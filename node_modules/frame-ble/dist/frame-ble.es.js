var m = Object.defineProperty;
var p = (w, e, a) => e in w ? m(w, e, { enumerable: !0, configurable: !0, writable: !0, value: a }) : w[e] = a;
var c = (w, e, a) => p(w, typeof e != "symbol" ? e + "" : e, a);
class R {
  constructor() {
    c(this, "device");
    c(this, "server");
    c(this, "txCharacteristic");
    c(this, "rxCharacteristic");
    c(this, "SERVICE_UUID", "7a230001-5475-a6a4-654c-8431f6ad49c4");
    c(this, "TX_CHARACTERISTIC_UUID", "7a230002-5475-a6a4-654c-8431f6ad49c4");
    c(this, "RX_CHARACTERISTIC_UUID", "7a230003-5475-a6a4-654c-8431f6ad49c4");
    c(this, "maxPayload", 60);
    // will be set after connection
    c(this, "awaitingPrintResponse", !1);
    c(this, "awaitingDataResponse", !1);
    c(this, "printTimeoutId");
    c(this, "printResponsePromise");
    c(this, "printResolve");
    // Updated promise and resolve types for data responses
    c(this, "dataResponsePromise");
    c(this, "dataResolve");
    // Updated handler types
    c(this, "onDataResponse");
    c(this, "onPrintResponse");
    c(this, "onDisconnectHandler");
    c(this, "handleDisconnect", () => {
      this.device = void 0, this.server = void 0, this.txCharacteristic = void 0, this.rxCharacteristic = void 0, this.onDisconnectHandler && this.onDisconnectHandler();
    });
    c(this, "notificationHandler", (e) => {
      const i = e.target.value;
      if (!(!i || i.buffer.byteLength === 0))
        if (i.byteLength > 0 && i.getUint8(0) === 1) {
          const s = new Uint8Array(i.buffer, i.byteOffset + 1, i.byteLength - 1);
          if (this.awaitingDataResponse && this.dataResolve && (this.awaitingDataResponse = !1, this.dataResolve(s)), this.onDataResponse) {
            const r = this.onDataResponse(s);
            r instanceof Promise && r.catch(console.error);
          }
        } else {
          const s = new TextDecoder().decode(i);
          if (this.awaitingPrintResponse && this.printResolve && (this.awaitingPrintResponse = !1, this.printResolve(s)), this.onPrintResponse) {
            const r = this.onPrintResponse(s);
            r instanceof Promise && r.catch(console.error);
          }
        }
    });
  }
  /**
   * Sets or updates the handler for asynchronous data responses from the device.
   * @param handler The function to call when data (as Uint8Array) is received.
   * Pass undefined to remove the current handler.
   */
  setDataResponseHandler(e) {
    this.onDataResponse = e;
  }
  /**
   * Sets or updates the handler for asynchronous print (string) responses from the device.
   * @param handler The function to call when a print string is received.
   * Pass undefined to remove the current handler.
   */
  setPrintResponseHandler(e) {
    this.onPrintResponse = e;
  }
  /**
   * Sets or updates the handler for disconnection events.
   * @param handler The function to call when the device disconnects.
   * Pass undefined to remove the current handler.
   */
  setDisconnectHandler(e) {
    this.onDisconnectHandler = e;
  }
  /**
   * Attempts to establish a connection with the device and set up characteristics.
   * This method is intended to be called internally by `connect` and handles a single connection attempt.
   */
  async _attemptConnection() {
    var e, a, i, s;
    if (!this.device || !this.device.gatt)
      throw new Error("Bluetooth device or GATT interface not available for connection attempt.");
    this.txCharacteristic = void 0, this.rxCharacteristic = void 0, this.server = void 0;
    try {
      console.log(`Attempting to connect to GATT server on device: ${this.device.name || this.device.id}...`), this.server = await this.device.gatt.connect(), console.log("GATT server connected."), console.log("Getting primary service...");
      const r = await this.server.getPrimaryService(this.SERVICE_UUID);
      console.log("Primary service obtained."), console.log("Getting TX characteristic..."), this.txCharacteristic = await r.getCharacteristic(this.TX_CHARACTERISTIC_UUID), console.log("TX characteristic obtained."), console.log("Getting RX characteristic..."), this.rxCharacteristic = await r.getCharacteristic(this.RX_CHARACTERISTIC_UUID), console.log("RX characteristic obtained."), console.log("Starting notifications on RX characteristic..."), await this.rxCharacteristic.startNotifications(), this.rxCharacteristic.addEventListener("characteristicvaluechanged", this.notificationHandler), console.log("Notifications started."), await this.sendBreakSignal(!1), console.log("Fetching MTU size (max_length) from device...");
      const t = await this.sendLua("print(frame.bluetooth.max_length())", { awaitPrint: !0 });
      if (t == null)
        throw new Error("Failed to get MTU size from device: no response.");
      const n = parseInt(t);
      if (isNaN(n) || n <= 0)
        throw new Error(`Invalid MTU size received: '${t}'`);
      this.maxPayload = n, console.log(`MTU size set to: ${this.maxPayload}`);
    } catch (r) {
      if (console.error("Error during connection attempt:", r), this.rxCharacteristic) {
        try {
          (a = (e = this.device) == null ? void 0 : e.gatt) != null && a.connected && await this.rxCharacteristic.stopNotifications();
        } catch {
        }
        this.rxCharacteristic.removeEventListener("characteristicvaluechanged", this.notificationHandler), this.rxCharacteristic = void 0;
      }
      throw this.txCharacteristic = void 0, (s = (i = this.device) == null ? void 0 : i.gatt) != null && s.connected && this.device.gatt.disconnect(), this.server = void 0, r;
    }
  }
  /**
  Connects to a Frame device. Prompts the user to select a device if one is not already known.
  Retries connection establishment on specific errors.
  */
  async connect(e = {}) {
    var h;
    const { name: a, namePrefix: i, numAttempts: s = 5, retryDelayMs: r = 1e3 } = e;
    if (!navigator.bluetooth)
      throw new Error("Web Bluetooth API not available.");
    if (!this.device) {
      const o = {
        filters: [a ? { services: [this.SERVICE_UUID], name: a } : i ? { services: [this.SERVICE_UUID], namePrefix: i } : { services: [this.SERVICE_UUID] }],
        optionalServices: [this.SERVICE_UUID]
      };
      try {
        if (console.log("Requesting Bluetooth device from user..."), this.device = await navigator.bluetooth.requestDevice(o), !this.device)
          throw new Error("No device selected by the user.");
        console.log(`Device selected: ${this.device.name || this.device.id}`);
      } catch (f) {
        throw console.error("Bluetooth device request failed:", f), this.device = void 0, f;
      }
    }
    if (!this.device)
      throw new Error("Device not available after selection phase.");
    const t = this.device;
    t.removeEventListener("gattserverdisconnected", this.handleDisconnect), t.addEventListener("gattserverdisconnected", this.handleDisconnect);
    let n;
    for (let l = 1; l <= s; l++) {
      if (!this.device) {
        console.warn(`Device (id: ${t.id}) was disconnected externally during connection attempts.`), n = n || new Error(`Device disconnected externally during connection attempt ${l}.`);
        break;
      }
      try {
        return console.log(`Connection attempt ${l} of ${s} to device '${t.name || t.id}'...`), await this._attemptConnection(), console.log(`Successfully connected to ${t.name || t.id} on attempt ${l}.`), t.id || t.name || "Unknown Device";
      } catch (o) {
        if (n = o, console.error(`Attempt ${l} to connect to '${t.name || t.id}' failed:`, o), o instanceof Error && o.name === "NetworkError" && // DOMException name
        (o.message.includes("Connection attempt failed.") || o.message.includes("GATT operation failed for unknown reason.") || o.message.includes("GATT Server is disconnected.") || // Potentially retryable if transient
        o.message.includes("Bluetooth device is already connected.")) && l < s)
          console.log(`Retryable error encountered. Retrying in ${r / 1e3}s...`), await new Promise((d) => setTimeout(d, r));
        else {
          console.log("Non-retryable error or max attempts reached. Aborting connection process.");
          break;
        }
      }
    }
    throw console.error(`Failed to connect to device '${t.name || t.id}' after ${s} attempts or due to external disconnection.`), t.removeEventListener("gattserverdisconnected", this.handleDisconnect), (h = t.gatt) != null && h.connected && t.gatt.disconnect(), this.server = void 0, this.txCharacteristic = void 0, this.rxCharacteristic = void 0, this.device = void 0, n || new Error(`Failed to connect to ${t.name || t.id} after ${s} attempts. No specific error recorded, or device disconnected externally.`);
  }
  async disconnect() {
    var e;
    this.device && ((e = this.device.gatt) != null && e.connected) ? this.device.gatt.disconnect() : this.handleDisconnect();
  }
  isConnected() {
    return !!(this.device && this.device.gatt && this.device.gatt.connected);
  }
  getMaxPayload(e) {
    return e ? this.maxPayload : this.maxPayload - 1;
  }
  async transmit(e, a = !1) {
    if (!this.txCharacteristic)
      throw new Error("Not connected or TX characteristic not available.");
    if (e.byteLength > this.maxPayload)
      throw new Error(`Payload length: ${e.byteLength} exceeds maximum BLE packet size: ${this.maxPayload}`);
    a && console.log("Transmitting (hex):", Array.from(e).map((i) => i.toString(16).padStart(2, "0")).join(" ")), await this.txCharacteristic.writeValueWithResponse(e);
  }
  async sendLua(e, a = {}) {
    const { showMe: i = !1, awaitPrint: s = !1, timeout: r = 5e3 } = a, t = new TextEncoder().encode(e);
    if (t.byteLength > this.getMaxPayload(!0))
      throw new Error(`Lua string payload (${t.byteLength} bytes) is too large for max Lua payload (${this.getMaxPayload(!0)} bytes).`);
    if (s && (this.printTimeoutId && clearTimeout(this.printTimeoutId), this.awaitingPrintResponse = !0, this.printResponsePromise = new Promise((n, h) => {
      this.printResolve = n, this.printTimeoutId = setTimeout(() => {
        this.awaitingPrintResponse && (this.awaitingPrintResponse = !1, this.printResolve = void 0, h(new Error(`Device didn't respond with a print within ${r}ms.`)));
      }, r);
    }).finally(() => {
      this.printTimeoutId && (clearTimeout(this.printTimeoutId), this.printTimeoutId = void 0);
    })), await this.transmit(t, i), s) return this.printResponsePromise;
  }
  /**
   * Sends raw data to the device. The data is prefixed with 0x01.
   * @param data The raw application payload to send as Uint8Array.
   * @param options Configuration for sending data.
   * @returns A promise that resolves with the Uint8Array data response if awaitData is true, or void otherwise.
   */
  async sendData(e, a = {}) {
    const { showMe: i = !1, awaitData: s = !1, timeout: r = 5e3 } = a;
    if (!this.txCharacteristic)
      throw new Error("Not connected or TX characteristic not available.");
    if (e.byteLength > this.getMaxPayload(!1))
      throw new Error(`Data payload (${e.byteLength} bytes) is too large for max data payload (${this.getMaxPayload(!1)} bytes).`);
    const t = new Uint8Array([1]), n = new Uint8Array(t.length + e.byteLength);
    n.set(t, 0), n.set(e, t.length);
    let h;
    if (s && (this.awaitingDataResponse = !0, this.dataResponsePromise = new Promise((l, o) => {
      this.dataResolve = l, h = setTimeout(() => {
        this.awaitingDataResponse && (this.awaitingDataResponse = !1, this.dataResolve = void 0, o(new Error(`Device didn't respond with data within ${r}ms.`)));
      }, r);
    }).finally(() => {
      h && clearTimeout(h);
    })), await this.transmit(n, i), s) return this.dataResponsePromise;
  }
  async sendResetSignal(e = !1) {
    const a = new Uint8Array([4]);
    await this.transmit(a, e), await new Promise((i) => setTimeout(i, 200));
  }
  async sendBreakSignal(e = !1) {
    const a = new Uint8Array([3]);
    await this.transmit(a, e), await new Promise((i) => setTimeout(i, 200));
  }
  async uploadFileFromString(e, a = "main.lua") {
    let i = e.replace(/\r/g, "").replace(/\\/g, "\\\\").replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/'/g, "\\'").replace(/"/g, '\\"');
    const s = await this.sendLua(`f=frame.file.open('${a}','w');print(1)`, { awaitPrint: !0 });
    if (s !== "1")
      throw new Error(`Failed to open file ${a} on device. Response: ${s}`);
    const t = this.getMaxPayload(!0) - 20;
    if (t <= 0)
      throw new Error("Max payload size too small for file upload operations.");
    let n = 0;
    for (; n < i.length; ) {
      let h = Math.min(t, i.length - n), l = i.substring(n, n + h);
      for (; l.endsWith("\\"); ) {
        let f = 0;
        for (let d = l.length - 1; d >= 0 && l[d] === "\\"; d--)
          f++;
        if (f % 2 !== 0)
          if (h > 1)
            h--, l = i.substring(n, n + h);
          else
            throw await this.sendLua("f:close();print(nil)", { awaitPrint: !0 }), new Error("Cannot safely chunk content due to isolated escape character at chunk boundary.");
        else
          break;
      }
      const o = await this.sendLua(`f:write("${l}");print(1)`, { awaitPrint: !0 });
      if (o !== "1")
        throw await this.sendLua("f:close();print(nil)", { awaitPrint: !0 }), new Error(`Failed to write chunk to ${a}. Response: ${o}`);
      n += h;
    }
    await this.sendLua("f:close();print(nil)", { awaitPrint: !0 });
  }
  async uploadFile(e, a = "main.lua") {
    await this.uploadFileFromString(e, a);
  }
  async sendMessage(e, a, i = !1) {
    if (e < 0 || e > 255)
      throw new Error(`Message code must be 0-255, got ${e}`);
    const t = a.byteLength;
    if (t > 65535)
      throw new Error(`Payload size ${t} exceeds maximum 65535 bytes`);
    const n = this.getMaxPayload(!1), h = n - 1 - 2, l = n - 1;
    if (h <= 0 || l <= 0)
      throw new Error("Max payload size too small for message sending protocol.");
    let o = 0;
    const f = Math.min(h, t), d = new Uint8Array(3 + f);
    for (d[0] = e, d[1] = t >> 8, d[2] = t & 255, d.set(a.subarray(0, f), 3), await this.sendData(d, { showMe: i, awaitData: !0 }), o += f; o < t; ) {
      const v = t - o, g = Math.min(l, v), u = new Uint8Array(1 + g);
      u[0] = e, u.set(a.subarray(o, o + g), 1), await this.sendData(u, { showMe: i, awaitData: !0 }), o += g;
    }
  }
}
export {
  R as FrameBle
};
