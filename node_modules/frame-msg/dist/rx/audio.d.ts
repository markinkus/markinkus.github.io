import { FrameMsg } from '../frame-msg';
import { AsyncQueue } from '../async-queue';
export declare enum RxAudioSampleRate {
    SAMPLE_RATE_8KHZ = 8000,
    SAMPLE_RATE_16KHZ = 16000
}
export declare enum RxAudioBitDepth {
    BIT_DEPTH_8 = 8,
    BIT_DEPTH_16 = 16
}
export interface RxAudioOptions {
    nonFinalChunkFlag?: number;
    finalChunkFlag?: number;
    streaming?: boolean;
    sampleRate?: RxAudioSampleRate;
    bitDepth?: RxAudioBitDepth;
}
/**
 * RxAudio class handles audio data streaming and processing.
 * It can operate in two modes: streaming and single-clip mode.
 * In streaming mode, it processes audio data in real-time.
 * In single-clip mode, it accumulates audio data until a final chunk is received.
 * The class provides methods to attach and detach from a FrameMsg instance,
 * and to convert PCM data to WAV format.
 * Depending on how it is constructed, it will return samples as either
 * signed 8 or signed 16 bit integers, and the source bit depth in Lua should match.
 */
export declare class RxAudio {
    private nonFinalChunkFlag;
    private finalChunkFlag;
    private streaming;
    private bitDepth;
    private sampleRate;
    queue: AsyncQueue<Int8Array | Int16Array | null> | null;
    private _audioBuffer;
    constructor(options?: RxAudioOptions);
    private concatenateAudioData;
    handleData(data: Uint8Array): void;
    attach(frame: FrameMsg): Promise<AsyncQueue<Int8Array | Int16Array | null>>;
    detach(frame: FrameMsg): void;
    private static writeString;
    static toWavBytes(pcmData: Uint8Array, sampleRate?: number, bitsPerSample?: number, channels?: number): Uint8Array;
    static pcm8BitToFloat32(pcmData: Uint8Array): Float32Array<ArrayBuffer>;
    static pcm16BitToFloat32(pcmData: Uint8Array): Float32Array<ArrayBuffer>;
}
