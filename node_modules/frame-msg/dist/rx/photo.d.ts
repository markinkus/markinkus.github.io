import { FrameMsg } from '../frame-msg';
import { AsyncQueue } from '../async-queue';
export type JpegQuality = 'VERY_LOW' | 'LOW' | 'MEDIUM' | 'HIGH' | 'VERY_HIGH';
export interface RxPhotoOptions {
    nonFinalChunkFlag?: number;
    finalChunkFlag?: number;
    upright?: boolean;
    isRaw?: boolean;
    quality?: JpegQuality | null;
    resolution?: number | null;
}
/**
 * RxPhoto class handles JPEG image data streaming and processing.
 * It can process JPEG images with or without a header ("raw" mode), although at least one
 * compatible JPEG header must be cached before using raw mode.
 * It can also rotate images 90 degrees counter-clockwise to upright (default behavior).
 * Different JPEG qualities and resolutions can be specified.
 */
export declare class RxPhoto {
    private static _jpegHeaderMap;
    private nonFinalChunkFlag;
    private finalChunkFlag;
    private upright;
    private isRaw;
    private quality;
    private resolution;
    queue: AsyncQueue<Uint8Array> | null;
    private _imageDataChunks;
    constructor(options?: RxPhotoOptions);
    static hasJpegHeader(quality: JpegQuality, resolution: number): boolean;
    private concatenateImageData;
    handleData(data: Uint8Array): void;
    private _processCompleteImage;
    attach(frame: FrameMsg): Promise<AsyncQueue<Uint8Array>>;
    detach(frame: FrameMsg): void;
    /**
     * Rotates a JPEG image 90 degrees counter-clockwise using an offscreen canvas.
     * @param inputBytes The input JPEG image as a Uint8Array.
     * @returns the rotated JPEG image as a Uint8Array.
     */
    rotateJpeg90CounterClockwise(inputBytes: Uint8Array): Promise<Uint8Array>;
}
