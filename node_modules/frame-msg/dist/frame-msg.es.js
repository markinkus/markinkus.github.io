var Yt = Object.defineProperty;
var Bt = (e) => {
  throw TypeError(e);
};
var Zt = (e, i, t) => i in e ? Yt(e, i, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[i] = t;
var $e = (e, i, t) => Zt(e, typeof i != "symbol" ? i + "" : i, t), Tt = (e, i, t) => i.has(e) || Bt("Cannot " + t);
var St = (e, i, t) => (Tt(e, i, "read from private field"), t ? t.call(e) : i.get(e)), It = (e, i, t) => i.has(e) ? Bt("Cannot add the same private member more than once") : i instanceof WeakSet ? i.add(e) : i.set(e, t), Dt = (e, i, t, r) => (Tt(e, i, "write to private field"), r ? r.call(e, t) : i.set(e, t), t), $t = (e, i, t) => (Tt(e, i, "access private method"), t);
var m = Object.defineProperty, p = (e, i, t) => i in e ? m(e, i, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[i] = t, c = (e, i, t) => p(e, typeof i != "symbol" ? i + "" : i, t);
class R {
  constructor() {
    c(this, "device"), c(this, "server"), c(this, "txCharacteristic"), c(this, "rxCharacteristic"), c(this, "SERVICE_UUID", "7a230001-5475-a6a4-654c-8431f6ad49c4"), c(this, "TX_CHARACTERISTIC_UUID", "7a230002-5475-a6a4-654c-8431f6ad49c4"), c(this, "RX_CHARACTERISTIC_UUID", "7a230003-5475-a6a4-654c-8431f6ad49c4"), c(this, "maxPayload", 60), c(this, "awaitingPrintResponse", !1), c(this, "awaitingDataResponse", !1), c(this, "printTimeoutId"), c(this, "printResponsePromise"), c(this, "printResolve"), c(this, "dataResponsePromise"), c(this, "dataResolve"), c(this, "onDataResponse"), c(this, "onPrintResponse"), c(this, "onDisconnectHandler"), c(this, "handleDisconnect", () => {
      this.device = void 0, this.server = void 0, this.txCharacteristic = void 0, this.rxCharacteristic = void 0, this.onDisconnectHandler && this.onDisconnectHandler();
    }), c(this, "notificationHandler", (i) => {
      const t = i.target.value;
      if (!(!t || t.buffer.byteLength === 0))
        if (t.byteLength > 0 && t.getUint8(0) === 1) {
          const r = new Uint8Array(t.buffer, t.byteOffset + 1, t.byteLength - 1);
          if (this.awaitingDataResponse && this.dataResolve && (this.awaitingDataResponse = !1, this.dataResolve(r)), this.onDataResponse) {
            const n = this.onDataResponse(r);
            n instanceof Promise && n.catch(console.error);
          }
        } else {
          const r = new TextDecoder().decode(t);
          if (this.awaitingPrintResponse && this.printResolve && (this.awaitingPrintResponse = !1, this.printResolve(r)), this.onPrintResponse) {
            const n = this.onPrintResponse(r);
            n instanceof Promise && n.catch(console.error);
          }
        }
    });
  }
  /**
   * Sets or updates the handler for asynchronous data responses from the device.
   * @param handler The function to call when data (as Uint8Array) is received.
   * Pass undefined to remove the current handler.
   */
  setDataResponseHandler(i) {
    this.onDataResponse = i;
  }
  /**
   * Sets or updates the handler for asynchronous print (string) responses from the device.
   * @param handler The function to call when a print string is received.
   * Pass undefined to remove the current handler.
   */
  setPrintResponseHandler(i) {
    this.onPrintResponse = i;
  }
  /**
   * Sets or updates the handler for disconnection events.
   * @param handler The function to call when the device disconnects.
   * Pass undefined to remove the current handler.
   */
  setDisconnectHandler(i) {
    this.onDisconnectHandler = i;
  }
  /**
   * Attempts to establish a connection with the device and set up characteristics.
   * This method is intended to be called internally by `connect` and handles a single connection attempt.
   */
  async _attemptConnection() {
    var i, t, r, n;
    if (!this.device || !this.device.gatt)
      throw new Error("Bluetooth device or GATT interface not available for connection attempt.");
    this.txCharacteristic = void 0, this.rxCharacteristic = void 0, this.server = void 0;
    try {
      console.log(`Attempting to connect to GATT server on device: ${this.device.name || this.device.id}...`), this.server = await this.device.gatt.connect(), console.log("GATT server connected."), console.log("Getting primary service...");
      const a = await this.server.getPrimaryService(this.SERVICE_UUID);
      console.log("Primary service obtained."), console.log("Getting TX characteristic..."), this.txCharacteristic = await a.getCharacteristic(this.TX_CHARACTERISTIC_UUID), console.log("TX characteristic obtained."), console.log("Getting RX characteristic..."), this.rxCharacteristic = await a.getCharacteristic(this.RX_CHARACTERISTIC_UUID), console.log("RX characteristic obtained."), console.log("Starting notifications on RX characteristic..."), await this.rxCharacteristic.startNotifications(), this.rxCharacteristic.addEventListener("characteristicvaluechanged", this.notificationHandler), console.log("Notifications started."), await this.sendBreakSignal(!1), console.log("Fetching MTU size (max_length) from device...");
      const s = await this.sendLua("print(frame.bluetooth.max_length())", { awaitPrint: !0 });
      if (s == null)
        throw new Error("Failed to get MTU size from device: no response.");
      const o = parseInt(s);
      if (isNaN(o) || o <= 0)
        throw new Error(`Invalid MTU size received: '${s}'`);
      this.maxPayload = o, console.log(`MTU size set to: ${this.maxPayload}`);
    } catch (a) {
      if (console.error("Error during connection attempt:", a), this.rxCharacteristic) {
        try {
          (t = (i = this.device) == null ? void 0 : i.gatt) != null && t.connected && await this.rxCharacteristic.stopNotifications();
        } catch {
        }
        this.rxCharacteristic.removeEventListener("characteristicvaluechanged", this.notificationHandler), this.rxCharacteristic = void 0;
      }
      throw this.txCharacteristic = void 0, (n = (r = this.device) == null ? void 0 : r.gatt) != null && n.connected && this.device.gatt.disconnect(), this.server = void 0, a;
    }
  }
  /**
  Connects to a Frame device. Prompts the user to select a device if one is not already known.
  Retries connection establishment on specific errors.
  */
  async connect(i = {}) {
    var t;
    const { name: r, namePrefix: n, numAttempts: a = 5, retryDelayMs: s = 1e3 } = i;
    if (!navigator.bluetooth)
      throw new Error("Web Bluetooth API not available.");
    if (!this.device) {
      const l = {
        filters: [r ? { services: [this.SERVICE_UUID], name: r } : n ? { services: [this.SERVICE_UUID], namePrefix: n } : { services: [this.SERVICE_UUID] }],
        optionalServices: [this.SERVICE_UUID]
      };
      try {
        if (console.log("Requesting Bluetooth device from user..."), this.device = await navigator.bluetooth.requestDevice(l), !this.device)
          throw new Error("No device selected by the user.");
        console.log(`Device selected: ${this.device.name || this.device.id}`);
      } catch (f) {
        throw console.error("Bluetooth device request failed:", f), this.device = void 0, f;
      }
    }
    if (!this.device)
      throw new Error("Device not available after selection phase.");
    const o = this.device;
    o.removeEventListener("gattserverdisconnected", this.handleDisconnect), o.addEventListener("gattserverdisconnected", this.handleDisconnect);
    let h;
    for (let l = 1; l <= a; l++) {
      if (!this.device) {
        console.warn(`Device (id: ${o.id}) was disconnected externally during connection attempts.`), h = h || new Error(`Device disconnected externally during connection attempt ${l}.`);
        break;
      }
      try {
        return console.log(`Connection attempt ${l} of ${a} to device '${o.name || o.id}'...`), await this._attemptConnection(), console.log(`Successfully connected to ${o.name || o.id} on attempt ${l}.`), o.id || o.name || "Unknown Device";
      } catch (f) {
        if (h = f, console.error(`Attempt ${l} to connect to '${o.name || o.id}' failed:`, f), f instanceof Error && f.name === "NetworkError" && // DOMException name
        (f.message.includes("Connection attempt failed.") || f.message.includes("GATT operation failed for unknown reason.") || f.message.includes("GATT Server is disconnected.") || // Potentially retryable if transient
        f.message.includes("Bluetooth device is already connected.")) && l < a)
          console.log(`Retryable error encountered. Retrying in ${s / 1e3}s...`), await new Promise((b) => setTimeout(b, s));
        else {
          console.log("Non-retryable error or max attempts reached. Aborting connection process.");
          break;
        }
      }
    }
    throw console.error(`Failed to connect to device '${o.name || o.id}' after ${a} attempts or due to external disconnection.`), o.removeEventListener("gattserverdisconnected", this.handleDisconnect), (t = o.gatt) != null && t.connected && o.gatt.disconnect(), this.server = void 0, this.txCharacteristic = void 0, this.rxCharacteristic = void 0, this.device = void 0, h || new Error(`Failed to connect to ${o.name || o.id} after ${a} attempts. No specific error recorded, or device disconnected externally.`);
  }
  async disconnect() {
    var i;
    this.device && (i = this.device.gatt) != null && i.connected ? this.device.gatt.disconnect() : this.handleDisconnect();
  }
  isConnected() {
    return !!(this.device && this.device.gatt && this.device.gatt.connected);
  }
  getMaxPayload(i) {
    return i ? this.maxPayload : this.maxPayload - 1;
  }
  async transmit(i, t = !1) {
    if (!this.txCharacteristic)
      throw new Error("Not connected or TX characteristic not available.");
    if (i.byteLength > this.maxPayload)
      throw new Error(`Payload length: ${i.byteLength} exceeds maximum BLE packet size: ${this.maxPayload}`);
    t && console.log("Transmitting (hex):", Array.from(i).map((r) => r.toString(16).padStart(2, "0")).join(" ")), await this.txCharacteristic.writeValueWithResponse(i);
  }
  async sendLua(i, t = {}) {
    const { showMe: r = !1, awaitPrint: n = !1, timeout: a = 5e3 } = t, s = new TextEncoder().encode(i);
    if (s.byteLength > this.getMaxPayload(!0))
      throw new Error(`Lua string payload (${s.byteLength} bytes) is too large for max Lua payload (${this.getMaxPayload(!0)} bytes).`);
    if (n && (this.printTimeoutId && clearTimeout(this.printTimeoutId), this.awaitingPrintResponse = !0, this.printResponsePromise = new Promise((o, h) => {
      this.printResolve = o, this.printTimeoutId = setTimeout(() => {
        this.awaitingPrintResponse && (this.awaitingPrintResponse = !1, this.printResolve = void 0, h(new Error(`Device didn't respond with a print within ${a}ms.`)));
      }, a);
    }).finally(() => {
      this.printTimeoutId && (clearTimeout(this.printTimeoutId), this.printTimeoutId = void 0);
    })), await this.transmit(s, r), n) return this.printResponsePromise;
  }
  /**
   * Sends raw data to the device. The data is prefixed with 0x01.
   * @param data The raw application payload to send as Uint8Array.
   * @param options Configuration for sending data.
   * @returns A promise that resolves with the Uint8Array data response if awaitData is true, or void otherwise.
   */
  async sendData(i, t = {}) {
    const { showMe: r = !1, awaitData: n = !1, timeout: a = 5e3 } = t;
    if (!this.txCharacteristic)
      throw new Error("Not connected or TX characteristic not available.");
    if (i.byteLength > this.getMaxPayload(!1))
      throw new Error(`Data payload (${i.byteLength} bytes) is too large for max data payload (${this.getMaxPayload(!1)} bytes).`);
    const s = new Uint8Array([1]), o = new Uint8Array(s.length + i.byteLength);
    o.set(s, 0), o.set(i, s.length);
    let h;
    if (n && (this.awaitingDataResponse = !0, this.dataResponsePromise = new Promise((l, f) => {
      this.dataResolve = l, h = setTimeout(() => {
        this.awaitingDataResponse && (this.awaitingDataResponse = !1, this.dataResolve = void 0, f(new Error(`Device didn't respond with data within ${a}ms.`)));
      }, a);
    }).finally(() => {
      h && clearTimeout(h);
    })), await this.transmit(o, r), n) return this.dataResponsePromise;
  }
  async sendResetSignal(i = !1) {
    const t = new Uint8Array([4]);
    await this.transmit(t, i), await new Promise((r) => setTimeout(r, 200));
  }
  async sendBreakSignal(i = !1) {
    const t = new Uint8Array([3]);
    await this.transmit(t, i), await new Promise((r) => setTimeout(r, 200));
  }
  async uploadFileFromString(i, t = "main.lua") {
    let r = i.replace(/\r/g, "").replace(/\\/g, "\\\\").replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/'/g, "\\'").replace(/"/g, '\\"');
    const n = await this.sendLua(`f=frame.file.open('${t}','w');print(1)`, { awaitPrint: !0 });
    if (n !== "1")
      throw new Error(`Failed to open file ${t} on device. Response: ${n}`);
    const a = this.getMaxPayload(!0) - 20;
    if (a <= 0)
      throw new Error("Max payload size too small for file upload operations.");
    let s = 0;
    for (; s < r.length; ) {
      let o = Math.min(a, r.length - s), h = r.substring(s, s + o);
      for (; h.endsWith("\\"); ) {
        let f = 0;
        for (let b = h.length - 1; b >= 0 && h[b] === "\\"; b--)
          f++;
        if (f % 2 !== 0)
          if (o > 1)
            o--, h = r.substring(s, s + o);
          else
            throw await this.sendLua("f:close();print(nil)", { awaitPrint: !0 }), new Error("Cannot safely chunk content due to isolated escape character at chunk boundary.");
        else
          break;
      }
      const l = await this.sendLua(`f:write("${h}");print(1)`, { awaitPrint: !0 });
      if (l !== "1")
        throw await this.sendLua("f:close();print(nil)", { awaitPrint: !0 }), new Error(`Failed to write chunk to ${t}. Response: ${l}`);
      s += o;
    }
    await this.sendLua("f:close();print(nil)", { awaitPrint: !0 });
  }
  async uploadFile(i, t = "main.lua") {
    await this.uploadFileFromString(i, t);
  }
  async sendMessage(i, t, r = !1) {
    if (i < 0 || i > 255)
      throw new Error(`Message code must be 0-255, got ${i}`);
    const n = t.byteLength;
    if (n > 65535)
      throw new Error(`Payload size ${n} exceeds maximum 65535 bytes`);
    const a = this.getMaxPayload(!1), s = a - 1 - 2, o = a - 1;
    if (s <= 0 || o <= 0)
      throw new Error("Max payload size too small for message sending protocol.");
    let h = 0;
    const l = Math.min(s, n), f = new Uint8Array(3 + l);
    for (f[0] = i, f[1] = n >> 8, f[2] = n & 255, f.set(t.subarray(0, l), 3), await this.sendData(f, { showMe: r, awaitData: !0 }), h += l; h < n; ) {
      const b = n - h, w = Math.min(o, b), g = new Uint8Array(1 + w);
      g[0] = i, g.set(t.subarray(h, h + w), 1), await this.sendData(g, { showMe: r, awaitData: !0 }), h += w;
    }
  }
}
const stdDataMinLua = "local a={}local b={}a.app_data_accum=b;local c={}a.app_data_block=c;local d={}a.app_data=d;local e={}a.parsers=e;function a.update_app_data_accum(f)rc,err=pcall(function()local g=string.byte(f,1)local h=a.app_data_accum[g]if h==nil or next(h)==nil then h={chunk_table={},num_chunks=0,size=0,recv_bytes=0}a.app_data_accum[g]=h end;if h.num_chunks==0 then h.size=string.byte(f,2)<<8|string.byte(f,3)h.chunk_table[1]=string.sub(f,4)h.num_chunks=1;h.recv_bytes=string.len(f)-3;if h.recv_bytes==h.size then a.app_data_block[g]=h.chunk_table[1]h.size=0;h.recv_bytes=0;h.num_chunks=0;h.chunk_table[1]=nil;b[g]=h end else h.chunk_table[h.num_chunks+1]=string.sub(f,2)h.num_chunks=h.num_chunks+1;h.recv_bytes=h.recv_bytes+string.len(f)-1;if h.recv_bytes==h.size then collectgarbage('collect')a.app_data_block[g]=table.concat(h.chunk_table)for i,j in pairs(h.chunk_table)do h.chunk_table[i]=nil end;collectgarbage('collect')h.size=0;h.recv_bytes=0;h.num_chunks=0;a.app_data_accum[g]=h end end;while true do if pcall(frame.bluetooth.send,'\\x00')then break end;frame.sleep(0.0025)end end)if rc==false then print('Error in data accumulator: '..err)while true do if pcall(frame.bluetooth.send,'\\x01')then break end;frame.sleep(0.0025)end;error(err)end end;frame.bluetooth.receive_callback(a.update_app_data_accum)function a.process_raw_items()local k=0;rc,err=pcall(function()collectgarbage('collect')for l,m in pairs(a.app_data_block)do if a.parsers[l]==nil then print('Error: No parser for flag: '..tostring(l))else a.app_data[l]=a.parsers[l](m,a.app_data[l])a.app_data_block[l]=nil;k=k+1 end end end)if rc==false then print('Error processing raw items: '..err)error(err)end;return k end;return a", stdAudioMinLua = "local a={}local b=0x06;local c=0x05;local d=frame.bluetooth.max_length()if d%2==1 then d=d-1 end;function a.start(e)local f=e and e.sample_rate or 8000;local g=e and e.bit_depth or 8;pcall(frame.microphone.start,{sample_rate=f,bit_depth=g})end;function a.stop()pcall(frame.microphone.stop)end;function a.read_and_send_audio()audio_data=frame.microphone.read(d)if audio_data==nil then while true do if pcall(frame.bluetooth.send,string.char(b))then break end end;return nil elseif audio_data~=''then while true do if pcall(frame.bluetooth.send,string.char(c)..audio_data)then break end end;return string.len(audio_data)end;return 0 end;return a", stdCameraMinLua = `local a={}local b=0x07;local c=0x08;local d=0x11;local e=0x12;local f={'VERY_LOW','LOW','MEDIUM','HIGH','VERY_HIGH'}local g={'SPOT','CENTER_WEIGHTED','AVERAGE'}local h={metering='CENTER_WEIGHTED',exposure=0.1,exposure_speed=0.45,shutter_limit=16383,analog_gain_limit=16.0,white_balance_speed=0.5,rgb_gain_limit=287}local i={shutter=4096,analog_gain=1,red_gain=121,green_gain=64,blue_gain=140}a.is_auto_exp=true;function update_if_present(j,k)for l,m in pairs(k)do if m~=nil then j[l]=m end end end;function a.set_auto_exp_settings(n)update_if_present(h,n)a.is_auto_exp=true end;function a.set_manual_exp_settings(n)a.is_auto_exp=false;update_if_present(i,n)frame.camera.set_shutter(i.shutter)frame.camera.set_gain(i.analog_gain)frame.camera.set_white_balance(i.red_gain,i.green_gain,i.blue_gain)end;function a.parse_auto_exp_settings(o)local j={}j.metering=g[string.byte(o,1)+1]j.exposure=string.byte(o,2)/255.0;j.exposure_speed=string.byte(o,3)/255.0;j.shutter_limit=string.byte(o,4)<<8|(string.byte(o,5)&0x3FFF)j.analog_gain_limit=string.byte(o,6)&0xFF;j.white_balance_speed=string.byte(o,7)/255.0;j.rgb_gain_limit=string.byte(o,8)<<8|(string.byte(o,9)&0x3FF)return j end;function a.parse_manual_exp_settings(o)local j={}j.shutter=string.byte(o,1)<<8|(string.byte(o,2)&0x3FFF)j.analog_gain=string.byte(o,3)&0xFF;j.red_gain=string.byte(o,4)<<8|(string.byte(o,5)&0x3FF)j.green_gain=string.byte(o,6)<<8|(string.byte(o,7)&0x3FF)j.blue_gain=string.byte(o,8)<<8|(string.byte(o,9)&0x3FF)return j end;function a.parse_capture_settings(o)local j={}j.quality=f[string.byte(o,1)+1]local p=string.byte(o,2)<<8|string.byte(o,3)j.resolution=p*2;local q=string.byte(o,4)<<8|string.byte(o,5)j.pan=q-140;j.raw=string.byte(o,6)>0;return j end;function send_data(o)local r=false;local s=frame.time.utc()+2;while frame.time.utc()<s do if pcall(frame.bluetooth.send,o)then r=true;break end end;if not r then error('Error sending photo data')end end;function a.run_auto_exposure()return frame.camera.auto(h)end;function a.send_autoexp_result(t)local o=string.pack("<Bffffffffffffffff",d,t['error'],t['shutter'],t['analog_gain'],t['red_gain'],t['green_gain'],t['blue_gain'],t['brightness']['center_weighted_average'],t['brightness']['scene'],t['brightness']['matrix']['r'],t['brightness']['matrix']['g'],t['brightness']['matrix']['b'],t['brightness']['matrix']['average'],t['brightness']['spot']['r'],t['brightness']['spot']['g'],t['brightness']['spot']['b'],t['brightness']['spot']['average'])send_data(o)end;function a.send_metering_data()send_data(string.char(e)..frame.fpga_read(0x25,6))end;function a.capture_and_send(n)frame.camera.capture{resolution=n.resolution,quality=n.quality,pan=n.pan}while not frame.camera.image_ready()do frame.sleep(0.005)end;local o=''local u=n.raw;while true do if u then o=frame.camera.read_raw(frame.bluetooth.max_length()-1)else o=frame.camera.read(frame.bluetooth.max_length()-1)end;if o~=nil then send_data(string.char(b)..o)else send_data(string.char(c))break end end end;return a`, stdCodeMinLua = "local _M={}function _M.parse_code(a)local b={}b.value=string.byte(a,1)return b end;return _M", stdIMUMinLua = 'local _M={}local a=0x0A;function _M.send_imu_data(b)local c=b or a;local d=frame.imu.raw()local e=string.pack("<Bxhhhhhh",c,d.compass.x,d.compass.y,d.compass.z,d.accelerometer.x,d.accelerometer.y,d.accelerometer.z)pcall(frame.bluetooth.send,e)end;return _M', stdImageSpriteBlockMinLua = "local a={}function a.parse_image_sprite_block(b,c)if string.byte(b,1)==0xFF then if c~=nil then for d,e in pairs(c.sprites)do c.sprites[d]=nil end;c=nil;collectgarbage('collect')end;local f={}f.width=string.byte(b,2)<<8|string.byte(b,3)f.height=string.byte(b,4)<<8|string.byte(b,5)f.sprite_line_height=string.byte(b,6)<<8|string.byte(b,7)f.progressive_render=string.byte(b,8)==1;f.updatable=string.byte(b,9)==1;f.sprites={}local g=f.height+f.sprite_line_height-1;f.total_sprites=g//f.sprite_line_height;f.active_sprites=0;f.current_sprite_index=0;return f else if c==nil then return nil end;c.current_sprite_index=c.current_sprite_index+1;if c.current_sprite_index>c.total_sprites then if c.updatable then c.current_sprite_index=1 else return c end end;if c.active_sprites<c.total_sprites then c.active_sprites=c.active_sprites+1 end;local h={}h.width=string.byte(b,1)<<8|string.byte(b,2)h.height=string.byte(b,3)<<8|string.byte(b,4)h.compressed=string.byte(b,5)>0;h.bpp=string.byte(b,6)h.num_colors=string.byte(b,7)h.palette_data=string.sub(b,8,8+h.num_colors*3-1)h.pixel_data=string.sub(b,8+h.num_colors*3)c.sprites[c.current_sprite_index]=h;return c end end;function a.set_palette(i,j)local k={'VOID','WHITE','GREY','RED','PINK','DARKBROWN','BROWN','ORANGE','YELLOW','DARKGREEN','GREEN','LIGHTGREEN','NIGHTBLUE','SEABLUE','SKYBLUE','CLOUDBLUE'}for l=1,i do local m=(l-1)*3;frame.display.assign_color(k[l],string.byte(j,m+1),string.byte(j,m+2),string.byte(j,m+3))end end;return a", stdPlainTextMinLua = "local _M={}local a={'VOID','WHITE','GREY','RED','PINK','DARKBROWN','BROWN','ORANGE','YELLOW','DARKGREEN','GREEN','LIGHTGREEN','NIGHTBLUE','SEABLUE','SKYBLUE','CLOUDBLUE'}function _M.parse_plain_text(b)local c={}c.x=string.byte(b,1)<<8|string.byte(b,2)c.y=string.byte(b,3)<<8|string.byte(b,4)c.palette_offset=string.byte(b,5)c.color=a[c.palette_offset%16+1]c.spacing=string.byte(b,6)c.string=string.sub(b,7)return c end;return _M", stdSpriteMinLua = "local a={}function a.parse_sprite(b)local c={}c.width=string.byte(b,1)<<8|string.byte(b,2)c.height=string.byte(b,3)<<8|string.byte(b,4)c.compressed=string.byte(b,5)>0;c.bpp=string.byte(b,6)c.num_colors=string.byte(b,7)c.palette_data=string.sub(b,8,8+c.num_colors*3-1)c.pixel_data=string.sub(b,8+c.num_colors*3)return c end;function a.set_palette(d,e)local f={'VOID','WHITE','GREY','RED','PINK','DARKBROWN','BROWN','ORANGE','YELLOW','DARKGREEN','GREEN','LIGHTGREEN','NIGHTBLUE','SEABLUE','SKYBLUE','CLOUDBLUE'}for g=1,d do local h=(g-1)*3;frame.display.assign_color(f[g],string.byte(e,h+1),string.byte(e,h+2),string.byte(e,h+3))end end;return a", stdSpriteCoordsMinLua = "local a={}function a.parse_sprite_coords(b)local c={}c.code=string.byte(b,1)c.x=string.byte(b,2)<<8|string.byte(b,3)c.y=string.byte(b,4)<<8|string.byte(b,5)c.offset=string.byte(b,6)return c end;return a", stdTapMinLua = "local a={}local b=0x09;function a.send_tap()rc,err=pcall(frame.bluetooth.send,string.char(b))if rc==false then print(err)end end;return a", stdTextSpriteBlockMinLua = "local a={}function a.parse_text_sprite_block(b,c)if string.byte(b,1)==0xFF then local d={}d.width=string.byte(b,2)<<8|string.byte(b,3)d.max_display_rows=string.byte(b,4)d.lines=string.byte(b,5)local e={}for f=0,d.lines-1 do local g={}g.x=string.byte(b,5+4*f+1)<<8|string.byte(b,5+4*f+2)g.y=string.byte(b,5+4*f+3)<<8|string.byte(b,5+4*f+4)table.insert(e,g)end;d.offsets=e;d.sprites={}d.last_sprite_index=0;d.first_sprite_index=0;return d else if c==nil then return nil end;c.last_sprite_index=c.last_sprite_index+1;if c.first_sprite_index==0 then c.first_sprite_index=1 end;if c.last_sprite_index-c.first_sprite_index+1>c.max_display_rows then c.sprites[c.first_sprite_index]=nil;c.first_sprite_index=c.first_sprite_index+1 end;local h={}h.width=string.byte(b,1)<<8|string.byte(b,2)h.height=string.byte(b,3)<<8|string.byte(b,4)h.compressed=string.byte(b,5)>0;h.bpp=string.byte(b,6)h.num_colors=string.byte(b,7)h.palette_data=string.sub(b,8,8+h.num_colors*3-1)h.pixel_data=string.sub(b,8+h.num_colors*3)c.sprites[c.last_sprite_index]=h;return c end end;return a";
var StdLua = /* @__PURE__ */ ((e) => (e.DataMin = "stdDataMin", e.AudioMin = "stdAudioMin", e.CameraMin = "stdCameraMin", e.CodeMin = "stdCodeMin", e.IMUMin = "stdIMUMin", e.ImageSpriteBlockMin = "stdImageSpriteBlockMin", e.PlainTextMin = "stdPlainTextMin", e.SpriteMin = "stdSpriteMin", e.SpriteCoordsMin = "stdSpriteCoordsMin", e.TapMin = "stdTapMin", e.TextSpriteBlockMin = "stdTextSpriteBlockMin", e))(StdLua || {});
const standardLuaLibrarySources = {
  stdDataMin: { content: stdDataMinLua, targetFileName: "data.min.lua" },
  stdAudioMin: { content: stdAudioMinLua, targetFileName: "audio.min.lua" },
  stdCameraMin: { content: stdCameraMinLua, targetFileName: "camera.min.lua" },
  stdCodeMin: { content: stdCodeMinLua, targetFileName: "code.min.lua" },
  stdIMUMin: { content: stdIMUMinLua, targetFileName: "imu.min.lua" },
  stdImageSpriteBlockMin: { content: stdImageSpriteBlockMinLua, targetFileName: "image_sprite_block.min.lua" },
  stdPlainTextMin: { content: stdPlainTextMinLua, targetFileName: "plain_text.min.lua" },
  stdSpriteMin: { content: stdSpriteMinLua, targetFileName: "sprite.min.lua" },
  stdSpriteCoordsMin: { content: stdSpriteCoordsMinLua, targetFileName: "sprite_coords.min.lua" },
  stdTapMin: { content: stdTapMinLua, targetFileName: "tap.min.lua" },
  stdTextSpriteBlockMin: { content: stdTextSpriteBlockMinLua, targetFileName: "text_sprite_block.min.lua" }
};
class FrameMsg {
  constructor() {
    $e(this, "ble");
    $e(this, "dataResponseHandlers");
    this.ble = new R(), this.dataResponseHandlers = /* @__PURE__ */ new Map(), this.ble.setDataResponseHandler(this._handleDataResponse.bind(this));
  }
  /**
   * Connects to the Frame device and optionally runs the initialization sequence.
   * Note: Print and Disconnect handlers should be set directly on the FrameBle instance
   * (e.g., `frameMsg.ble.setPrintResponseHandler(...)`, `frameMsg.ble.setDisconnectHandler(...)`)
   * or via `frameMsg.attachPrintResponseHandler(...)` before or after calling connect.
   * @param initialize If true, runs the break/reset/break sequence after connecting. Defaults to true.
   * @param connectOptions Options including name and namePrefix for device filtering.
   * @returns The device ID or name if connection was successful.
   * @throws Any exceptions from the underlying FrameBle connection or initialization.
   */
  async connect(i = !0, t = {}) {
    try {
      const r = {
        name: t.name,
        namePrefix: t.namePrefix
      }, n = await this.ble.connect(r);
      return i && (await this.ble.sendBreakSignal(), await this.ble.sendResetSignal(), await this.ble.sendBreakSignal()), n;
    } catch (r) {
      throw this.ble.isConnected() && await this.ble.disconnect(), r;
    }
  }
  async disconnect() {
    this.ble.isConnected() && await this.ble.disconnect();
  }
  isConnected() {
    return this.ble.isConnected();
  }
  async printShortText(i = "") {
    const t = i.replace(/'/g, "\\'").replace(/\n/g, "");
    return this.ble.sendLua(`frame.display.text('${t}',1,1);frame.display.show();print(0)`, { awaitPrint: !0 });
  }
  async uploadStdLuaLibs(i) {
    for (const t of i) {
      const r = standardLuaLibrarySources[t];
      r ? await this.ble.uploadFileFromString(r.content, r.targetFileName) : console.warn(`Standard Lua library key "${t}" not found. Skipping.`);
    }
  }
  async uploadFrameApp(i, t = "frame_app.lua") {
    await this.ble.uploadFile(i, t);
  }
  async startFrameApp(i = "frame_app", t = !0) {
    return this.ble.sendLua(`require('${i}')`, { awaitPrint: t });
  }
  async stopFrameApp(i = !0) {
    await this.ble.sendBreakSignal(), i && await this.ble.sendResetSignal();
  }
  attachPrintResponseHandler(i = console.log) {
    this.ble.setPrintResponseHandler(i);
  }
  detachPrintResponseHandler() {
    this.ble.setPrintResponseHandler(void 0);
  }
  async sendMessage(i, t, r = !1) {
    await this.ble.sendMessage(i, t, r);
  }
  /**
   * Registers a handler for a subscriber interested in specific message codes from Frame.
   * @param subscriber The subscriber object/identifier.
   * @param msgCodes Array of message codes the subscriber is interested in.
   * @param handler The function to call with the incoming data (Uint8Array).
   */
  registerDataResponseHandler(i, t, r) {
    for (const n of t) {
      this.dataResponseHandlers.has(n) || this.dataResponseHandlers.set(n, []);
      const a = this.dataResponseHandlers.get(n);
      a.find(
        (o) => o.subscriber === i && o.handler === r
      ) || a.push({ subscriber: i, handler: r });
    }
  }
  unregisterDataResponseHandler(i) {
    this.dataResponseHandlers.forEach((t, r) => {
      const n = t.filter((a) => a.subscriber !== i);
      n.length === 0 ? this.dataResponseHandlers.delete(r) : this.dataResponseHandlers.set(r, n);
    });
  }
  /**
   * Internal method to handle incoming data responses from FrameBle (as Uint8Array)
   * and dispatch to appropriate FrameMsg subscribers.
   * @param data The incoming data response as a Uint8Array.
   */
  _handleDataResponse(i) {
    if (i && i.byteLength > 0) {
      const t = i[0];
      this.dataResponseHandlers.has(t) && this.dataResponseHandlers.get(t).forEach((r) => {
        try {
          r.handler(i);
        } catch (n) {
          console.error("Error in FrameMsg data response handler for msgCode", t, ":", n);
        }
      });
    }
  }
  // --- Direct proxy methods to FrameBle for convenience ---
  async sendLua(i, t = {}) {
    return this.ble.sendLua(i, t);
  }
  /**
   * Sends raw data to the device.
   * @param data The Uint8Array payload to send.
   * @param options Configuration options.
   * @returns A Promise that resolves with the Uint8Array data response if awaitData is true, or void.
   */
  async sendData(i, t = {}) {
    return this.ble.sendData(i, t);
  }
  async sendResetSignal(i = !1) {
    return this.ble.sendResetSignal(i);
  }
  async sendBreakSignal(i = !1) {
    return this.ble.sendBreakSignal(i);
  }
  getMaxPayload(i) {
    return this.ble ? this.ble.getMaxPayload(i) : (console.warn("FrameBle instance not initialized or not connected for getMaxPayload."), 60);
  }
}
class AsyncQueue {
  constructor() {
    $e(this, "promises");
    $e(this, "resolvers");
    this.promises = [], this.resolvers = [];
  }
  add() {
    this.promises.push(new Promise((i) => {
      this.resolvers.push(i);
    }));
  }
  put(i) {
    this.resolvers.length || this.add();
    const t = this.resolvers.shift();
    t && t(i);
  }
  async get() {
    this.promises.length || this.add();
    const i = this.promises.shift();
    return i || new Promise((t) => {
      this.resolvers.push(t), this.promises.push(this.get());
    });
  }
  isEmpty() {
    return this.promises.length === 0;
  }
  size() {
    return this.promises.length;
  }
  clear() {
    this.resolvers.forEach((i) => {
    }), this.promises = [], this.resolvers = [];
  }
}
class TxPlainText {
  /**
   * @param text The plain text content to be transmitted
   * @param x X-coordinate for text position (1-640, Lua/1-based indexing)
   * @param y Y-coordinate for text position (1-400, Lua/1-based indexing)
   * @param paletteOffset Color palette offset (1-15, 0/'VOID' is invalid)
   * @param spacing Character spacing value
   */
  constructor(i, t = 1, r = 1, n = 1, a = 4) {
    this.text = i, this.x = t, this.y = r, this.paletteOffset = n, this.spacing = a;
  }
  /**
   * Packs the message into a binary format.
   * @returns Uint8Array Binary representation of the message
   */
  pack() {
    const t = new TextEncoder().encode(this.text), r = new Uint8Array(6), n = new DataView(r.buffer);
    n.setUint16(0, this.x, !1), n.setUint16(2, this.y, !1), n.setUint8(4, this.paletteOffset & 15), n.setUint8(5, this.spacing & 255);
    const a = new Uint8Array(r.length + t.length);
    return a.set(r), a.set(t, r.length), a;
  }
}
class TxCaptureSettings {
  /**
   * @param resolution Image resolution (256-720, must be even). Defaults to 512.
   * @param qualityIndex Index into [VERY_LOW, LOW, MEDIUM, HIGH, VERY_HIGH]. Defaults to 4.
   * @param pan Image pan value (-140 to 140). Defaults to 0.
   * @param raw Whether to return the JPEG in raw (headerless) format. Defaults to false.
   */
  constructor(i = 512, t = 4, r = 0, n = !1) {
    /**
     * Image resolution (256-720, must be even)
     */
    $e(this, "resolution");
    /**
     * Index into [VERY_LOW, LOW, MEDIUM, HIGH, VERY_HIGH]
     */
    $e(this, "qualityIndex");
    /**
     * Image pan value (-140 to 140)
     */
    $e(this, "pan");
    /**
     * Whether to capture in RAW format
     */
    $e(this, "raw");
    this.resolution = i, this.qualityIndex = t, this.pan = r, this.raw = n;
  }
  /**
   * Packs the settings into 6 bytes.
   * @returns Uint8Array Binary representation of the message (6 bytes)
   */
  pack() {
    const i = new ArrayBuffer(6), t = new DataView(i), r = this.resolution / 2, n = this.pan + 140;
    return t.setUint8(0, this.qualityIndex & 255), t.setUint16(1, r & 65535, !1), t.setUint16(3, n & 65535, !1), t.setUint8(5, this.raw ? 1 : 0), new Uint8Array(i);
  }
}
class TxCode {
  /**
   * @param value The byte value to be transmitted (0-255)
   */
  constructor(i = 0) {
    this.value = i;
  }
  /**
   * Packs the message into a single byte.
   * @returns Uint8Array Binary representation of the message (a single byte)
   */
  pack() {
    const i = this.value & 255;
    return new Uint8Array([i]);
  }
}
const bitMethods = {
  /**
   * Get the bit of a pixel using a pixel index.
   * This method can only be called on binary images.
   * @memberof Image
   * @instance
   * @param {number} pixel - The pixel index which corresponds to `x * image.width + y`
   * @return {number} 0: bit is unset, 1: bit is set
   */
  getBit(e) {
    return this.data[getSlot(e)] & 1 << getShift(e) ? 1 : 0;
  },
  /**
   * Set the bit of a pixel using a pixel index.
   * This method can only be called on binary images.
   * @memberof Image
   * @instance
   * @param {number} pixel - The pixel index which corresponds to `x * image.width + y`
   */
  setBit(e) {
    this.data[getSlot(e)] |= 1 << getShift(e);
  },
  /**
   * Clear the bit of a pixel using a pixel index.
   * This method can only be called on binary images.
   * @memberof Image
   * @instance
   * @param {number} pixel - The pixel index which corresponds to `x * image.width + y`
   */
  clearBit(e) {
    this.data[getSlot(e)] &= ~(1 << getShift(e));
  },
  /**
   * Toggle (invert) the bit of a pixel using a pixel index.
   * This method can only be called on binary images.
   * @memberof Image
   * @instance
   * @param {number} pixel - The pixel index which corresponds to `x * image.width + y`
   */
  toggleBit(e) {
    this.data[getSlot(e)] ^= 1 << getShift(e);
  },
  /**
   * Get the bit of a pixel using coordinates.
   * This method can only be called on binary images.
   * @memberof Image
   * @instance
   * @param {number} x - x coordinate (0 = left)
   * @param {number} y - y coordinate (0 = top)
   * @return {number} 0: bit is unset, 1: bit is set
   */
  getBitXY(e, i) {
    return e >= this.width || i >= this.height ? 0 : this.getBit(i * this.width + e);
  },
  /**
   * Set the bit of a pixel using coordinates.
   * This method can only be called on binary images.
   * @memberof Image
   * @instance
   * @param {number} x - x coordinate (0 = left)
   * @param {number} y - y coordinate (0 = top)
   */
  setBitXY(e, i) {
    this.setBit(i * this.width + e);
  },
  /**
   * Clear the bit of a pixel using coordinates.
   * @memberof Image
   * @instance
   * @param {number} x - x coordinate (0 = left)
   * @param {number} y - y coordinate (0 = top)
   */
  clearBitXY(e, i) {
    this.clearBit(i * this.width + e);
  },
  /**
   * Toggle (invert) the bit of a pixel using coordinates.
   * @memberof Image
   * @instance
   * @param {number} x - x coordinate (0 = left)
   * @param {number} y - y coordinate (0 = top)
   */
  toggleBitXY(e, i) {
    this.toggleBit(i * this.width + e);
  }
};
function getSlot(e) {
  return e >> 3;
}
function getShift(e) {
  return 7 - (e & 7);
}
function setBitMethods(e) {
  for (const i in bitMethods)
    e.prototype[i] = bitMethods[i];
}
function checkProcessable(e, i = {}) {
  let { bitDepth: t, alpha: r, colorModel: n, components: a, channels: s } = i;
  if (typeof e != "string" || e.length === 0)
    throw new TypeError("processName must be a string");
  if (t && (Array.isArray(t) || (t = [t]), !t.includes(this.bitDepth)))
    throw new TypeError(
      `The process: ${e} can only be applied if bit depth is in: ${t}`
    );
  if (r && (Array.isArray(r) || (r = [r]), !r.includes(this.alpha)))
    throw new TypeError(
      `The process: ${e} can only be applied if alpha is in: ${r}`
    );
  if (n && (Array.isArray(n) || (n = [n]), !n.includes(this.colorModel)))
    throw new TypeError(
      `The process: ${e} can only be applied if color model is in: ${n}`
    );
  if (a && (Array.isArray(a) || (a = [a]), !a.includes(this.components))) {
    let o = `The process: ${e} can only be applied if the number of components is in: ${a}`;
    throw a.length === 1 && a[0] === 1 ? new TypeError(
      `${o}.\rYou should transform your image using "image.grey()" before applying the algorithm.`
    ) : new TypeError(o);
  }
  if (s && (Array.isArray(s) || (s = [s]), !s.includes(this.channels)))
    throw new TypeError(
      `The process: ${e} can only be applied if the number of channels is in: ${s}`
    );
}
function createBlob(e, i) {
  e = e || [], i = i || {}, typeof i == "string" && (i = { type: i });
  try {
    return new Blob(e, i);
  } catch (a) {
    if (a.name !== "TypeError")
      throw a;
    for (var t = typeof BlobBuilder < "u" ? BlobBuilder : typeof MSBlobBuilder < "u" ? MSBlobBuilder : typeof MozBlobBuilder < "u" ? MozBlobBuilder : WebKitBlobBuilder, r = new t(), n = 0; n < e.length; n += 1)
      r.append(e[n]);
    return r.getBlob(i.type);
  }
}
function dataURLToBlob(e) {
  var i = e.match(/data:([^;]+)/)[1], t = e.replace(/^[^,]+,/, ""), r = binaryStringToArrayBuffer(atob(t));
  return createBlob([r], { type: i });
}
function canvasToBlob(e, i, t) {
  return typeof e.toBlob == "function" ? new Promise(function(r) {
    e.toBlob(r, i, t);
  }) : Promise.resolve(dataURLToBlob(e.toDataURL(i, t)));
}
function binaryStringToArrayBuffer(e) {
  for (var i = e.length, t = new ArrayBuffer(i), r = new Uint8Array(t), n = -1; ++n < i; )
    r[n] = e.charCodeAt(n);
  return t;
}
function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function getAugmentedNamespace(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var i = e.default;
  if (typeof i == "function") {
    var t = function r() {
      return this instanceof r ? Reflect.construct(i, arguments, this.constructor) : i.apply(this, arguments);
    };
    t.prototype = i.prototype;
  } else t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var n = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(t, r, n.get ? n : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), t;
}
var src$5 = {};
function decode$2(e, i = "utf8") {
  return new TextDecoder(i).decode(e);
}
const encoder$1 = new TextEncoder();
function encode$1(e) {
  return encoder$1.encode(e);
}
const defaultByteLength = 1024 * 8, hostBigEndian = (() => {
  const e = new Uint8Array(4), i = new Uint32Array(e.buffer);
  return !((i[0] = 1) & e[0]);
})(), typedArrays = {
  int8: globalThis.Int8Array,
  uint8: globalThis.Uint8Array,
  int16: globalThis.Int16Array,
  uint16: globalThis.Uint16Array,
  int32: globalThis.Int32Array,
  uint32: globalThis.Uint32Array,
  uint64: globalThis.BigUint64Array,
  int64: globalThis.BigInt64Array,
  float32: globalThis.Float32Array,
  float64: globalThis.Float64Array
};
class IOBuffer {
  /**
   * Create a new IOBuffer.
   * @param data - The data to construct the IOBuffer with.
   * If data is a number, it will be the new buffer's length<br>
   * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
   * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
   * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
   * @param options - An object for the options.
   * @returns A new IOBuffer instance.
   */
  constructor(i = defaultByteLength, t = {}) {
    /**
     * Reference to the internal ArrayBuffer object.
     */
    $e(this, "buffer");
    /**
     * Byte length of the internal ArrayBuffer.
     */
    $e(this, "byteLength");
    /**
     * Byte offset of the internal ArrayBuffer.
     */
    $e(this, "byteOffset");
    /**
     * Byte length of the internal ArrayBuffer.
     */
    $e(this, "length");
    /**
     * The current offset of the buffer's pointer.
     */
    $e(this, "offset");
    $e(this, "lastWrittenByte");
    $e(this, "littleEndian");
    $e(this, "_data");
    $e(this, "_mark");
    $e(this, "_marks");
    let r = !1;
    typeof i == "number" ? i = new ArrayBuffer(i) : (r = !0, this.lastWrittenByte = i.byteLength);
    const n = t.offset ? t.offset >>> 0 : 0, a = i.byteLength - n;
    let s = n;
    (ArrayBuffer.isView(i) || i instanceof IOBuffer) && (i.byteLength !== i.buffer.byteLength && (s = i.byteOffset + n), i = i.buffer), r ? this.lastWrittenByte = a : this.lastWrittenByte = 0, this.buffer = i, this.length = a, this.byteLength = a, this.byteOffset = s, this.offset = 0, this.littleEndian = !0, this._data = new DataView(this.buffer, s, a), this._mark = 0, this._marks = [];
  }
  /**
   * Checks if the memory allocated to the buffer is sufficient to store more
   * bytes after the offset.
   * @param byteLength - The needed memory in bytes.
   * @returns `true` if there is sufficient space and `false` otherwise.
   */
  available(i = 1) {
    return this.offset + i <= this.length;
  }
  /**
   * Check if little-endian mode is used for reading and writing multi-byte
   * values.
   * @returns `true` if little-endian mode is used, `false` otherwise.
   */
  isLittleEndian() {
    return this.littleEndian;
  }
  /**
   * Set little-endian mode for reading and writing multi-byte values.
   * @returns This.
   */
  setLittleEndian() {
    return this.littleEndian = !0, this;
  }
  /**
   * Check if big-endian mode is used for reading and writing multi-byte values.
   * @returns `true` if big-endian mode is used, `false` otherwise.
   */
  isBigEndian() {
    return !this.littleEndian;
  }
  /**
   * Switches to big-endian mode for reading and writing multi-byte values.
   * @returns This.
   */
  setBigEndian() {
    return this.littleEndian = !1, this;
  }
  /**
   * Move the pointer n bytes forward.
   * @param n - Number of bytes to skip.
   * @returns This.
   */
  skip(i = 1) {
    return this.offset += i, this;
  }
  /**
   * Move the pointer n bytes backward.
   * @param n - Number of bytes to move back.
   * @returns This.
   */
  back(i = 1) {
    return this.offset -= i, this;
  }
  /**
   * Move the pointer to the given offset.
   * @param offset - The offset to move to.
   * @returns This.
   */
  seek(i) {
    return this.offset = i, this;
  }
  /**
   * Store the current pointer offset.
   * @see {@link IOBuffer#reset}
   * @returns This.
   */
  mark() {
    return this._mark = this.offset, this;
  }
  /**
   * Move the pointer back to the last pointer offset set by mark.
   * @see {@link IOBuffer#mark}
   * @returns This.
   */
  reset() {
    return this.offset = this._mark, this;
  }
  /**
   * Push the current pointer offset to the mark stack.
   * @see {@link IOBuffer#popMark}
   * @returns This.
   */
  pushMark() {
    return this._marks.push(this.offset), this;
  }
  /**
   * Pop the last pointer offset from the mark stack, and set the current
   * pointer offset to the popped value.
   * @see {@link IOBuffer#pushMark}
   * @returns This.
   */
  popMark() {
    const i = this._marks.pop();
    if (i === void 0)
      throw new Error("Mark stack empty");
    return this.seek(i), this;
  }
  /**
   * Move the pointer offset back to 0.
   * @returns This.
   */
  rewind() {
    return this.offset = 0, this;
  }
  /**
   * Make sure the buffer has sufficient memory to write a given byteLength at
   * the current pointer offset.
   * If the buffer's memory is insufficient, this method will create a new
   * buffer (a copy) with a length that is twice (byteLength + current offset).
   * @param byteLength - The needed memory in bytes.
   * @returns This.
   */
  ensureAvailable(i = 1) {
    if (!this.available(i)) {
      const r = (this.offset + i) * 2, n = new Uint8Array(r);
      n.set(new Uint8Array(this.buffer)), this.buffer = n.buffer, this.length = r, this.byteLength = r, this._data = new DataView(this.buffer);
    }
    return this;
  }
  /**
   * Read a byte and return false if the byte's value is 0, or true otherwise.
   * Moves pointer forward by one byte.
   * @returns The read boolean.
   */
  readBoolean() {
    return this.readUint8() !== 0;
  }
  /**
   * Read a signed 8-bit integer and move pointer forward by 1 byte.
   * @returns The read byte.
   */
  readInt8() {
    return this._data.getInt8(this.offset++);
  }
  /**
   * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
   * @returns The read byte.
   */
  readUint8() {
    return this._data.getUint8(this.offset++);
  }
  /**
   * Alias for {@link IOBuffer#readUint8}.
   * @returns The read byte.
   */
  readByte() {
    return this.readUint8();
  }
  /**
   * Read `n` bytes and move pointer forward by `n` bytes.
   * @param n - Number of bytes to read.
   * @returns The read bytes.
   */
  readBytes(i = 1) {
    return this.readArray(i, "uint8");
  }
  /**
   * Creates an array of corresponding to the type `type` and size `size`.
   * For example type `uint8` will create a `Uint8Array`.
   * @param size - size of the resulting array
   * @param type - number type of elements to read
   * @returns The read array.
   */
  readArray(i, t) {
    const r = typedArrays[t].BYTES_PER_ELEMENT * i, n = this.byteOffset + this.offset, a = this.buffer.slice(n, n + r);
    if (this.littleEndian === hostBigEndian && t !== "uint8" && t !== "int8") {
      const o = new Uint8Array(this.buffer.slice(n, n + r));
      o.reverse();
      const h = new typedArrays[t](o.buffer);
      return this.offset += r, h.reverse(), h;
    }
    const s = new typedArrays[t](a);
    return this.offset += r, s;
  }
  /**
   * Read a 16-bit signed integer and move pointer forward by 2 bytes.
   * @returns The read value.
   */
  readInt16() {
    const i = this._data.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, i;
  }
  /**
   * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
   * @returns The read value.
   */
  readUint16() {
    const i = this._data.getUint16(this.offset, this.littleEndian);
    return this.offset += 2, i;
  }
  /**
   * Read a 32-bit signed integer and move pointer forward by 4 bytes.
   * @returns The read value.
   */
  readInt32() {
    const i = this._data.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, i;
  }
  /**
   * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
   * @returns The read value.
   */
  readUint32() {
    const i = this._data.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, i;
  }
  /**
   * Read a 32-bit floating number and move pointer forward by 4 bytes.
   * @returns The read value.
   */
  readFloat32() {
    const i = this._data.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, i;
  }
  /**
   * Read a 64-bit floating number and move pointer forward by 8 bytes.
   * @returns The read value.
   */
  readFloat64() {
    const i = this._data.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, i;
  }
  /**
   * Read a 64-bit signed integer number and move pointer forward by 8 bytes.
   * @returns The read value.
   */
  readBigInt64() {
    const i = this._data.getBigInt64(this.offset, this.littleEndian);
    return this.offset += 8, i;
  }
  /**
   * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.
   * @returns The read value.
   */
  readBigUint64() {
    const i = this._data.getBigUint64(this.offset, this.littleEndian);
    return this.offset += 8, i;
  }
  /**
   * Read a 1-byte ASCII character and move pointer forward by 1 byte.
   * @returns The read character.
   */
  readChar() {
    return String.fromCharCode(this.readInt8());
  }
  /**
   * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
   * @param n - Number of characters to read.
   * @returns The read characters.
   */
  readChars(i = 1) {
    let t = "";
    for (let r = 0; r < i; r++)
      t += this.readChar();
    return t;
  }
  /**
   * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
   * forward by `n` bytes.
   * @param n - Number of bytes to read.
   * @returns The decoded string.
   */
  readUtf8(i = 1) {
    return decode$2(this.readBytes(i));
  }
  /**
   * Read the next `n` bytes, return a string decoded with `encoding` and move pointer
   * forward by `n` bytes.
   * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}
   * @param n - Number of bytes to read.
   * @param encoding - The encoding to use. Default is 'utf8'.
   * @returns The decoded string.
   */
  decodeText(i = 1, t = "utf8") {
    return decode$2(this.readBytes(i), t);
  }
  /**
   * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
   * forward by 1 byte.
   * @param value - The value to write.
   * @returns This.
   */
  writeBoolean(i) {
    return this.writeUint8(i ? 255 : 0), this;
  }
  /**
   * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
   * @param value - The value to write.
   * @returns This.
   */
  writeInt8(i) {
    return this.ensureAvailable(1), this._data.setInt8(this.offset++, i), this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
   * byte.
   * @param value - The value to write.
   * @returns This.
   */
  writeUint8(i) {
    return this.ensureAvailable(1), this._data.setUint8(this.offset++, i), this._updateLastWrittenByte(), this;
  }
  /**
   * An alias for {@link IOBuffer#writeUint8}.
   * @param value - The value to write.
   * @returns This.
   */
  writeByte(i) {
    return this.writeUint8(i);
  }
  /**
   * Write all elements of `bytes` as uint8 values and move pointer forward by
   * `bytes.length` bytes.
   * @param bytes - The array of bytes to write.
   * @returns This.
   */
  writeBytes(i) {
    this.ensureAvailable(i.length);
    for (let t = 0; t < i.length; t++)
      this._data.setUint8(this.offset++, i[t]);
    return this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 16-bit signed integer and move pointer forward by 2
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeInt16(i) {
    return this.ensureAvailable(2), this._data.setInt16(this.offset, i, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeUint16(i) {
    return this.ensureAvailable(2), this._data.setUint16(this.offset, i, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 32-bit signed integer and move pointer forward by 4
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeInt32(i) {
    return this.ensureAvailable(4), this._data.setInt32(this.offset, i, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeUint32(i) {
    return this.ensureAvailable(4), this._data.setUint32(this.offset, i, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 32-bit floating number and move pointer forward by 4
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeFloat32(i) {
    return this.ensureAvailable(4), this._data.setFloat32(this.offset, i, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 64-bit floating number and move pointer forward by 8
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeFloat64(i) {
    return this.ensureAvailable(8), this._data.setFloat64(this.offset, i, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 64-bit signed bigint and move pointer forward by 8
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeBigInt64(i) {
    return this.ensureAvailable(8), this._data.setBigInt64(this.offset, i, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeBigUint64(i) {
    return this.ensureAvailable(8), this._data.setBigUint64(this.offset, i, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
  }
  /**
   * Write the charCode of `str`'s first character as an 8-bit unsigned integer
   * and move pointer forward by 1 byte.
   * @param str - The character to write.
   * @returns This.
   */
  writeChar(i) {
    return this.writeUint8(i.charCodeAt(0));
  }
  /**
   * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
   * and move pointer forward by `str.length` bytes.
   * @param str - The characters to write.
   * @returns This.
   */
  writeChars(i) {
    for (let t = 0; t < i.length; t++)
      this.writeUint8(i.charCodeAt(t));
    return this;
  }
  /**
   * UTF-8 encode and write `str` to the current pointer offset and move pointer
   * forward according to the encoded length.
   * @param str - The string to write.
   * @returns This.
   */
  writeUtf8(i) {
    return this.writeBytes(encode$1(i));
  }
  /**
   * Export a Uint8Array view of the internal buffer.
   * The view starts at the byte offset and its length
   * is calculated to stop at the last written byte or the original length.
   * @returns A new Uint8Array view.
   */
  toArray() {
    return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
  }
  /**
   *  Get the total number of bytes written so far, regardless of the current offset.
   * @returns - Total number of bytes.
   */
  getWrittenByteLength() {
    return this.lastWrittenByte - this.byteOffset;
  }
  /**
   * Update the last written byte offset
   * @private
   */
  _updateLastWrittenByte() {
    this.offset > this.lastWrittenByte && (this.lastWrittenByte = this.offset);
  }
}
const IOBuffer$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  IOBuffer
}, Symbol.toStringTag, { value: "Module" })), require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(IOBuffer$1);
var constants$1, hasRequiredConstants$1;
function requireConstants$1() {
  return hasRequiredConstants$1 || (hasRequiredConstants$1 = 1, constants$1 = {
    BITMAPV5HEADER: {
      LogicalColorSpace: {
        // https://msdn.microsoft.com/en-us/library/cc250396.aspx
        LCS_CALIBRATED_RGB: 0,
        LCS_sRGB: 1934772034,
        // eslint-disable-line camelcase
        LCS_WINDOWS_COLOR_SPACE: 1466527264
      },
      Compression: {
        // https://msdn.microsoft.com/en-us/library/cc250415.aspx
        BI_RGB: 0,
        // No compression
        BI_RLE8: 1,
        BI_RLE4: 2,
        BI_BITFIELDS: 3,
        BI_JPEG: 4,
        BI_PNG: 5,
        BI_CMYK: 11,
        BI_CMYKRLE8: 12,
        BI_CMYKRLE4: 13
      },
      GamutMappingIntent: {
        // https://msdn.microsoft.com/en-us/library/cc250392.aspx
        LCS_GM_ABS_COLORIMETRIC: 8,
        LCS_GM_BUSINESS: 1,
        LCS_GM_GRAPHICS: 2,
        LCS_GM_IMAGES: 4
      }
    }
  }), constants$1;
}
var BMPEncoder_1, hasRequiredBMPEncoder;
function requireBMPEncoder() {
  if (hasRequiredBMPEncoder) return BMPEncoder_1;
  hasRequiredBMPEncoder = 1;
  const { IOBuffer: e } = require$$0$3, i = requireConstants$1(), t = [];
  for (let n = 0; n <= 8; n++)
    t.push(255 << n);
  class r extends e {
    constructor(a) {
      if (a.bitDepth !== 1)
        throw new Error("Only bitDepth of 1 is supported");
      if (!a.height || !a.width)
        throw new Error("ImageData width and height are required");
      super(a.data), this.width = a.width, this.height = a.height, this.bitDepth = a.bitDepth, this.channels = a.channels, this.components = a.components;
    }
    encode() {
      this.encoded = new e(), this.encoded.skip(14), this.writeBitmapV5Header(), this.writeColorTable();
      const a = this.encoded.offset;
      return this.writePixelArray(), this.encoded.rewind(), this.writeBitmapFileHeader(a), this.encoded.toArray();
    }
    writePixelArray() {
      let a = this.encoded;
      const s = Math.floor((this.bitDepth * this.width + 31) / 32) * 4, o = Math.ceil(this.bitDepth * this.width / 8), h = s - o, l = this.bitDepth * this.width % 8, f = l === 0 ? 0 : 8 - l, b = s * this.height;
      let w, g, E = 0, k = 0, A = 8;
      a.mark(), g = this.readUint8();
      for (let T = this.height - 1; T >= 0; T--) {
        const C = T === 0;
        a.reset(), a.skip(T * s);
        for (let D = 0; D < o; D++) {
          const $ = D === o - 1;
          k <= f && $ ? (a.writeByte(g << k), (f === 0 || f === k) && !C && (w = g, g = this.readByte())) : k === 0 ? (w = g, g = this.readUint8(), a.writeByte(w)) : (w = g, g = this.readUint8(), a.writeByte(
            w << k & t[k] | g >> A
          )), $ && (E += l || 0, a.skip(h), k = E % 8, A = 8 - k);
        }
      }
      s > o && (a.reset(), a.skip(b - 1), a.writeUint8(0));
    }
    writeColorTable() {
      this.encoded.writeUint32(0).writeUint32(16777215);
    }
    writeBitmapFileHeader(a) {
      this.encoded.writeChars("BM").writeInt32(this.encoded.lastWrittenByte).writeUint16(0).writeUint16(0).writeUint32(a);
    }
    writeBitmapV5Header() {
      const s = Math.floor((this.bitDepth * this.width + 31) / 32) * 4 * this.height;
      this.encoded.writeUint32(124).writeInt32(this.width).writeInt32(this.height).writeUint16(1).writeUint16(this.bitDepth).writeUint32(i.BITMAPV5HEADER.Compression.BI_RGB).writeUint32(s).writeInt32(0).writeInt32(0).writeUint32(Math.pow(2, this.bitDepth)).writeUint32(Math.pow(2, this.bitDepth)).writeUint32(4278190080).writeUint32(16711680).writeUint32(65280).writeUint32(255).writeUint32(i.BITMAPV5HEADER.LogicalColorSpace.LCS_sRGB).skip(36).skip(12).writeUint32(i.BITMAPV5HEADER.GamutMappingIntent.LCS_GM_IMAGES).skip(12);
    }
  }
  return BMPEncoder_1 = r, BMPEncoder_1;
}
var hasRequiredSrc$5;
function requireSrc$5() {
  if (hasRequiredSrc$5) return src$5;
  hasRequiredSrc$5 = 1;
  const e = requireBMPEncoder();
  return src$5.encode = function(t) {
    return new e(t).encode();
  }, src$5;
}
var srcExports$3 = requireSrc$5();
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const Z_FIXED$1 = 4, Z_BINARY = 0, Z_TEXT = 1, Z_UNKNOWN$1 = 2;
function zero$1$1(e) {
  let i = e.length;
  for (; --i >= 0; )
    e[i] = 0;
}
const STORED_BLOCK = 0, STATIC_TREES = 1, DYN_TREES = 2, MIN_MATCH$1$1 = 3, MAX_MATCH$1$1 = 258, LENGTH_CODES$1$1 = 29, LITERALS$1$1 = 256, L_CODES$1$1 = LITERALS$1$1 + 1 + LENGTH_CODES$1$1, D_CODES$1$1 = 30, BL_CODES$1 = 19, HEAP_SIZE$1 = 2 * L_CODES$1$1 + 1, MAX_BITS$1 = 15, Buf_size = 16, MAX_BL_BITS = 7, END_BLOCK = 256, REP_3_6 = 16, REPZ_3_10 = 17, REPZ_11_138 = 18, extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
), extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
), extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
), bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), DIST_CODE_LEN$1 = 512, static_ltree$1 = new Array((L_CODES$1$1 + 2) * 2);
zero$1$1(static_ltree$1);
const static_dtree$1 = new Array(D_CODES$1$1 * 2);
zero$1$1(static_dtree$1);
const _dist_code$1 = new Array(DIST_CODE_LEN$1);
zero$1$1(_dist_code$1);
const _length_code$1 = new Array(MAX_MATCH$1$1 - MIN_MATCH$1$1 + 1);
zero$1$1(_length_code$1);
const base_length$1 = new Array(LENGTH_CODES$1$1);
zero$1$1(base_length$1);
const base_dist$1 = new Array(D_CODES$1$1);
zero$1$1(base_dist$1);
function StaticTreeDesc(e, i, t, r, n) {
  this.static_tree = e, this.extra_bits = i, this.extra_base = t, this.elems = r, this.max_length = n, this.has_stree = e && e.length;
}
let static_l_desc, static_d_desc, static_bl_desc;
function TreeDesc(e, i) {
  this.dyn_tree = e, this.max_code = 0, this.stat_desc = i;
}
const d_code = (e) => e < 256 ? _dist_code$1[e] : _dist_code$1[256 + (e >>> 7)], put_short = (e, i) => {
  e.pending_buf[e.pending++] = i & 255, e.pending_buf[e.pending++] = i >>> 8 & 255;
}, send_bits = (e, i, t) => {
  e.bi_valid > Buf_size - t ? (e.bi_buf |= i << e.bi_valid & 65535, put_short(e, e.bi_buf), e.bi_buf = i >> Buf_size - e.bi_valid, e.bi_valid += t - Buf_size) : (e.bi_buf |= i << e.bi_valid & 65535, e.bi_valid += t);
}, send_code = (e, i, t) => {
  send_bits(
    e,
    t[i * 2],
    t[i * 2 + 1]
    /*.Len*/
  );
}, bi_reverse = (e, i) => {
  let t = 0;
  do
    t |= e & 1, e >>>= 1, t <<= 1;
  while (--i > 0);
  return t >>> 1;
}, bi_flush = (e) => {
  e.bi_valid === 16 ? (put_short(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = e.bi_buf & 255, e.bi_buf >>= 8, e.bi_valid -= 8);
}, gen_bitlen = (e, i) => {
  const t = i.dyn_tree, r = i.max_code, n = i.stat_desc.static_tree, a = i.stat_desc.has_stree, s = i.stat_desc.extra_bits, o = i.stat_desc.extra_base, h = i.stat_desc.max_length;
  let l, f, b, w, g, E, k = 0;
  for (w = 0; w <= MAX_BITS$1; w++)
    e.bl_count[w] = 0;
  for (t[e.heap[e.heap_max] * 2 + 1] = 0, l = e.heap_max + 1; l < HEAP_SIZE$1; l++)
    f = e.heap[l], w = t[t[f * 2 + 1] * 2 + 1] + 1, w > h && (w = h, k++), t[f * 2 + 1] = w, !(f > r) && (e.bl_count[w]++, g = 0, f >= o && (g = s[f - o]), E = t[f * 2], e.opt_len += E * (w + g), a && (e.static_len += E * (n[f * 2 + 1] + g)));
  if (k !== 0) {
    do {
      for (w = h - 1; e.bl_count[w] === 0; )
        w--;
      e.bl_count[w]--, e.bl_count[w + 1] += 2, e.bl_count[h]--, k -= 2;
    } while (k > 0);
    for (w = h; w !== 0; w--)
      for (f = e.bl_count[w]; f !== 0; )
        b = e.heap[--l], !(b > r) && (t[b * 2 + 1] !== w && (e.opt_len += (w - t[b * 2 + 1]) * t[b * 2], t[b * 2 + 1] = w), f--);
  }
}, gen_codes = (e, i, t) => {
  const r = new Array(MAX_BITS$1 + 1);
  let n = 0, a, s;
  for (a = 1; a <= MAX_BITS$1; a++)
    n = n + t[a - 1] << 1, r[a] = n;
  for (s = 0; s <= i; s++) {
    let o = e[s * 2 + 1];
    o !== 0 && (e[s * 2] = bi_reverse(r[o]++, o));
  }
}, tr_static_init = () => {
  let e, i, t, r, n;
  const a = new Array(MAX_BITS$1 + 1);
  for (t = 0, r = 0; r < LENGTH_CODES$1$1 - 1; r++)
    for (base_length$1[r] = t, e = 0; e < 1 << extra_lbits[r]; e++)
      _length_code$1[t++] = r;
  for (_length_code$1[t - 1] = r, n = 0, r = 0; r < 16; r++)
    for (base_dist$1[r] = n, e = 0; e < 1 << extra_dbits[r]; e++)
      _dist_code$1[n++] = r;
  for (n >>= 7; r < D_CODES$1$1; r++)
    for (base_dist$1[r] = n << 7, e = 0; e < 1 << extra_dbits[r] - 7; e++)
      _dist_code$1[256 + n++] = r;
  for (i = 0; i <= MAX_BITS$1; i++)
    a[i] = 0;
  for (e = 0; e <= 143; )
    static_ltree$1[e * 2 + 1] = 8, e++, a[8]++;
  for (; e <= 255; )
    static_ltree$1[e * 2 + 1] = 9, e++, a[9]++;
  for (; e <= 279; )
    static_ltree$1[e * 2 + 1] = 7, e++, a[7]++;
  for (; e <= 287; )
    static_ltree$1[e * 2 + 1] = 8, e++, a[8]++;
  for (gen_codes(static_ltree$1, L_CODES$1$1 + 1, a), e = 0; e < D_CODES$1$1; e++)
    static_dtree$1[e * 2 + 1] = 5, static_dtree$1[e * 2] = bi_reverse(e, 5);
  static_l_desc = new StaticTreeDesc(static_ltree$1, extra_lbits, LITERALS$1$1 + 1, L_CODES$1$1, MAX_BITS$1), static_d_desc = new StaticTreeDesc(static_dtree$1, extra_dbits, 0, D_CODES$1$1, MAX_BITS$1), static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
}, init_block = (e) => {
  let i;
  for (i = 0; i < L_CODES$1$1; i++)
    e.dyn_ltree[i * 2] = 0;
  for (i = 0; i < D_CODES$1$1; i++)
    e.dyn_dtree[i * 2] = 0;
  for (i = 0; i < BL_CODES$1; i++)
    e.bl_tree[i * 2] = 0;
  e.dyn_ltree[END_BLOCK * 2] = 1, e.opt_len = e.static_len = 0, e.sym_next = e.matches = 0;
}, bi_windup = (e) => {
  e.bi_valid > 8 ? put_short(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;
}, smaller = (e, i, t, r) => {
  const n = i * 2, a = t * 2;
  return e[n] < e[a] || e[n] === e[a] && r[i] <= r[t];
}, pqdownheap = (e, i, t) => {
  const r = e.heap[t];
  let n = t << 1;
  for (; n <= e.heap_len && (n < e.heap_len && smaller(i, e.heap[n + 1], e.heap[n], e.depth) && n++, !smaller(i, r, e.heap[n], e.depth)); )
    e.heap[t] = e.heap[n], t = n, n <<= 1;
  e.heap[t] = r;
}, compress_block = (e, i, t) => {
  let r, n, a = 0, s, o;
  if (e.sym_next !== 0)
    do
      r = e.pending_buf[e.sym_buf + a++] & 255, r += (e.pending_buf[e.sym_buf + a++] & 255) << 8, n = e.pending_buf[e.sym_buf + a++], r === 0 ? send_code(e, n, i) : (s = _length_code$1[n], send_code(e, s + LITERALS$1$1 + 1, i), o = extra_lbits[s], o !== 0 && (n -= base_length$1[s], send_bits(e, n, o)), r--, s = d_code(r), send_code(e, s, t), o = extra_dbits[s], o !== 0 && (r -= base_dist$1[s], send_bits(e, r, o)));
    while (a < e.sym_next);
  send_code(e, END_BLOCK, i);
}, build_tree = (e, i) => {
  const t = i.dyn_tree, r = i.stat_desc.static_tree, n = i.stat_desc.has_stree, a = i.stat_desc.elems;
  let s, o, h = -1, l;
  for (e.heap_len = 0, e.heap_max = HEAP_SIZE$1, s = 0; s < a; s++)
    t[s * 2] !== 0 ? (e.heap[++e.heap_len] = h = s, e.depth[s] = 0) : t[s * 2 + 1] = 0;
  for (; e.heap_len < 2; )
    l = e.heap[++e.heap_len] = h < 2 ? ++h : 0, t[l * 2] = 1, e.depth[l] = 0, e.opt_len--, n && (e.static_len -= r[l * 2 + 1]);
  for (i.max_code = h, s = e.heap_len >> 1; s >= 1; s--)
    pqdownheap(e, t, s);
  l = a;
  do
    s = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[
      1
      /*SMALLEST*/
    ] = e.heap[e.heap_len--], pqdownheap(
      e,
      t,
      1
      /*SMALLEST*/
    ), o = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[--e.heap_max] = s, e.heap[--e.heap_max] = o, t[l * 2] = t[s * 2] + t[o * 2], e.depth[l] = (e.depth[s] >= e.depth[o] ? e.depth[s] : e.depth[o]) + 1, t[s * 2 + 1] = t[o * 2 + 1] = l, e.heap[
      1
      /*SMALLEST*/
    ] = l++, pqdownheap(
      e,
      t,
      1
      /*SMALLEST*/
    );
  while (e.heap_len >= 2);
  e.heap[--e.heap_max] = e.heap[
    1
    /*SMALLEST*/
  ], gen_bitlen(e, i), gen_codes(t, h, e.bl_count);
}, scan_tree = (e, i, t) => {
  let r, n = -1, a, s = i[0 * 2 + 1], o = 0, h = 7, l = 4;
  for (s === 0 && (h = 138, l = 3), i[(t + 1) * 2 + 1] = 65535, r = 0; r <= t; r++)
    a = s, s = i[(r + 1) * 2 + 1], !(++o < h && a === s) && (o < l ? e.bl_tree[a * 2] += o : a !== 0 ? (a !== n && e.bl_tree[a * 2]++, e.bl_tree[REP_3_6 * 2]++) : o <= 10 ? e.bl_tree[REPZ_3_10 * 2]++ : e.bl_tree[REPZ_11_138 * 2]++, o = 0, n = a, s === 0 ? (h = 138, l = 3) : a === s ? (h = 6, l = 3) : (h = 7, l = 4));
}, send_tree = (e, i, t) => {
  let r, n = -1, a, s = i[0 * 2 + 1], o = 0, h = 7, l = 4;
  for (s === 0 && (h = 138, l = 3), r = 0; r <= t; r++)
    if (a = s, s = i[(r + 1) * 2 + 1], !(++o < h && a === s)) {
      if (o < l)
        do
          send_code(e, a, e.bl_tree);
        while (--o !== 0);
      else a !== 0 ? (a !== n && (send_code(e, a, e.bl_tree), o--), send_code(e, REP_3_6, e.bl_tree), send_bits(e, o - 3, 2)) : o <= 10 ? (send_code(e, REPZ_3_10, e.bl_tree), send_bits(e, o - 3, 3)) : (send_code(e, REPZ_11_138, e.bl_tree), send_bits(e, o - 11, 7));
      o = 0, n = a, s === 0 ? (h = 138, l = 3) : a === s ? (h = 6, l = 3) : (h = 7, l = 4);
    }
}, build_bl_tree = (e) => {
  let i;
  for (scan_tree(e, e.dyn_ltree, e.l_desc.max_code), scan_tree(e, e.dyn_dtree, e.d_desc.max_code), build_tree(e, e.bl_desc), i = BL_CODES$1 - 1; i >= 3 && e.bl_tree[bl_order[i] * 2 + 1] === 0; i--)
    ;
  return e.opt_len += 3 * (i + 1) + 5 + 5 + 4, i;
}, send_all_trees = (e, i, t, r) => {
  let n;
  for (send_bits(e, i - 257, 5), send_bits(e, t - 1, 5), send_bits(e, r - 4, 4), n = 0; n < r; n++)
    send_bits(e, e.bl_tree[bl_order[n] * 2 + 1], 3);
  send_tree(e, e.dyn_ltree, i - 1), send_tree(e, e.dyn_dtree, t - 1);
}, detect_data_type = (e) => {
  let i = 4093624447, t;
  for (t = 0; t <= 31; t++, i >>>= 1)
    if (i & 1 && e.dyn_ltree[t * 2] !== 0)
      return Z_BINARY;
  if (e.dyn_ltree[9 * 2] !== 0 || e.dyn_ltree[10 * 2] !== 0 || e.dyn_ltree[13 * 2] !== 0)
    return Z_TEXT;
  for (t = 32; t < LITERALS$1$1; t++)
    if (e.dyn_ltree[t * 2] !== 0)
      return Z_TEXT;
  return Z_BINARY;
};
let static_init_done = !1;
const _tr_init$1 = (e) => {
  static_init_done || (tr_static_init(), static_init_done = !0), e.l_desc = new TreeDesc(e.dyn_ltree, static_l_desc), e.d_desc = new TreeDesc(e.dyn_dtree, static_d_desc), e.bl_desc = new TreeDesc(e.bl_tree, static_bl_desc), e.bi_buf = 0, e.bi_valid = 0, init_block(e);
}, _tr_stored_block$1 = (e, i, t, r) => {
  send_bits(e, (STORED_BLOCK << 1) + (r ? 1 : 0), 3), bi_windup(e), put_short(e, t), put_short(e, ~t), t && e.pending_buf.set(e.window.subarray(i, i + t), e.pending), e.pending += t;
}, _tr_align$1 = (e) => {
  send_bits(e, STATIC_TREES << 1, 3), send_code(e, END_BLOCK, static_ltree$1), bi_flush(e);
}, _tr_flush_block$1 = (e, i, t, r) => {
  let n, a, s = 0;
  e.level > 0 ? (e.strm.data_type === Z_UNKNOWN$1 && (e.strm.data_type = detect_data_type(e)), build_tree(e, e.l_desc), build_tree(e, e.d_desc), s = build_bl_tree(e), n = e.opt_len + 3 + 7 >>> 3, a = e.static_len + 3 + 7 >>> 3, a <= n && (n = a)) : n = a = t + 5, t + 4 <= n && i !== -1 ? _tr_stored_block$1(e, i, t, r) : e.strategy === Z_FIXED$1 || a === n ? (send_bits(e, (STATIC_TREES << 1) + (r ? 1 : 0), 3), compress_block(e, static_ltree$1, static_dtree$1)) : (send_bits(e, (DYN_TREES << 1) + (r ? 1 : 0), 3), send_all_trees(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, s + 1), compress_block(e, e.dyn_ltree, e.dyn_dtree)), init_block(e), r && bi_windup(e);
}, _tr_tally$1 = (e, i, t) => (e.pending_buf[e.sym_buf + e.sym_next++] = i, e.pending_buf[e.sym_buf + e.sym_next++] = i >> 8, e.pending_buf[e.sym_buf + e.sym_next++] = t, i === 0 ? e.dyn_ltree[t * 2]++ : (e.matches++, i--, e.dyn_ltree[(_length_code$1[t] + LITERALS$1$1 + 1) * 2]++, e.dyn_dtree[d_code(i) * 2]++), e.sym_next === e.sym_end);
var _tr_init_1 = _tr_init$1, _tr_stored_block_1 = _tr_stored_block$1, _tr_flush_block_1 = _tr_flush_block$1, _tr_tally_1 = _tr_tally$1, _tr_align_1 = _tr_align$1, trees$1 = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
const adler32$1 = (e, i, t, r) => {
  let n = e & 65535 | 0, a = e >>> 16 & 65535 | 0, s = 0;
  for (; t !== 0; ) {
    s = t > 2e3 ? 2e3 : t, t -= s;
    do
      n = n + i[r++] | 0, a = a + n | 0;
    while (--s);
    n %= 65521, a %= 65521;
  }
  return n | a << 16 | 0;
};
var adler32_1$2 = adler32$1;
const makeTable$1 = () => {
  let e, i = [];
  for (var t = 0; t < 256; t++) {
    e = t;
    for (var r = 0; r < 8; r++)
      e = e & 1 ? 3988292384 ^ e >>> 1 : e >>> 1;
    i[t] = e;
  }
  return i;
}, crcTable$2 = new Uint32Array(makeTable$1()), crc32$1 = (e, i, t, r) => {
  const n = crcTable$2, a = r + t;
  e ^= -1;
  for (let s = r; s < a; s++)
    e = e >>> 8 ^ n[(e ^ i[s]) & 255];
  return e ^ -1;
};
var crc32_1$2 = crc32$1, messages$2 = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, constants$2$1 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees$1, {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2$1, MAX_MEM_LEVEL = 9, MAX_WBITS$1 = 15, DEF_MEM_LEVEL = 8, LENGTH_CODES = 29, LITERALS = 256, L_CODES = LITERALS + 1 + LENGTH_CODES, D_CODES = 30, BL_CODES = 19, HEAP_SIZE = 2 * L_CODES + 1, MAX_BITS = 15, MIN_MATCH = 3, MAX_MATCH = 258, MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1, PRESET_DICT = 32, INIT_STATE = 42, GZIP_STATE = 57, EXTRA_STATE = 69, NAME_STATE = 73, COMMENT_STATE = 91, HCRC_STATE = 103, BUSY_STATE = 113, FINISH_STATE = 666, BS_NEED_MORE = 1, BS_BLOCK_DONE = 2, BS_FINISH_STARTED = 3, BS_FINISH_DONE = 4, OS_CODE = 3, err = (e, i) => (e.msg = messages$2[i], i), rank = (e) => e * 2 - (e > 4 ? 9 : 0), zero = (e) => {
  let i = e.length;
  for (; --i >= 0; )
    e[i] = 0;
}, slide_hash = (e) => {
  let i, t, r, n = e.w_size;
  i = e.hash_size, r = i;
  do
    t = e.head[--r], e.head[r] = t >= n ? t - n : 0;
  while (--i);
  i = n, r = i;
  do
    t = e.prev[--r], e.prev[r] = t >= n ? t - n : 0;
  while (--i);
};
let HASH_ZLIB = (e, i, t) => (i << e.hash_shift ^ t) & e.hash_mask, HASH = HASH_ZLIB;
const flush_pending = (e) => {
  const i = e.state;
  let t = i.pending;
  t > e.avail_out && (t = e.avail_out), t !== 0 && (e.output.set(i.pending_buf.subarray(i.pending_out, i.pending_out + t), e.next_out), e.next_out += t, i.pending_out += t, e.total_out += t, e.avail_out -= t, i.pending -= t, i.pending === 0 && (i.pending_out = 0));
}, flush_block_only = (e, i) => {
  _tr_flush_block(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, i), e.block_start = e.strstart, flush_pending(e.strm);
}, put_byte = (e, i) => {
  e.pending_buf[e.pending++] = i;
}, putShortMSB = (e, i) => {
  e.pending_buf[e.pending++] = i >>> 8 & 255, e.pending_buf[e.pending++] = i & 255;
}, read_buf = (e, i, t, r) => {
  let n = e.avail_in;
  return n > r && (n = r), n === 0 ? 0 : (e.avail_in -= n, i.set(e.input.subarray(e.next_in, e.next_in + n), t), e.state.wrap === 1 ? e.adler = adler32_1$2(e.adler, i, n, t) : e.state.wrap === 2 && (e.adler = crc32_1$2(e.adler, i, n, t)), e.next_in += n, e.total_in += n, n);
}, longest_match = (e, i) => {
  let t = e.max_chain_length, r = e.strstart, n, a, s = e.prev_length, o = e.nice_match;
  const h = e.strstart > e.w_size - MIN_LOOKAHEAD ? e.strstart - (e.w_size - MIN_LOOKAHEAD) : 0, l = e.window, f = e.w_mask, b = e.prev, w = e.strstart + MAX_MATCH;
  let g = l[r + s - 1], E = l[r + s];
  e.prev_length >= e.good_match && (t >>= 2), o > e.lookahead && (o = e.lookahead);
  do
    if (n = i, !(l[n + s] !== E || l[n + s - 1] !== g || l[n] !== l[r] || l[++n] !== l[r + 1])) {
      r += 2, n++;
      do
        ;
      while (l[++r] === l[++n] && l[++r] === l[++n] && l[++r] === l[++n] && l[++r] === l[++n] && l[++r] === l[++n] && l[++r] === l[++n] && l[++r] === l[++n] && l[++r] === l[++n] && r < w);
      if (a = MAX_MATCH - (w - r), r = w - MAX_MATCH, a > s) {
        if (e.match_start = i, s = a, a >= o)
          break;
        g = l[r + s - 1], E = l[r + s];
      }
    }
  while ((i = b[i & f]) > h && --t !== 0);
  return s <= e.lookahead ? s : e.lookahead;
}, fill_window = (e) => {
  const i = e.w_size;
  let t, r, n;
  do {
    if (r = e.window_size - e.lookahead - e.strstart, e.strstart >= i + (i - MIN_LOOKAHEAD) && (e.window.set(e.window.subarray(i, i + i - r), 0), e.match_start -= i, e.strstart -= i, e.block_start -= i, e.insert > e.strstart && (e.insert = e.strstart), slide_hash(e), r += i), e.strm.avail_in === 0)
      break;
    if (t = read_buf(e.strm, e.window, e.strstart + e.lookahead, r), e.lookahead += t, e.lookahead + e.insert >= MIN_MATCH)
      for (n = e.strstart - e.insert, e.ins_h = e.window[n], e.ins_h = HASH(e, e.ins_h, e.window[n + 1]); e.insert && (e.ins_h = HASH(e, e.ins_h, e.window[n + MIN_MATCH - 1]), e.prev[n & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = n, n++, e.insert--, !(e.lookahead + e.insert < MIN_MATCH)); )
        ;
  } while (e.lookahead < MIN_LOOKAHEAD && e.strm.avail_in !== 0);
}, deflate_stored = (e, i) => {
  let t = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5, r, n, a, s = 0, o = e.strm.avail_in;
  do {
    if (r = 65535, a = e.bi_valid + 42 >> 3, e.strm.avail_out < a || (a = e.strm.avail_out - a, n = e.strstart - e.block_start, r > n + e.strm.avail_in && (r = n + e.strm.avail_in), r > a && (r = a), r < t && (r === 0 && i !== Z_FINISH$3 || i === Z_NO_FLUSH$2 || r !== n + e.strm.avail_in)))
      break;
    s = i === Z_FINISH$3 && r === n + e.strm.avail_in ? 1 : 0, _tr_stored_block(e, 0, 0, s), e.pending_buf[e.pending - 4] = r, e.pending_buf[e.pending - 3] = r >> 8, e.pending_buf[e.pending - 2] = ~r, e.pending_buf[e.pending - 1] = ~r >> 8, flush_pending(e.strm), n && (n > r && (n = r), e.strm.output.set(e.window.subarray(e.block_start, e.block_start + n), e.strm.next_out), e.strm.next_out += n, e.strm.avail_out -= n, e.strm.total_out += n, e.block_start += n, r -= n), r && (read_buf(e.strm, e.strm.output, e.strm.next_out, r), e.strm.next_out += r, e.strm.avail_out -= r, e.strm.total_out += r);
  } while (s === 0);
  return o -= e.strm.avail_in, o && (o >= e.w_size ? (e.matches = 2, e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0), e.strstart = e.w_size, e.insert = e.strstart) : (e.window_size - e.strstart <= o && (e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, e.insert > e.strstart && (e.insert = e.strstart)), e.window.set(e.strm.input.subarray(e.strm.next_in - o, e.strm.next_in), e.strstart), e.strstart += o, e.insert += o > e.w_size - e.insert ? e.w_size - e.insert : o), e.block_start = e.strstart), e.high_water < e.strstart && (e.high_water = e.strstart), s ? BS_FINISH_DONE : i !== Z_NO_FLUSH$2 && i !== Z_FINISH$3 && e.strm.avail_in === 0 && e.strstart === e.block_start ? BS_BLOCK_DONE : (a = e.window_size - e.strstart, e.strm.avail_in > a && e.block_start >= e.w_size && (e.block_start -= e.w_size, e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, a += e.w_size, e.insert > e.strstart && (e.insert = e.strstart)), a > e.strm.avail_in && (a = e.strm.avail_in), a && (read_buf(e.strm, e.window, e.strstart, a), e.strstart += a, e.insert += a > e.w_size - e.insert ? e.w_size - e.insert : a), e.high_water < e.strstart && (e.high_water = e.strstart), a = e.bi_valid + 42 >> 3, a = e.pending_buf_size - a > 65535 ? 65535 : e.pending_buf_size - a, t = a > e.w_size ? e.w_size : a, n = e.strstart - e.block_start, (n >= t || (n || i === Z_FINISH$3) && i !== Z_NO_FLUSH$2 && e.strm.avail_in === 0 && n <= a) && (r = n > a ? a : n, s = i === Z_FINISH$3 && e.strm.avail_in === 0 && r === n ? 1 : 0, _tr_stored_block(e, e.block_start, r, s), e.block_start += r, flush_pending(e.strm)), s ? BS_FINISH_STARTED : BS_NEED_MORE);
}, deflate_fast = (e, i) => {
  let t, r;
  for (; ; ) {
    if (e.lookahead < MIN_LOOKAHEAD) {
      if (fill_window(e), e.lookahead < MIN_LOOKAHEAD && i === Z_NO_FLUSH$2)
        return BS_NEED_MORE;
      if (e.lookahead === 0)
        break;
    }
    if (t = 0, e.lookahead >= MIN_MATCH && (e.ins_h = HASH(e, e.ins_h, e.window[e.strstart + MIN_MATCH - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), t !== 0 && e.strstart - t <= e.w_size - MIN_LOOKAHEAD && (e.match_length = longest_match(e, t)), e.match_length >= MIN_MATCH)
      if (r = _tr_tally(e, e.strstart - e.match_start, e.match_length - MIN_MATCH), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= MIN_MATCH) {
        e.match_length--;
        do
          e.strstart++, e.ins_h = HASH(e, e.ins_h, e.window[e.strstart + MIN_MATCH - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;
        while (--e.match_length !== 0);
        e.strstart++;
      } else
        e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = HASH(e, e.ins_h, e.window[e.strstart + 1]);
    else
      r = _tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
    if (r && (flush_block_only(e, !1), e.strm.avail_out === 0))
      return BS_NEED_MORE;
  }
  return e.insert = e.strstart < MIN_MATCH - 1 ? e.strstart : MIN_MATCH - 1, i === Z_FINISH$3 ? (flush_block_only(e, !0), e.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : e.sym_next && (flush_block_only(e, !1), e.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE;
}, deflate_slow = (e, i) => {
  let t, r, n;
  for (; ; ) {
    if (e.lookahead < MIN_LOOKAHEAD) {
      if (fill_window(e), e.lookahead < MIN_LOOKAHEAD && i === Z_NO_FLUSH$2)
        return BS_NEED_MORE;
      if (e.lookahead === 0)
        break;
    }
    if (t = 0, e.lookahead >= MIN_MATCH && (e.ins_h = HASH(e, e.ins_h, e.window[e.strstart + MIN_MATCH - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = MIN_MATCH - 1, t !== 0 && e.prev_length < e.max_lazy_match && e.strstart - t <= e.w_size - MIN_LOOKAHEAD && (e.match_length = longest_match(e, t), e.match_length <= 5 && (e.strategy === Z_FILTERED || e.match_length === MIN_MATCH && e.strstart - e.match_start > 4096) && (e.match_length = MIN_MATCH - 1)), e.prev_length >= MIN_MATCH && e.match_length <= e.prev_length) {
      n = e.strstart + e.lookahead - MIN_MATCH, r = _tr_tally(e, e.strstart - 1 - e.prev_match, e.prev_length - MIN_MATCH), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
      do
        ++e.strstart <= n && (e.ins_h = HASH(e, e.ins_h, e.window[e.strstart + MIN_MATCH - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);
      while (--e.prev_length !== 0);
      if (e.match_available = 0, e.match_length = MIN_MATCH - 1, e.strstart++, r && (flush_block_only(e, !1), e.strm.avail_out === 0))
        return BS_NEED_MORE;
    } else if (e.match_available) {
      if (r = _tr_tally(e, 0, e.window[e.strstart - 1]), r && flush_block_only(e, !1), e.strstart++, e.lookahead--, e.strm.avail_out === 0)
        return BS_NEED_MORE;
    } else
      e.match_available = 1, e.strstart++, e.lookahead--;
  }
  return e.match_available && (r = _tr_tally(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < MIN_MATCH - 1 ? e.strstart : MIN_MATCH - 1, i === Z_FINISH$3 ? (flush_block_only(e, !0), e.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : e.sym_next && (flush_block_only(e, !1), e.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE;
}, deflate_rle = (e, i) => {
  let t, r, n, a;
  const s = e.window;
  for (; ; ) {
    if (e.lookahead <= MAX_MATCH) {
      if (fill_window(e), e.lookahead <= MAX_MATCH && i === Z_NO_FLUSH$2)
        return BS_NEED_MORE;
      if (e.lookahead === 0)
        break;
    }
    if (e.match_length = 0, e.lookahead >= MIN_MATCH && e.strstart > 0 && (n = e.strstart - 1, r = s[n], r === s[++n] && r === s[++n] && r === s[++n])) {
      a = e.strstart + MAX_MATCH;
      do
        ;
      while (r === s[++n] && r === s[++n] && r === s[++n] && r === s[++n] && r === s[++n] && r === s[++n] && r === s[++n] && r === s[++n] && n < a);
      e.match_length = MAX_MATCH - (a - n), e.match_length > e.lookahead && (e.match_length = e.lookahead);
    }
    if (e.match_length >= MIN_MATCH ? (t = _tr_tally(e, 1, e.match_length - MIN_MATCH), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (t = _tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), t && (flush_block_only(e, !1), e.strm.avail_out === 0))
      return BS_NEED_MORE;
  }
  return e.insert = 0, i === Z_FINISH$3 ? (flush_block_only(e, !0), e.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : e.sym_next && (flush_block_only(e, !1), e.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE;
}, deflate_huff = (e, i) => {
  let t;
  for (; ; ) {
    if (e.lookahead === 0 && (fill_window(e), e.lookahead === 0)) {
      if (i === Z_NO_FLUSH$2)
        return BS_NEED_MORE;
      break;
    }
    if (e.match_length = 0, t = _tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, t && (flush_block_only(e, !1), e.strm.avail_out === 0))
      return BS_NEED_MORE;
  }
  return e.insert = 0, i === Z_FINISH$3 ? (flush_block_only(e, !0), e.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : e.sym_next && (flush_block_only(e, !1), e.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE;
};
function Config(e, i, t, r, n) {
  this.good_length = e, this.max_lazy = i, this.nice_length = t, this.max_chain = r, this.func = n;
}
const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
], lm_init = (e) => {
  e.window_size = 2 * e.w_size, zero(e.head), e.max_lazy_match = configuration_table[e.level].max_lazy, e.good_match = configuration_table[e.level].good_length, e.nice_match = configuration_table[e.level].nice_length, e.max_chain_length = configuration_table[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = MIN_MATCH - 1, e.match_available = 0, e.ins_h = 0;
};
function DeflateState() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Z_DEFLATED$2, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2), this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2), this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2), zero(this.dyn_ltree), zero(this.dyn_dtree), zero(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(MAX_BITS + 1), this.heap = new Uint16Array(2 * L_CODES + 1), zero(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * L_CODES + 1), zero(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
const deflateStateCheck = (e) => {
  if (!e)
    return 1;
  const i = e.state;
  return !i || i.strm !== e || i.status !== INIT_STATE && //#ifdef GZIP
  i.status !== GZIP_STATE && //#endif
  i.status !== EXTRA_STATE && i.status !== NAME_STATE && i.status !== COMMENT_STATE && i.status !== HCRC_STATE && i.status !== BUSY_STATE && i.status !== FINISH_STATE ? 1 : 0;
}, deflateResetKeep = (e) => {
  if (deflateStateCheck(e))
    return err(e, Z_STREAM_ERROR$2);
  e.total_in = e.total_out = 0, e.data_type = Z_UNKNOWN;
  const i = e.state;
  return i.pending = 0, i.pending_out = 0, i.wrap < 0 && (i.wrap = -i.wrap), i.status = //#ifdef GZIP
  i.wrap === 2 ? GZIP_STATE : (
    //#endif
    i.wrap ? INIT_STATE : BUSY_STATE
  ), e.adler = i.wrap === 2 ? 0 : 1, i.last_flush = -2, _tr_init(i), Z_OK$3;
}, deflateReset = (e) => {
  const i = deflateResetKeep(e);
  return i === Z_OK$3 && lm_init(e.state), i;
}, deflateSetHeader = (e, i) => deflateStateCheck(e) || e.state.wrap !== 2 ? Z_STREAM_ERROR$2 : (e.state.gzhead = i, Z_OK$3), deflateInit2 = (e, i, t, r, n, a) => {
  if (!e)
    return Z_STREAM_ERROR$2;
  let s = 1;
  if (i === Z_DEFAULT_COMPRESSION$1 && (i = 6), r < 0 ? (s = 0, r = -r) : r > 15 && (s = 2, r -= 16), n < 1 || n > MAX_MEM_LEVEL || t !== Z_DEFLATED$2 || r < 8 || r > 15 || i < 0 || i > 9 || a < 0 || a > Z_FIXED || r === 8 && s !== 1)
    return err(e, Z_STREAM_ERROR$2);
  r === 8 && (r = 9);
  const o = new DeflateState();
  return e.state = o, o.strm = e, o.status = INIT_STATE, o.wrap = s, o.gzhead = null, o.w_bits = r, o.w_size = 1 << o.w_bits, o.w_mask = o.w_size - 1, o.hash_bits = n + 7, o.hash_size = 1 << o.hash_bits, o.hash_mask = o.hash_size - 1, o.hash_shift = ~~((o.hash_bits + MIN_MATCH - 1) / MIN_MATCH), o.window = new Uint8Array(o.w_size * 2), o.head = new Uint16Array(o.hash_size), o.prev = new Uint16Array(o.w_size), o.lit_bufsize = 1 << n + 6, o.pending_buf_size = o.lit_bufsize * 4, o.pending_buf = new Uint8Array(o.pending_buf_size), o.sym_buf = o.lit_bufsize, o.sym_end = (o.lit_bufsize - 1) * 3, o.level = i, o.strategy = a, o.method = t, deflateReset(e);
}, deflateInit = (e, i) => deflateInit2(e, i, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1), deflate$2 = (e, i) => {
  if (deflateStateCheck(e) || i > Z_BLOCK$1 || i < 0)
    return e ? err(e, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  const t = e.state;
  if (!e.output || e.avail_in !== 0 && !e.input || t.status === FINISH_STATE && i !== Z_FINISH$3)
    return err(e, e.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  const r = t.last_flush;
  if (t.last_flush = i, t.pending !== 0) {
    if (flush_pending(e), e.avail_out === 0)
      return t.last_flush = -1, Z_OK$3;
  } else if (e.avail_in === 0 && rank(i) <= rank(r) && i !== Z_FINISH$3)
    return err(e, Z_BUF_ERROR$1);
  if (t.status === FINISH_STATE && e.avail_in !== 0)
    return err(e, Z_BUF_ERROR$1);
  if (t.status === INIT_STATE && t.wrap === 0 && (t.status = BUSY_STATE), t.status === INIT_STATE) {
    let n = Z_DEFLATED$2 + (t.w_bits - 8 << 4) << 8, a = -1;
    if (t.strategy >= Z_HUFFMAN_ONLY || t.level < 2 ? a = 0 : t.level < 6 ? a = 1 : t.level === 6 ? a = 2 : a = 3, n |= a << 6, t.strstart !== 0 && (n |= PRESET_DICT), n += 31 - n % 31, putShortMSB(t, n), t.strstart !== 0 && (putShortMSB(t, e.adler >>> 16), putShortMSB(t, e.adler & 65535)), e.adler = 1, t.status = BUSY_STATE, flush_pending(e), t.pending !== 0)
      return t.last_flush = -1, Z_OK$3;
  }
  if (t.status === GZIP_STATE) {
    if (e.adler = 0, put_byte(t, 31), put_byte(t, 139), put_byte(t, 8), t.gzhead)
      put_byte(
        t,
        (t.gzhead.text ? 1 : 0) + (t.gzhead.hcrc ? 2 : 0) + (t.gzhead.extra ? 4 : 0) + (t.gzhead.name ? 8 : 0) + (t.gzhead.comment ? 16 : 0)
      ), put_byte(t, t.gzhead.time & 255), put_byte(t, t.gzhead.time >> 8 & 255), put_byte(t, t.gzhead.time >> 16 & 255), put_byte(t, t.gzhead.time >> 24 & 255), put_byte(t, t.level === 9 ? 2 : t.strategy >= Z_HUFFMAN_ONLY || t.level < 2 ? 4 : 0), put_byte(t, t.gzhead.os & 255), t.gzhead.extra && t.gzhead.extra.length && (put_byte(t, t.gzhead.extra.length & 255), put_byte(t, t.gzhead.extra.length >> 8 & 255)), t.gzhead.hcrc && (e.adler = crc32_1$2(e.adler, t.pending_buf, t.pending, 0)), t.gzindex = 0, t.status = EXTRA_STATE;
    else if (put_byte(t, 0), put_byte(t, 0), put_byte(t, 0), put_byte(t, 0), put_byte(t, 0), put_byte(t, t.level === 9 ? 2 : t.strategy >= Z_HUFFMAN_ONLY || t.level < 2 ? 4 : 0), put_byte(t, OS_CODE), t.status = BUSY_STATE, flush_pending(e), t.pending !== 0)
      return t.last_flush = -1, Z_OK$3;
  }
  if (t.status === EXTRA_STATE) {
    if (t.gzhead.extra) {
      let n = t.pending, a = (t.gzhead.extra.length & 65535) - t.gzindex;
      for (; t.pending + a > t.pending_buf_size; ) {
        let o = t.pending_buf_size - t.pending;
        if (t.pending_buf.set(t.gzhead.extra.subarray(t.gzindex, t.gzindex + o), t.pending), t.pending = t.pending_buf_size, t.gzhead.hcrc && t.pending > n && (e.adler = crc32_1$2(e.adler, t.pending_buf, t.pending - n, n)), t.gzindex += o, flush_pending(e), t.pending !== 0)
          return t.last_flush = -1, Z_OK$3;
        n = 0, a -= o;
      }
      let s = new Uint8Array(t.gzhead.extra);
      t.pending_buf.set(s.subarray(t.gzindex, t.gzindex + a), t.pending), t.pending += a, t.gzhead.hcrc && t.pending > n && (e.adler = crc32_1$2(e.adler, t.pending_buf, t.pending - n, n)), t.gzindex = 0;
    }
    t.status = NAME_STATE;
  }
  if (t.status === NAME_STATE) {
    if (t.gzhead.name) {
      let n = t.pending, a;
      do {
        if (t.pending === t.pending_buf_size) {
          if (t.gzhead.hcrc && t.pending > n && (e.adler = crc32_1$2(e.adler, t.pending_buf, t.pending - n, n)), flush_pending(e), t.pending !== 0)
            return t.last_flush = -1, Z_OK$3;
          n = 0;
        }
        t.gzindex < t.gzhead.name.length ? a = t.gzhead.name.charCodeAt(t.gzindex++) & 255 : a = 0, put_byte(t, a);
      } while (a !== 0);
      t.gzhead.hcrc && t.pending > n && (e.adler = crc32_1$2(e.adler, t.pending_buf, t.pending - n, n)), t.gzindex = 0;
    }
    t.status = COMMENT_STATE;
  }
  if (t.status === COMMENT_STATE) {
    if (t.gzhead.comment) {
      let n = t.pending, a;
      do {
        if (t.pending === t.pending_buf_size) {
          if (t.gzhead.hcrc && t.pending > n && (e.adler = crc32_1$2(e.adler, t.pending_buf, t.pending - n, n)), flush_pending(e), t.pending !== 0)
            return t.last_flush = -1, Z_OK$3;
          n = 0;
        }
        t.gzindex < t.gzhead.comment.length ? a = t.gzhead.comment.charCodeAt(t.gzindex++) & 255 : a = 0, put_byte(t, a);
      } while (a !== 0);
      t.gzhead.hcrc && t.pending > n && (e.adler = crc32_1$2(e.adler, t.pending_buf, t.pending - n, n));
    }
    t.status = HCRC_STATE;
  }
  if (t.status === HCRC_STATE) {
    if (t.gzhead.hcrc) {
      if (t.pending + 2 > t.pending_buf_size && (flush_pending(e), t.pending !== 0))
        return t.last_flush = -1, Z_OK$3;
      put_byte(t, e.adler & 255), put_byte(t, e.adler >> 8 & 255), e.adler = 0;
    }
    if (t.status = BUSY_STATE, flush_pending(e), t.pending !== 0)
      return t.last_flush = -1, Z_OK$3;
  }
  if (e.avail_in !== 0 || t.lookahead !== 0 || i !== Z_NO_FLUSH$2 && t.status !== FINISH_STATE) {
    let n = t.level === 0 ? deflate_stored(t, i) : t.strategy === Z_HUFFMAN_ONLY ? deflate_huff(t, i) : t.strategy === Z_RLE ? deflate_rle(t, i) : configuration_table[t.level].func(t, i);
    if ((n === BS_FINISH_STARTED || n === BS_FINISH_DONE) && (t.status = FINISH_STATE), n === BS_NEED_MORE || n === BS_FINISH_STARTED)
      return e.avail_out === 0 && (t.last_flush = -1), Z_OK$3;
    if (n === BS_BLOCK_DONE && (i === Z_PARTIAL_FLUSH ? _tr_align(t) : i !== Z_BLOCK$1 && (_tr_stored_block(t, 0, 0, !1), i === Z_FULL_FLUSH$1 && (zero(t.head), t.lookahead === 0 && (t.strstart = 0, t.block_start = 0, t.insert = 0))), flush_pending(e), e.avail_out === 0))
      return t.last_flush = -1, Z_OK$3;
  }
  return i !== Z_FINISH$3 ? Z_OK$3 : t.wrap <= 0 ? Z_STREAM_END$3 : (t.wrap === 2 ? (put_byte(t, e.adler & 255), put_byte(t, e.adler >> 8 & 255), put_byte(t, e.adler >> 16 & 255), put_byte(t, e.adler >> 24 & 255), put_byte(t, e.total_in & 255), put_byte(t, e.total_in >> 8 & 255), put_byte(t, e.total_in >> 16 & 255), put_byte(t, e.total_in >> 24 & 255)) : (putShortMSB(t, e.adler >>> 16), putShortMSB(t, e.adler & 65535)), flush_pending(e), t.wrap > 0 && (t.wrap = -t.wrap), t.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3);
}, deflateEnd = (e) => {
  if (deflateStateCheck(e))
    return Z_STREAM_ERROR$2;
  const i = e.state.status;
  return e.state = null, i === BUSY_STATE ? err(e, Z_DATA_ERROR$2) : Z_OK$3;
}, deflateSetDictionary = (e, i) => {
  let t = i.length;
  if (deflateStateCheck(e))
    return Z_STREAM_ERROR$2;
  const r = e.state, n = r.wrap;
  if (n === 2 || n === 1 && r.status !== INIT_STATE || r.lookahead)
    return Z_STREAM_ERROR$2;
  if (n === 1 && (e.adler = adler32_1$2(e.adler, i, t, 0)), r.wrap = 0, t >= r.w_size) {
    n === 0 && (zero(r.head), r.strstart = 0, r.block_start = 0, r.insert = 0);
    let h = new Uint8Array(r.w_size);
    h.set(i.subarray(t - r.w_size, t), 0), i = h, t = r.w_size;
  }
  const a = e.avail_in, s = e.next_in, o = e.input;
  for (e.avail_in = t, e.next_in = 0, e.input = i, fill_window(r); r.lookahead >= MIN_MATCH; ) {
    let h = r.strstart, l = r.lookahead - (MIN_MATCH - 1);
    do
      r.ins_h = HASH(r, r.ins_h, r.window[h + MIN_MATCH - 1]), r.prev[h & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = h, h++;
    while (--l);
    r.strstart = h, r.lookahead = MIN_MATCH - 1, fill_window(r);
  }
  return r.strstart += r.lookahead, r.block_start = r.strstart, r.insert = r.lookahead, r.lookahead = 0, r.match_length = r.prev_length = MIN_MATCH - 1, r.match_available = 0, e.next_in = s, e.input = o, e.avail_in = a, r.wrap = n, Z_OK$3;
};
var deflateInit_1 = deflateInit, deflateInit2_1 = deflateInit2, deflateReset_1 = deflateReset, deflateResetKeep_1 = deflateResetKeep, deflateSetHeader_1 = deflateSetHeader, deflate_2$1 = deflate$2, deflateEnd_1 = deflateEnd, deflateSetDictionary_1 = deflateSetDictionary, deflateInfo = "pako deflate (from Nodeca project)", deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
const _has$1 = (e, i) => Object.prototype.hasOwnProperty.call(e, i);
var assign$1 = function(e) {
  const i = Array.prototype.slice.call(arguments, 1);
  for (; i.length; ) {
    const t = i.shift();
    if (t) {
      if (typeof t != "object")
        throw new TypeError(t + "must be non-object");
      for (const r in t)
        _has$1(t, r) && (e[r] = t[r]);
    }
  }
  return e;
}, flattenChunks$1 = (e) => {
  let i = 0;
  for (let r = 0, n = e.length; r < n; r++)
    i += e[r].length;
  const t = new Uint8Array(i);
  for (let r = 0, n = 0, a = e.length; r < a; r++) {
    let s = e[r];
    t.set(s, n), n += s.length;
  }
  return t;
}, common$2 = {
  assign: assign$1,
  flattenChunks: flattenChunks$1
};
let STR_APPLY_UIA_OK$1 = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  STR_APPLY_UIA_OK$1 = !1;
}
const _utf8len$1 = new Uint8Array(256);
for (let e = 0; e < 256; e++)
  _utf8len$1[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
_utf8len$1[254] = _utf8len$1[254] = 1;
var string2buf$1 = (e) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(e);
  let i, t, r, n, a, s = e.length, o = 0;
  for (n = 0; n < s; n++)
    t = e.charCodeAt(n), (t & 64512) === 55296 && n + 1 < s && (r = e.charCodeAt(n + 1), (r & 64512) === 56320 && (t = 65536 + (t - 55296 << 10) + (r - 56320), n++)), o += t < 128 ? 1 : t < 2048 ? 2 : t < 65536 ? 3 : 4;
  for (i = new Uint8Array(o), a = 0, n = 0; a < o; n++)
    t = e.charCodeAt(n), (t & 64512) === 55296 && n + 1 < s && (r = e.charCodeAt(n + 1), (r & 64512) === 56320 && (t = 65536 + (t - 55296 << 10) + (r - 56320), n++)), t < 128 ? i[a++] = t : t < 2048 ? (i[a++] = 192 | t >>> 6, i[a++] = 128 | t & 63) : t < 65536 ? (i[a++] = 224 | t >>> 12, i[a++] = 128 | t >>> 6 & 63, i[a++] = 128 | t & 63) : (i[a++] = 240 | t >>> 18, i[a++] = 128 | t >>> 12 & 63, i[a++] = 128 | t >>> 6 & 63, i[a++] = 128 | t & 63);
  return i;
};
const buf2binstring$1 = (e, i) => {
  if (i < 65534 && e.subarray && STR_APPLY_UIA_OK$1)
    return String.fromCharCode.apply(null, e.length === i ? e : e.subarray(0, i));
  let t = "";
  for (let r = 0; r < i; r++)
    t += String.fromCharCode(e[r]);
  return t;
};
var buf2string$1 = (e, i) => {
  const t = i || e.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(e.subarray(0, i));
  let r, n;
  const a = new Array(t * 2);
  for (n = 0, r = 0; r < t; ) {
    let s = e[r++];
    if (s < 128) {
      a[n++] = s;
      continue;
    }
    let o = _utf8len$1[s];
    if (o > 4) {
      a[n++] = 65533, r += o - 1;
      continue;
    }
    for (s &= o === 2 ? 31 : o === 3 ? 15 : 7; o > 1 && r < t; )
      s = s << 6 | e[r++] & 63, o--;
    if (o > 1) {
      a[n++] = 65533;
      continue;
    }
    s < 65536 ? a[n++] = s : (s -= 65536, a[n++] = 55296 | s >> 10 & 1023, a[n++] = 56320 | s & 1023);
  }
  return buf2binstring$1(a, n);
}, utf8border$1 = (e, i) => {
  i = i || e.length, i > e.length && (i = e.length);
  let t = i - 1;
  for (; t >= 0 && (e[t] & 192) === 128; )
    t--;
  return t < 0 || t === 0 ? i : t + _utf8len$1[e[t]] > i ? t : i;
}, strings$2 = {
  string2buf: string2buf$1,
  buf2string: buf2string$1,
  utf8border: utf8border$1
};
function ZStream$1() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var zstream$2 = ZStream$1;
const toString$1$1 = Object.prototype.toString, {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2$1;
function Deflate$1(e) {
  this.options = common$2.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, e || {});
  let i = this.options;
  i.raw && i.windowBits > 0 ? i.windowBits = -i.windowBits : i.gzip && i.windowBits > 0 && i.windowBits < 16 && (i.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new zstream$2(), this.strm.avail_out = 0;
  let t = deflate_1$2.deflateInit2(
    this.strm,
    i.level,
    i.method,
    i.windowBits,
    i.memLevel,
    i.strategy
  );
  if (t !== Z_OK$2)
    throw new Error(messages$2[t]);
  if (i.header && deflate_1$2.deflateSetHeader(this.strm, i.header), i.dictionary) {
    let r;
    if (typeof i.dictionary == "string" ? r = strings$2.string2buf(i.dictionary) : toString$1$1.call(i.dictionary) === "[object ArrayBuffer]" ? r = new Uint8Array(i.dictionary) : r = i.dictionary, t = deflate_1$2.deflateSetDictionary(this.strm, r), t !== Z_OK$2)
      throw new Error(messages$2[t]);
    this._dict_set = !0;
  }
}
Deflate$1.prototype.push = function(e, i) {
  const t = this.strm, r = this.options.chunkSize;
  let n, a;
  if (this.ended)
    return !1;
  for (i === ~~i ? a = i : a = i === !0 ? Z_FINISH$2 : Z_NO_FLUSH$1, typeof e == "string" ? t.input = strings$2.string2buf(e) : toString$1$1.call(e) === "[object ArrayBuffer]" ? t.input = new Uint8Array(e) : t.input = e, t.next_in = 0, t.avail_in = t.input.length; ; ) {
    if (t.avail_out === 0 && (t.output = new Uint8Array(r), t.next_out = 0, t.avail_out = r), (a === Z_SYNC_FLUSH || a === Z_FULL_FLUSH) && t.avail_out <= 6) {
      this.onData(t.output.subarray(0, t.next_out)), t.avail_out = 0;
      continue;
    }
    if (n = deflate_1$2.deflate(t, a), n === Z_STREAM_END$2)
      return t.next_out > 0 && this.onData(t.output.subarray(0, t.next_out)), n = deflate_1$2.deflateEnd(this.strm), this.onEnd(n), this.ended = !0, n === Z_OK$2;
    if (t.avail_out === 0) {
      this.onData(t.output);
      continue;
    }
    if (a > 0 && t.next_out > 0) {
      this.onData(t.output.subarray(0, t.next_out)), t.avail_out = 0;
      continue;
    }
    if (t.avail_in === 0) break;
  }
  return !0;
};
Deflate$1.prototype.onData = function(e) {
  this.chunks.push(e);
};
Deflate$1.prototype.onEnd = function(e) {
  e === Z_OK$2 && (this.result = common$2.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function deflate$1$1(e, i) {
  const t = new Deflate$1(i);
  if (t.push(e, !0), t.err)
    throw t.msg || messages$2[t.err];
  return t.result;
}
var deflate_2 = deflate$1$1, deflate_1$1 = {
  deflate: deflate_2
};
const BAD$1$1 = 16209, TYPE$1$1 = 16191;
var inffast$2 = function(i, t) {
  let r, n, a, s, o, h, l, f, b, w, g, E, k, A, T, C, D, $, P, z, B, F, O, N;
  const G = i.state;
  r = i.next_in, O = i.input, n = r + (i.avail_in - 5), a = i.next_out, N = i.output, s = a - (t - i.avail_out), o = a + (i.avail_out - 257), h = G.dmax, l = G.wsize, f = G.whave, b = G.wnext, w = G.window, g = G.hold, E = G.bits, k = G.lencode, A = G.distcode, T = (1 << G.lenbits) - 1, C = (1 << G.distbits) - 1;
  e:
    do {
      E < 15 && (g += O[r++] << E, E += 8, g += O[r++] << E, E += 8), D = k[g & T];
      t:
        for (; ; ) {
          if ($ = D >>> 24, g >>>= $, E -= $, $ = D >>> 16 & 255, $ === 0)
            N[a++] = D & 65535;
          else if ($ & 16) {
            P = D & 65535, $ &= 15, $ && (E < $ && (g += O[r++] << E, E += 8), P += g & (1 << $) - 1, g >>>= $, E -= $), E < 15 && (g += O[r++] << E, E += 8, g += O[r++] << E, E += 8), D = A[g & C];
            i:
              for (; ; ) {
                if ($ = D >>> 24, g >>>= $, E -= $, $ = D >>> 16 & 255, $ & 16) {
                  if (z = D & 65535, $ &= 15, E < $ && (g += O[r++] << E, E += 8, E < $ && (g += O[r++] << E, E += 8)), z += g & (1 << $) - 1, z > h) {
                    i.msg = "invalid distance too far back", G.mode = BAD$1$1;
                    break e;
                  }
                  if (g >>>= $, E -= $, $ = a - s, z > $) {
                    if ($ = z - $, $ > f && G.sane) {
                      i.msg = "invalid distance too far back", G.mode = BAD$1$1;
                      break e;
                    }
                    if (B = 0, F = w, b === 0) {
                      if (B += l - $, $ < P) {
                        P -= $;
                        do
                          N[a++] = w[B++];
                        while (--$);
                        B = a - z, F = N;
                      }
                    } else if (b < $) {
                      if (B += l + b - $, $ -= b, $ < P) {
                        P -= $;
                        do
                          N[a++] = w[B++];
                        while (--$);
                        if (B = 0, b < P) {
                          $ = b, P -= $;
                          do
                            N[a++] = w[B++];
                          while (--$);
                          B = a - z, F = N;
                        }
                      }
                    } else if (B += b - $, $ < P) {
                      P -= $;
                      do
                        N[a++] = w[B++];
                      while (--$);
                      B = a - z, F = N;
                    }
                    for (; P > 2; )
                      N[a++] = F[B++], N[a++] = F[B++], N[a++] = F[B++], P -= 3;
                    P && (N[a++] = F[B++], P > 1 && (N[a++] = F[B++]));
                  } else {
                    B = a - z;
                    do
                      N[a++] = N[B++], N[a++] = N[B++], N[a++] = N[B++], P -= 3;
                    while (P > 2);
                    P && (N[a++] = N[B++], P > 1 && (N[a++] = N[B++]));
                  }
                } else if (($ & 64) === 0) {
                  D = A[(D & 65535) + (g & (1 << $) - 1)];
                  continue i;
                } else {
                  i.msg = "invalid distance code", G.mode = BAD$1$1;
                  break e;
                }
                break;
              }
          } else if (($ & 64) === 0) {
            D = k[(D & 65535) + (g & (1 << $) - 1)];
            continue t;
          } else if ($ & 32) {
            G.mode = TYPE$1$1;
            break e;
          } else {
            i.msg = "invalid literal/length code", G.mode = BAD$1$1;
            break e;
          }
          break;
        }
    } while (r < n && a < o);
  P = E >> 3, r -= P, E -= P << 3, g &= (1 << E) - 1, i.next_in = r, i.next_out = a, i.avail_in = r < n ? 5 + (n - r) : 5 - (r - n), i.avail_out = a < o ? 257 + (o - a) : 257 - (a - o), G.hold = g, G.bits = E;
};
const MAXBITS$1 = 15, ENOUGH_LENS$1$1 = 852, ENOUGH_DISTS$1$1 = 592, CODES$1$1 = 0, LENS$1$1 = 1, DISTS$1$1 = 2, lbase$1 = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]), lext$1 = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]), dbase$1 = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]), dext$1 = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]), inflate_table$1 = (e, i, t, r, n, a, s, o) => {
  const h = o.bits;
  let l = 0, f = 0, b = 0, w = 0, g = 0, E = 0, k = 0, A = 0, T = 0, C = 0, D, $, P, z, B, F = null, O;
  const N = new Uint16Array(MAXBITS$1 + 1), G = new Uint16Array(MAXBITS$1 + 1);
  let V = null, J, Q, W;
  for (l = 0; l <= MAXBITS$1; l++)
    N[l] = 0;
  for (f = 0; f < r; f++)
    N[i[t + f]]++;
  for (g = h, w = MAXBITS$1; w >= 1 && N[w] === 0; w--)
    ;
  if (g > w && (g = w), w === 0)
    return n[a++] = 1 << 24 | 64 << 16 | 0, n[a++] = 1 << 24 | 64 << 16 | 0, o.bits = 1, 0;
  for (b = 1; b < w && N[b] === 0; b++)
    ;
  for (g < b && (g = b), A = 1, l = 1; l <= MAXBITS$1; l++)
    if (A <<= 1, A -= N[l], A < 0)
      return -1;
  if (A > 0 && (e === CODES$1$1 || w !== 1))
    return -1;
  for (G[1] = 0, l = 1; l < MAXBITS$1; l++)
    G[l + 1] = G[l] + N[l];
  for (f = 0; f < r; f++)
    i[t + f] !== 0 && (s[G[i[t + f]]++] = f);
  if (e === CODES$1$1 ? (F = V = s, O = 20) : e === LENS$1$1 ? (F = lbase$1, V = lext$1, O = 257) : (F = dbase$1, V = dext$1, O = 0), C = 0, f = 0, l = b, B = a, E = g, k = 0, P = -1, T = 1 << g, z = T - 1, e === LENS$1$1 && T > ENOUGH_LENS$1$1 || e === DISTS$1$1 && T > ENOUGH_DISTS$1$1)
    return 1;
  for (; ; ) {
    J = l - k, s[f] + 1 < O ? (Q = 0, W = s[f]) : s[f] >= O ? (Q = V[s[f] - O], W = F[s[f] - O]) : (Q = 96, W = 0), D = 1 << l - k, $ = 1 << E, b = $;
    do
      $ -= D, n[B + (C >> k) + $] = J << 24 | Q << 16 | W | 0;
    while ($ !== 0);
    for (D = 1 << l - 1; C & D; )
      D >>= 1;
    if (D !== 0 ? (C &= D - 1, C += D) : C = 0, f++, --N[l] === 0) {
      if (l === w)
        break;
      l = i[t + s[f]];
    }
    if (l > g && (C & z) !== P) {
      for (k === 0 && (k = g), B += b, E = l - k, A = 1 << E; E + k < w && (A -= N[E + k], !(A <= 0)); )
        E++, A <<= 1;
      if (T += 1 << E, e === LENS$1$1 && T > ENOUGH_LENS$1$1 || e === DISTS$1$1 && T > ENOUGH_DISTS$1$1)
        return 1;
      P = C & z, n[P] = g << 24 | E << 16 | B - a | 0;
    }
  }
  return C !== 0 && (n[B + C] = l - k << 24 | 64 << 16 | 0), o.bits = g, 0;
};
var inftrees$2 = inflate_table$1;
const CODES$2 = 0, LENS$2 = 1, DISTS$2 = 2, {
  Z_FINISH: Z_FINISH$1$1,
  Z_BLOCK: Z_BLOCK$2,
  Z_TREES: Z_TREES$1,
  Z_OK: Z_OK$1$1,
  Z_STREAM_END: Z_STREAM_END$1$1,
  Z_NEED_DICT: Z_NEED_DICT$1$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1$1,
  Z_BUF_ERROR: Z_BUF_ERROR$2,
  Z_DEFLATED: Z_DEFLATED$3
} = constants$2$1, HEAD$1 = 16180, FLAGS$1 = 16181, TIME$1 = 16182, OS$1 = 16183, EXLEN$1 = 16184, EXTRA$1 = 16185, NAME$1 = 16186, COMMENT$1 = 16187, HCRC$1 = 16188, DICTID$1 = 16189, DICT$1 = 16190, TYPE$2 = 16191, TYPEDO$1 = 16192, STORED$1 = 16193, COPY_$1 = 16194, COPY$1 = 16195, TABLE$1 = 16196, LENLENS$1 = 16197, CODELENS$1 = 16198, LEN_$1 = 16199, LEN$1 = 16200, LENEXT$1 = 16201, DIST$1 = 16202, DISTEXT$1 = 16203, MATCH$1 = 16204, LIT$1 = 16205, CHECK$1 = 16206, LENGTH$1 = 16207, DONE$1 = 16208, BAD$2 = 16209, MEM$1 = 16210, SYNC$1 = 16211, ENOUGH_LENS$2 = 852, ENOUGH_DISTS$2 = 592, MAX_WBITS$2 = 15, DEF_WBITS$1 = MAX_WBITS$2, zswap32$1 = (e) => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((e & 65280) << 8) + ((e & 255) << 24);
function InflateState$1() {
  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const inflateStateCheck$1 = (e) => {
  if (!e)
    return 1;
  const i = e.state;
  return !i || i.strm !== e || i.mode < HEAD$1 || i.mode > SYNC$1 ? 1 : 0;
}, inflateResetKeep$1 = (e) => {
  if (inflateStateCheck$1(e))
    return Z_STREAM_ERROR$1$1;
  const i = e.state;
  return e.total_in = e.total_out = i.total = 0, e.msg = "", i.wrap && (e.adler = i.wrap & 1), i.mode = HEAD$1, i.last = 0, i.havedict = 0, i.flags = -1, i.dmax = 32768, i.head = null, i.hold = 0, i.bits = 0, i.lencode = i.lendyn = new Int32Array(ENOUGH_LENS$2), i.distcode = i.distdyn = new Int32Array(ENOUGH_DISTS$2), i.sane = 1, i.back = -1, Z_OK$1$1;
}, inflateReset$1 = (e) => {
  if (inflateStateCheck$1(e))
    return Z_STREAM_ERROR$1$1;
  const i = e.state;
  return i.wsize = 0, i.whave = 0, i.wnext = 0, inflateResetKeep$1(e);
}, inflateReset2$1 = (e, i) => {
  let t;
  if (inflateStateCheck$1(e))
    return Z_STREAM_ERROR$1$1;
  const r = e.state;
  return i < 0 ? (t = 0, i = -i) : (t = (i >> 4) + 5, i < 48 && (i &= 15)), i && (i < 8 || i > 15) ? Z_STREAM_ERROR$1$1 : (r.window !== null && r.wbits !== i && (r.window = null), r.wrap = t, r.wbits = i, inflateReset$1(e));
}, inflateInit2$1 = (e, i) => {
  if (!e)
    return Z_STREAM_ERROR$1$1;
  const t = new InflateState$1();
  e.state = t, t.strm = e, t.window = null, t.mode = HEAD$1;
  const r = inflateReset2$1(e, i);
  return r !== Z_OK$1$1 && (e.state = null), r;
}, inflateInit$1 = (e) => inflateInit2$1(e, DEF_WBITS$1);
let virgin$1 = !0, lenfix$1, distfix$1;
const fixedtables$1 = (e) => {
  if (virgin$1) {
    lenfix$1 = new Int32Array(512), distfix$1 = new Int32Array(32);
    let i = 0;
    for (; i < 144; )
      e.lens[i++] = 8;
    for (; i < 256; )
      e.lens[i++] = 9;
    for (; i < 280; )
      e.lens[i++] = 7;
    for (; i < 288; )
      e.lens[i++] = 8;
    for (inftrees$2(LENS$2, e.lens, 0, 288, lenfix$1, 0, e.work, { bits: 9 }), i = 0; i < 32; )
      e.lens[i++] = 5;
    inftrees$2(DISTS$2, e.lens, 0, 32, distfix$1, 0, e.work, { bits: 5 }), virgin$1 = !1;
  }
  e.lencode = lenfix$1, e.lenbits = 9, e.distcode = distfix$1, e.distbits = 5;
}, updatewindow$1 = (e, i, t, r) => {
  let n;
  const a = e.state;
  return a.window === null && (a.wsize = 1 << a.wbits, a.wnext = 0, a.whave = 0, a.window = new Uint8Array(a.wsize)), r >= a.wsize ? (a.window.set(i.subarray(t - a.wsize, t), 0), a.wnext = 0, a.whave = a.wsize) : (n = a.wsize - a.wnext, n > r && (n = r), a.window.set(i.subarray(t - r, t - r + n), a.wnext), r -= n, r ? (a.window.set(i.subarray(t - r, t), 0), a.wnext = r, a.whave = a.wsize) : (a.wnext += n, a.wnext === a.wsize && (a.wnext = 0), a.whave < a.wsize && (a.whave += n))), 0;
}, inflate$2$1 = (e, i) => {
  let t, r, n, a, s, o, h, l, f, b, w, g, E, k, A = 0, T, C, D, $, P, z, B, F;
  const O = new Uint8Array(4);
  let N, G;
  const V = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck$1(e) || !e.output || !e.input && e.avail_in !== 0)
    return Z_STREAM_ERROR$1$1;
  t = e.state, t.mode === TYPE$2 && (t.mode = TYPEDO$1), s = e.next_out, n = e.output, h = e.avail_out, a = e.next_in, r = e.input, o = e.avail_in, l = t.hold, f = t.bits, b = o, w = h, F = Z_OK$1$1;
  e:
    for (; ; )
      switch (t.mode) {
        case HEAD$1:
          if (t.wrap === 0) {
            t.mode = TYPEDO$1;
            break;
          }
          for (; f < 16; ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          if (t.wrap & 2 && l === 35615) {
            t.wbits === 0 && (t.wbits = 15), t.check = 0, O[0] = l & 255, O[1] = l >>> 8 & 255, t.check = crc32_1$2(t.check, O, 2, 0), l = 0, f = 0, t.mode = FLAGS$1;
            break;
          }
          if (t.head && (t.head.done = !1), !(t.wrap & 1) || /* check if zlib header allowed */
          (((l & 255) << 8) + (l >> 8)) % 31) {
            e.msg = "incorrect header check", t.mode = BAD$2;
            break;
          }
          if ((l & 15) !== Z_DEFLATED$3) {
            e.msg = "unknown compression method", t.mode = BAD$2;
            break;
          }
          if (l >>>= 4, f -= 4, B = (l & 15) + 8, t.wbits === 0 && (t.wbits = B), B > 15 || B > t.wbits) {
            e.msg = "invalid window size", t.mode = BAD$2;
            break;
          }
          t.dmax = 1 << t.wbits, t.flags = 0, e.adler = t.check = 1, t.mode = l & 512 ? DICTID$1 : TYPE$2, l = 0, f = 0;
          break;
        case FLAGS$1:
          for (; f < 16; ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          if (t.flags = l, (t.flags & 255) !== Z_DEFLATED$3) {
            e.msg = "unknown compression method", t.mode = BAD$2;
            break;
          }
          if (t.flags & 57344) {
            e.msg = "unknown header flags set", t.mode = BAD$2;
            break;
          }
          t.head && (t.head.text = l >> 8 & 1), t.flags & 512 && t.wrap & 4 && (O[0] = l & 255, O[1] = l >>> 8 & 255, t.check = crc32_1$2(t.check, O, 2, 0)), l = 0, f = 0, t.mode = TIME$1;
        /* falls through */
        case TIME$1:
          for (; f < 32; ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          t.head && (t.head.time = l), t.flags & 512 && t.wrap & 4 && (O[0] = l & 255, O[1] = l >>> 8 & 255, O[2] = l >>> 16 & 255, O[3] = l >>> 24 & 255, t.check = crc32_1$2(t.check, O, 4, 0)), l = 0, f = 0, t.mode = OS$1;
        /* falls through */
        case OS$1:
          for (; f < 16; ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          t.head && (t.head.xflags = l & 255, t.head.os = l >> 8), t.flags & 512 && t.wrap & 4 && (O[0] = l & 255, O[1] = l >>> 8 & 255, t.check = crc32_1$2(t.check, O, 2, 0)), l = 0, f = 0, t.mode = EXLEN$1;
        /* falls through */
        case EXLEN$1:
          if (t.flags & 1024) {
            for (; f < 16; ) {
              if (o === 0)
                break e;
              o--, l += r[a++] << f, f += 8;
            }
            t.length = l, t.head && (t.head.extra_len = l), t.flags & 512 && t.wrap & 4 && (O[0] = l & 255, O[1] = l >>> 8 & 255, t.check = crc32_1$2(t.check, O, 2, 0)), l = 0, f = 0;
          } else t.head && (t.head.extra = null);
          t.mode = EXTRA$1;
        /* falls through */
        case EXTRA$1:
          if (t.flags & 1024 && (g = t.length, g > o && (g = o), g && (t.head && (B = t.head.extra_len - t.length, t.head.extra || (t.head.extra = new Uint8Array(t.head.extra_len)), t.head.extra.set(
            r.subarray(
              a,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              a + g
            ),
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            B
          )), t.flags & 512 && t.wrap & 4 && (t.check = crc32_1$2(t.check, r, g, a)), o -= g, a += g, t.length -= g), t.length))
            break e;
          t.length = 0, t.mode = NAME$1;
        /* falls through */
        case NAME$1:
          if (t.flags & 2048) {
            if (o === 0)
              break e;
            g = 0;
            do
              B = r[a + g++], t.head && B && t.length < 65536 && (t.head.name += String.fromCharCode(B));
            while (B && g < o);
            if (t.flags & 512 && t.wrap & 4 && (t.check = crc32_1$2(t.check, r, g, a)), o -= g, a += g, B)
              break e;
          } else t.head && (t.head.name = null);
          t.length = 0, t.mode = COMMENT$1;
        /* falls through */
        case COMMENT$1:
          if (t.flags & 4096) {
            if (o === 0)
              break e;
            g = 0;
            do
              B = r[a + g++], t.head && B && t.length < 65536 && (t.head.comment += String.fromCharCode(B));
            while (B && g < o);
            if (t.flags & 512 && t.wrap & 4 && (t.check = crc32_1$2(t.check, r, g, a)), o -= g, a += g, B)
              break e;
          } else t.head && (t.head.comment = null);
          t.mode = HCRC$1;
        /* falls through */
        case HCRC$1:
          if (t.flags & 512) {
            for (; f < 16; ) {
              if (o === 0)
                break e;
              o--, l += r[a++] << f, f += 8;
            }
            if (t.wrap & 4 && l !== (t.check & 65535)) {
              e.msg = "header crc mismatch", t.mode = BAD$2;
              break;
            }
            l = 0, f = 0;
          }
          t.head && (t.head.hcrc = t.flags >> 9 & 1, t.head.done = !0), e.adler = t.check = 0, t.mode = TYPE$2;
          break;
        case DICTID$1:
          for (; f < 32; ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          e.adler = t.check = zswap32$1(l), l = 0, f = 0, t.mode = DICT$1;
        /* falls through */
        case DICT$1:
          if (t.havedict === 0)
            return e.next_out = s, e.avail_out = h, e.next_in = a, e.avail_in = o, t.hold = l, t.bits = f, Z_NEED_DICT$1$1;
          e.adler = t.check = 1, t.mode = TYPE$2;
        /* falls through */
        case TYPE$2:
          if (i === Z_BLOCK$2 || i === Z_TREES$1)
            break e;
        /* falls through */
        case TYPEDO$1:
          if (t.last) {
            l >>>= f & 7, f -= f & 7, t.mode = CHECK$1;
            break;
          }
          for (; f < 3; ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          switch (t.last = l & 1, l >>>= 1, f -= 1, l & 3) {
            case 0:
              t.mode = STORED$1;
              break;
            case 1:
              if (fixedtables$1(t), t.mode = LEN_$1, i === Z_TREES$1) {
                l >>>= 2, f -= 2;
                break e;
              }
              break;
            case 2:
              t.mode = TABLE$1;
              break;
            case 3:
              e.msg = "invalid block type", t.mode = BAD$2;
          }
          l >>>= 2, f -= 2;
          break;
        case STORED$1:
          for (l >>>= f & 7, f -= f & 7; f < 32; ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          if ((l & 65535) !== (l >>> 16 ^ 65535)) {
            e.msg = "invalid stored block lengths", t.mode = BAD$2;
            break;
          }
          if (t.length = l & 65535, l = 0, f = 0, t.mode = COPY_$1, i === Z_TREES$1)
            break e;
        /* falls through */
        case COPY_$1:
          t.mode = COPY$1;
        /* falls through */
        case COPY$1:
          if (g = t.length, g) {
            if (g > o && (g = o), g > h && (g = h), g === 0)
              break e;
            n.set(r.subarray(a, a + g), s), o -= g, a += g, h -= g, s += g, t.length -= g;
            break;
          }
          t.mode = TYPE$2;
          break;
        case TABLE$1:
          for (; f < 14; ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          if (t.nlen = (l & 31) + 257, l >>>= 5, f -= 5, t.ndist = (l & 31) + 1, l >>>= 5, f -= 5, t.ncode = (l & 15) + 4, l >>>= 4, f -= 4, t.nlen > 286 || t.ndist > 30) {
            e.msg = "too many length or distance symbols", t.mode = BAD$2;
            break;
          }
          t.have = 0, t.mode = LENLENS$1;
        /* falls through */
        case LENLENS$1:
          for (; t.have < t.ncode; ) {
            for (; f < 3; ) {
              if (o === 0)
                break e;
              o--, l += r[a++] << f, f += 8;
            }
            t.lens[V[t.have++]] = l & 7, l >>>= 3, f -= 3;
          }
          for (; t.have < 19; )
            t.lens[V[t.have++]] = 0;
          if (t.lencode = t.lendyn, t.lenbits = 7, N = { bits: t.lenbits }, F = inftrees$2(CODES$2, t.lens, 0, 19, t.lencode, 0, t.work, N), t.lenbits = N.bits, F) {
            e.msg = "invalid code lengths set", t.mode = BAD$2;
            break;
          }
          t.have = 0, t.mode = CODELENS$1;
        /* falls through */
        case CODELENS$1:
          for (; t.have < t.nlen + t.ndist; ) {
            for (; A = t.lencode[l & (1 << t.lenbits) - 1], T = A >>> 24, C = A >>> 16 & 255, D = A & 65535, !(T <= f); ) {
              if (o === 0)
                break e;
              o--, l += r[a++] << f, f += 8;
            }
            if (D < 16)
              l >>>= T, f -= T, t.lens[t.have++] = D;
            else {
              if (D === 16) {
                for (G = T + 2; f < G; ) {
                  if (o === 0)
                    break e;
                  o--, l += r[a++] << f, f += 8;
                }
                if (l >>>= T, f -= T, t.have === 0) {
                  e.msg = "invalid bit length repeat", t.mode = BAD$2;
                  break;
                }
                B = t.lens[t.have - 1], g = 3 + (l & 3), l >>>= 2, f -= 2;
              } else if (D === 17) {
                for (G = T + 3; f < G; ) {
                  if (o === 0)
                    break e;
                  o--, l += r[a++] << f, f += 8;
                }
                l >>>= T, f -= T, B = 0, g = 3 + (l & 7), l >>>= 3, f -= 3;
              } else {
                for (G = T + 7; f < G; ) {
                  if (o === 0)
                    break e;
                  o--, l += r[a++] << f, f += 8;
                }
                l >>>= T, f -= T, B = 0, g = 11 + (l & 127), l >>>= 7, f -= 7;
              }
              if (t.have + g > t.nlen + t.ndist) {
                e.msg = "invalid bit length repeat", t.mode = BAD$2;
                break;
              }
              for (; g--; )
                t.lens[t.have++] = B;
            }
          }
          if (t.mode === BAD$2)
            break;
          if (t.lens[256] === 0) {
            e.msg = "invalid code -- missing end-of-block", t.mode = BAD$2;
            break;
          }
          if (t.lenbits = 9, N = { bits: t.lenbits }, F = inftrees$2(LENS$2, t.lens, 0, t.nlen, t.lencode, 0, t.work, N), t.lenbits = N.bits, F) {
            e.msg = "invalid literal/lengths set", t.mode = BAD$2;
            break;
          }
          if (t.distbits = 6, t.distcode = t.distdyn, N = { bits: t.distbits }, F = inftrees$2(DISTS$2, t.lens, t.nlen, t.ndist, t.distcode, 0, t.work, N), t.distbits = N.bits, F) {
            e.msg = "invalid distances set", t.mode = BAD$2;
            break;
          }
          if (t.mode = LEN_$1, i === Z_TREES$1)
            break e;
        /* falls through */
        case LEN_$1:
          t.mode = LEN$1;
        /* falls through */
        case LEN$1:
          if (o >= 6 && h >= 258) {
            e.next_out = s, e.avail_out = h, e.next_in = a, e.avail_in = o, t.hold = l, t.bits = f, inffast$2(e, w), s = e.next_out, n = e.output, h = e.avail_out, a = e.next_in, r = e.input, o = e.avail_in, l = t.hold, f = t.bits, t.mode === TYPE$2 && (t.back = -1);
            break;
          }
          for (t.back = 0; A = t.lencode[l & (1 << t.lenbits) - 1], T = A >>> 24, C = A >>> 16 & 255, D = A & 65535, !(T <= f); ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          if (C && (C & 240) === 0) {
            for ($ = T, P = C, z = D; A = t.lencode[z + ((l & (1 << $ + P) - 1) >> $)], T = A >>> 24, C = A >>> 16 & 255, D = A & 65535, !($ + T <= f); ) {
              if (o === 0)
                break e;
              o--, l += r[a++] << f, f += 8;
            }
            l >>>= $, f -= $, t.back += $;
          }
          if (l >>>= T, f -= T, t.back += T, t.length = D, C === 0) {
            t.mode = LIT$1;
            break;
          }
          if (C & 32) {
            t.back = -1, t.mode = TYPE$2;
            break;
          }
          if (C & 64) {
            e.msg = "invalid literal/length code", t.mode = BAD$2;
            break;
          }
          t.extra = C & 15, t.mode = LENEXT$1;
        /* falls through */
        case LENEXT$1:
          if (t.extra) {
            for (G = t.extra; f < G; ) {
              if (o === 0)
                break e;
              o--, l += r[a++] << f, f += 8;
            }
            t.length += l & (1 << t.extra) - 1, l >>>= t.extra, f -= t.extra, t.back += t.extra;
          }
          t.was = t.length, t.mode = DIST$1;
        /* falls through */
        case DIST$1:
          for (; A = t.distcode[l & (1 << t.distbits) - 1], T = A >>> 24, C = A >>> 16 & 255, D = A & 65535, !(T <= f); ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          if ((C & 240) === 0) {
            for ($ = T, P = C, z = D; A = t.distcode[z + ((l & (1 << $ + P) - 1) >> $)], T = A >>> 24, C = A >>> 16 & 255, D = A & 65535, !($ + T <= f); ) {
              if (o === 0)
                break e;
              o--, l += r[a++] << f, f += 8;
            }
            l >>>= $, f -= $, t.back += $;
          }
          if (l >>>= T, f -= T, t.back += T, C & 64) {
            e.msg = "invalid distance code", t.mode = BAD$2;
            break;
          }
          t.offset = D, t.extra = C & 15, t.mode = DISTEXT$1;
        /* falls through */
        case DISTEXT$1:
          if (t.extra) {
            for (G = t.extra; f < G; ) {
              if (o === 0)
                break e;
              o--, l += r[a++] << f, f += 8;
            }
            t.offset += l & (1 << t.extra) - 1, l >>>= t.extra, f -= t.extra, t.back += t.extra;
          }
          if (t.offset > t.dmax) {
            e.msg = "invalid distance too far back", t.mode = BAD$2;
            break;
          }
          t.mode = MATCH$1;
        /* falls through */
        case MATCH$1:
          if (h === 0)
            break e;
          if (g = w - h, t.offset > g) {
            if (g = t.offset - g, g > t.whave && t.sane) {
              e.msg = "invalid distance too far back", t.mode = BAD$2;
              break;
            }
            g > t.wnext ? (g -= t.wnext, E = t.wsize - g) : E = t.wnext - g, g > t.length && (g = t.length), k = t.window;
          } else
            k = n, E = s - t.offset, g = t.length;
          g > h && (g = h), h -= g, t.length -= g;
          do
            n[s++] = k[E++];
          while (--g);
          t.length === 0 && (t.mode = LEN$1);
          break;
        case LIT$1:
          if (h === 0)
            break e;
          n[s++] = t.length, h--, t.mode = LEN$1;
          break;
        case CHECK$1:
          if (t.wrap) {
            for (; f < 32; ) {
              if (o === 0)
                break e;
              o--, l |= r[a++] << f, f += 8;
            }
            if (w -= h, e.total_out += w, t.total += w, t.wrap & 4 && w && (e.adler = t.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
            t.flags ? crc32_1$2(t.check, n, w, s - w) : adler32_1$2(t.check, n, w, s - w)), w = h, t.wrap & 4 && (t.flags ? l : zswap32$1(l)) !== t.check) {
              e.msg = "incorrect data check", t.mode = BAD$2;
              break;
            }
            l = 0, f = 0;
          }
          t.mode = LENGTH$1;
        /* falls through */
        case LENGTH$1:
          if (t.wrap && t.flags) {
            for (; f < 32; ) {
              if (o === 0)
                break e;
              o--, l += r[a++] << f, f += 8;
            }
            if (t.wrap & 4 && l !== (t.total & 4294967295)) {
              e.msg = "incorrect length check", t.mode = BAD$2;
              break;
            }
            l = 0, f = 0;
          }
          t.mode = DONE$1;
        /* falls through */
        case DONE$1:
          F = Z_STREAM_END$1$1;
          break e;
        case BAD$2:
          F = Z_DATA_ERROR$1$1;
          break e;
        case MEM$1:
          return Z_MEM_ERROR$1$1;
        case SYNC$1:
        /* falls through */
        default:
          return Z_STREAM_ERROR$1$1;
      }
  return e.next_out = s, e.avail_out = h, e.next_in = a, e.avail_in = o, t.hold = l, t.bits = f, (t.wsize || w !== e.avail_out && t.mode < BAD$2 && (t.mode < CHECK$1 || i !== Z_FINISH$1$1)) && updatewindow$1(e, e.output, e.next_out, w - e.avail_out), b -= e.avail_in, w -= e.avail_out, e.total_in += b, e.total_out += w, t.total += w, t.wrap & 4 && w && (e.adler = t.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
  t.flags ? crc32_1$2(t.check, n, w, e.next_out - w) : adler32_1$2(t.check, n, w, e.next_out - w)), e.data_type = t.bits + (t.last ? 64 : 0) + (t.mode === TYPE$2 ? 128 : 0) + (t.mode === LEN_$1 || t.mode === COPY_$1 ? 256 : 0), (b === 0 && w === 0 || i === Z_FINISH$1$1) && F === Z_OK$1$1 && (F = Z_BUF_ERROR$2), F;
}, inflateEnd$1 = (e) => {
  if (inflateStateCheck$1(e))
    return Z_STREAM_ERROR$1$1;
  let i = e.state;
  return i.window && (i.window = null), e.state = null, Z_OK$1$1;
}, inflateGetHeader$1 = (e, i) => {
  if (inflateStateCheck$1(e))
    return Z_STREAM_ERROR$1$1;
  const t = e.state;
  return (t.wrap & 2) === 0 ? Z_STREAM_ERROR$1$1 : (t.head = i, i.done = !1, Z_OK$1$1);
}, inflateSetDictionary$1 = (e, i) => {
  const t = i.length;
  let r, n, a;
  return inflateStateCheck$1(e) || (r = e.state, r.wrap !== 0 && r.mode !== DICT$1) ? Z_STREAM_ERROR$1$1 : r.mode === DICT$1 && (n = 1, n = adler32_1$2(n, i, t, 0), n !== r.check) ? Z_DATA_ERROR$1$1 : (a = updatewindow$1(e, i, t, t), a ? (r.mode = MEM$1, Z_MEM_ERROR$1$1) : (r.havedict = 1, Z_OK$1$1));
};
var inflateReset_1$1 = inflateReset$1, inflateReset2_1$1 = inflateReset2$1, inflateResetKeep_1$1 = inflateResetKeep$1, inflateInit_1$1 = inflateInit$1, inflateInit2_1$1 = inflateInit2$1, inflate_2$1$1 = inflate$2$1, inflateEnd_1$1 = inflateEnd$1, inflateGetHeader_1$1 = inflateGetHeader$1, inflateSetDictionary_1$1 = inflateSetDictionary$1, inflateInfo$1 = "pako inflate (from Nodeca project)", inflate_1$2$1 = {
  inflateReset: inflateReset_1$1,
  inflateReset2: inflateReset2_1$1,
  inflateResetKeep: inflateResetKeep_1$1,
  inflateInit: inflateInit_1$1,
  inflateInit2: inflateInit2_1$1,
  inflate: inflate_2$1$1,
  inflateEnd: inflateEnd_1$1,
  inflateGetHeader: inflateGetHeader_1$1,
  inflateSetDictionary: inflateSetDictionary_1$1,
  inflateInfo: inflateInfo$1
};
function GZheader$1() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var gzheader$2 = GZheader$1;
const toString$2 = Object.prototype.toString, {
  Z_NO_FLUSH: Z_NO_FLUSH$3,
  Z_FINISH: Z_FINISH$4,
  Z_OK: Z_OK$4,
  Z_STREAM_END: Z_STREAM_END$4,
  Z_NEED_DICT: Z_NEED_DICT$2,
  Z_STREAM_ERROR: Z_STREAM_ERROR$3,
  Z_DATA_ERROR: Z_DATA_ERROR$3,
  Z_MEM_ERROR: Z_MEM_ERROR$2
} = constants$2$1;
function Inflate$1$1(e) {
  this.options = common$2.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, e || {});
  const i = this.options;
  i.raw && i.windowBits >= 0 && i.windowBits < 16 && (i.windowBits = -i.windowBits, i.windowBits === 0 && (i.windowBits = -15)), i.windowBits >= 0 && i.windowBits < 16 && !(e && e.windowBits) && (i.windowBits += 32), i.windowBits > 15 && i.windowBits < 48 && (i.windowBits & 15) === 0 && (i.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new zstream$2(), this.strm.avail_out = 0;
  let t = inflate_1$2$1.inflateInit2(
    this.strm,
    i.windowBits
  );
  if (t !== Z_OK$4)
    throw new Error(messages$2[t]);
  if (this.header = new gzheader$2(), inflate_1$2$1.inflateGetHeader(this.strm, this.header), i.dictionary && (typeof i.dictionary == "string" ? i.dictionary = strings$2.string2buf(i.dictionary) : toString$2.call(i.dictionary) === "[object ArrayBuffer]" && (i.dictionary = new Uint8Array(i.dictionary)), i.raw && (t = inflate_1$2$1.inflateSetDictionary(this.strm, i.dictionary), t !== Z_OK$4)))
    throw new Error(messages$2[t]);
}
Inflate$1$1.prototype.push = function(e, i) {
  const t = this.strm, r = this.options.chunkSize, n = this.options.dictionary;
  let a, s, o;
  if (this.ended) return !1;
  for (i === ~~i ? s = i : s = i === !0 ? Z_FINISH$4 : Z_NO_FLUSH$3, toString$2.call(e) === "[object ArrayBuffer]" ? t.input = new Uint8Array(e) : t.input = e, t.next_in = 0, t.avail_in = t.input.length; ; ) {
    for (t.avail_out === 0 && (t.output = new Uint8Array(r), t.next_out = 0, t.avail_out = r), a = inflate_1$2$1.inflate(t, s), a === Z_NEED_DICT$2 && n && (a = inflate_1$2$1.inflateSetDictionary(t, n), a === Z_OK$4 ? a = inflate_1$2$1.inflate(t, s) : a === Z_DATA_ERROR$3 && (a = Z_NEED_DICT$2)); t.avail_in > 0 && a === Z_STREAM_END$4 && t.state.wrap > 0 && e[t.next_in] !== 0; )
      inflate_1$2$1.inflateReset(t), a = inflate_1$2$1.inflate(t, s);
    switch (a) {
      case Z_STREAM_ERROR$3:
      case Z_DATA_ERROR$3:
      case Z_NEED_DICT$2:
      case Z_MEM_ERROR$2:
        return this.onEnd(a), this.ended = !0, !1;
    }
    if (o = t.avail_out, t.next_out && (t.avail_out === 0 || a === Z_STREAM_END$4))
      if (this.options.to === "string") {
        let h = strings$2.utf8border(t.output, t.next_out), l = t.next_out - h, f = strings$2.buf2string(t.output, h);
        t.next_out = l, t.avail_out = r - l, l && t.output.set(t.output.subarray(h, h + l), 0), this.onData(f);
      } else
        this.onData(t.output.length === t.next_out ? t.output : t.output.subarray(0, t.next_out));
    if (!(a === Z_OK$4 && o === 0)) {
      if (a === Z_STREAM_END$4)
        return a = inflate_1$2$1.inflateEnd(this.strm), this.onEnd(a), this.ended = !0, !0;
      if (t.avail_in === 0) break;
    }
  }
  return !0;
};
Inflate$1$1.prototype.onData = function(e) {
  this.chunks.push(e);
};
Inflate$1$1.prototype.onEnd = function(e) {
  e === Z_OK$4 && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = common$2.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function inflate$1$2(e, i) {
  const t = new Inflate$1$1(i);
  if (t.push(e), t.err) throw t.msg || messages$2[t.err];
  return t.result;
}
var Inflate_1$1 = Inflate$1$1, inflate_2$2 = inflate$1$2, inflate_1$1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2$2
};
const { deflate: deflate$3 } = deflate_1$1, { Inflate, inflate: inflate$4 } = inflate_1$1$1;
var deflate_1 = deflate$3, Inflate_1 = Inflate, inflate_1$3 = inflate$4;
const crcTable$1 = [];
for (let e = 0; e < 256; e++) {
  let i = e;
  for (let t = 0; t < 8; t++)
    i & 1 ? i = 3988292384 ^ i >>> 1 : i = i >>> 1;
  crcTable$1[e] = i;
}
const initialCrc = 4294967295;
function updateCrc(e, i, t) {
  let r = e;
  for (let n = 0; n < t; n++)
    r = crcTable$1[(r ^ i[n]) & 255] ^ r >>> 8;
  return r;
}
function crc(e, i) {
  return (updateCrc(initialCrc, e, i) ^ initialCrc) >>> 0;
}
function checkCrc(e, i, t) {
  const r = e.readUint32(), n = crc(new Uint8Array(e.buffer, e.byteOffset + e.offset - i - 4, i), i);
  if (n !== r)
    throw new Error(`CRC mismatch for chunk ${t}. Expected ${r}, found ${n}`);
}
function writeCrc(e, i) {
  e.writeUint32(crc(new Uint8Array(e.buffer, e.byteOffset + e.offset - i, i), i));
}
function unfilterNone(e, i, t) {
  for (let r = 0; r < t; r++)
    i[r] = e[r];
}
function unfilterSub(e, i, t, r) {
  let n = 0;
  for (; n < r; n++)
    i[n] = e[n];
  for (; n < t; n++)
    i[n] = e[n] + i[n - r] & 255;
}
function unfilterUp(e, i, t, r) {
  let n = 0;
  if (t.length === 0)
    for (; n < r; n++)
      i[n] = e[n];
  else
    for (; n < r; n++)
      i[n] = e[n] + t[n] & 255;
}
function unfilterAverage(e, i, t, r, n) {
  let a = 0;
  if (t.length === 0) {
    for (; a < n; a++)
      i[a] = e[a];
    for (; a < r; a++)
      i[a] = e[a] + (i[a - n] >> 1) & 255;
  } else {
    for (; a < n; a++)
      i[a] = e[a] + (t[a] >> 1) & 255;
    for (; a < r; a++)
      i[a] = e[a] + (i[a - n] + t[a] >> 1) & 255;
  }
}
function unfilterPaeth(e, i, t, r, n) {
  let a = 0;
  if (t.length === 0) {
    for (; a < n; a++)
      i[a] = e[a];
    for (; a < r; a++)
      i[a] = e[a] + i[a - n] & 255;
  } else {
    for (; a < n; a++)
      i[a] = e[a] + t[a] & 255;
    for (; a < r; a++)
      i[a] = e[a] + paethPredictor(i[a - n], t[a], t[a - n]) & 255;
  }
}
function paethPredictor(e, i, t) {
  const r = e + i - t, n = Math.abs(r - e), a = Math.abs(r - i), s = Math.abs(r - t);
  return n <= a && n <= s ? e : a <= s ? i : t;
}
const uint16 = new Uint16Array([255]), uint8 = new Uint8Array(uint16.buffer), osIsLittleEndian = uint8[0] === 255, empty = new Uint8Array(0);
function decodeInterlaceNull(e) {
  const { data: i, width: t, height: r, channels: n, depth: a } = e, s = n * a / 8, o = t * s, h = new Uint8Array(r * o);
  let l = empty, f = 0, b, w;
  for (let g = 0; g < r; g++) {
    switch (b = i.subarray(f + 1, f + 1 + o), w = h.subarray(g * o, (g + 1) * o), i[f]) {
      case 0:
        unfilterNone(b, w, o);
        break;
      case 1:
        unfilterSub(b, w, o, s);
        break;
      case 2:
        unfilterUp(b, w, l, o);
        break;
      case 3:
        unfilterAverage(b, w, l, o, s);
        break;
      case 4:
        unfilterPaeth(b, w, l, o, s);
        break;
      default:
        throw new Error(`Unsupported filter: ${i[f]}`);
    }
    l = w, f += o + 1;
  }
  if (a === 16) {
    const g = new Uint16Array(h.buffer);
    if (osIsLittleEndian)
      for (let E = 0; E < g.length; E++)
        g[E] = swap16(g[E]);
    return g;
  } else
    return h;
}
function swap16(e) {
  return (e & 255) << 8 | e >> 8 & 255;
}
const pngSignature = Uint8Array.of(137, 80, 78, 71, 13, 10, 26, 10);
function writeSignature(e) {
  e.writeBytes(pngSignature);
}
function checkSignature(e) {
  if (!hasPngSignature(e.readBytes(pngSignature.length)))
    throw new Error("wrong PNG signature");
}
function hasPngSignature(e) {
  if (e.length < pngSignature.length)
    return !1;
  for (let i = 0; i < pngSignature.length; i++)
    if (e[i] !== pngSignature[i])
      return !1;
  return !0;
}
const textChunkName = "tEXt", NULL = 0, latin1Decoder = new TextDecoder("latin1");
function validateKeyword(e) {
  if (validateLatin1(e), e.length === 0 || e.length > 79)
    throw new Error("keyword length must be between 1 and 79");
}
const latin1Regex = /^[\u0000-\u00FF]*$/;
function validateLatin1(e) {
  if (!latin1Regex.test(e))
    throw new Error("invalid latin1 text");
}
function decodetEXt(e, i, t) {
  const r = readKeyword(i);
  e[r] = readLatin1(i, t - r.length - 1);
}
function encodetEXt(e, i, t) {
  validateKeyword(i), validateLatin1(t);
  const r = i.length + 1 + t.length;
  e.writeUint32(r), e.writeChars(textChunkName), e.writeChars(i), e.writeByte(NULL), e.writeChars(t), writeCrc(e, r + 4);
}
function readKeyword(e) {
  for (e.mark(); e.readByte() !== NULL; )
    ;
  const i = e.offset;
  e.reset();
  const t = latin1Decoder.decode(e.readBytes(i - e.offset - 1));
  return e.skip(1), validateKeyword(t), t;
}
function readLatin1(e, i) {
  return latin1Decoder.decode(e.readBytes(i));
}
const ColorType = {
  UNKNOWN: -1,
  GREYSCALE: 0,
  TRUECOLOUR: 2,
  INDEXED_COLOUR: 3,
  GREYSCALE_ALPHA: 4,
  TRUECOLOUR_ALPHA: 6
}, CompressionMethod = {
  UNKNOWN: -1,
  DEFLATE: 0
}, FilterMethod = {
  UNKNOWN: -1,
  ADAPTIVE: 0
}, InterlaceMethod = {
  UNKNOWN: -1,
  NO_INTERLACE: 0
};
class PngDecoder extends IOBuffer {
  constructor(t, r = {}) {
    super(t);
    $e(this, "_checkCrc");
    $e(this, "_inflator");
    $e(this, "_png");
    $e(this, "_end");
    $e(this, "_hasPalette");
    $e(this, "_palette");
    $e(this, "_hasTransparency");
    $e(this, "_transparency");
    $e(this, "_compressionMethod");
    $e(this, "_filterMethod");
    $e(this, "_interlaceMethod");
    $e(this, "_colorType");
    const { checkCrc: n = !1 } = r;
    this._checkCrc = n, this._inflator = new Inflate_1(), this._png = {
      width: -1,
      height: -1,
      channels: -1,
      data: new Uint8Array(0),
      depth: 1,
      text: {}
    }, this._end = !1, this._hasPalette = !1, this._palette = [], this._hasTransparency = !1, this._transparency = new Uint16Array(0), this._compressionMethod = CompressionMethod.UNKNOWN, this._filterMethod = FilterMethod.UNKNOWN, this._interlaceMethod = InterlaceMethod.UNKNOWN, this._colorType = ColorType.UNKNOWN, this.setBigEndian();
  }
  decode() {
    for (checkSignature(this); !this._end; )
      this.decodeChunk();
    return this.decodeImage(), this._png;
  }
  // https://www.w3.org/TR/PNG/#5Chunk-layout
  decodeChunk() {
    const t = this.readUint32(), r = this.readChars(4), n = this.offset;
    switch (r) {
      // 11.2 Critical chunks
      case "IHDR":
        this.decodeIHDR();
        break;
      case "PLTE":
        this.decodePLTE(t);
        break;
      case "IDAT":
        this.decodeIDAT(t);
        break;
      case "IEND":
        this._end = !0;
        break;
      // 11.3 Ancillary chunks
      case "tRNS":
        this.decodetRNS(t);
        break;
      case "iCCP":
        this.decodeiCCP(t);
        break;
      case textChunkName:
        decodetEXt(this._png.text, this, t);
        break;
      case "pHYs":
        this.decodepHYs();
        break;
      default:
        this.skip(t);
        break;
    }
    if (this.offset - n !== t)
      throw new Error(`Length mismatch while decoding chunk ${r}`);
    this._checkCrc ? checkCrc(this, t + 4, r) : this.skip(4);
  }
  // https://www.w3.org/TR/PNG/#11IHDR
  decodeIHDR() {
    const t = this._png;
    t.width = this.readUint32(), t.height = this.readUint32(), t.depth = checkBitDepth(this.readUint8());
    const r = this.readUint8();
    this._colorType = r;
    let n;
    switch (r) {
      case ColorType.GREYSCALE:
        n = 1;
        break;
      case ColorType.TRUECOLOUR:
        n = 3;
        break;
      case ColorType.INDEXED_COLOUR:
        n = 1;
        break;
      case ColorType.GREYSCALE_ALPHA:
        n = 2;
        break;
      case ColorType.TRUECOLOUR_ALPHA:
        n = 4;
        break;
      // Kept for exhaustiveness.
      // eslint-disable-next-line unicorn/no-useless-switch-case
      case ColorType.UNKNOWN:
      default:
        throw new Error(`Unknown color type: ${r}`);
    }
    if (this._png.channels = n, this._compressionMethod = this.readUint8(), this._compressionMethod !== CompressionMethod.DEFLATE)
      throw new Error(`Unsupported compression method: ${this._compressionMethod}`);
    this._filterMethod = this.readUint8(), this._interlaceMethod = this.readUint8();
  }
  // https://www.w3.org/TR/PNG/#11PLTE
  decodePLTE(t) {
    if (t % 3 !== 0)
      throw new RangeError(`PLTE field length must be a multiple of 3. Got ${t}`);
    const r = t / 3;
    this._hasPalette = !0;
    const n = [];
    this._palette = n;
    for (let a = 0; a < r; a++)
      n.push([this.readUint8(), this.readUint8(), this.readUint8()]);
  }
  // https://www.w3.org/TR/PNG/#11IDAT
  decodeIDAT(t) {
    this._inflator.push(new Uint8Array(this.buffer, this.offset + this.byteOffset, t)), this.skip(t);
  }
  // https://www.w3.org/TR/PNG/#11tRNS
  decodetRNS(t) {
    switch (this._colorType) {
      case ColorType.GREYSCALE:
      case ColorType.TRUECOLOUR: {
        if (t % 2 !== 0)
          throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${t}`);
        if (t / 2 > this._png.width * this._png.height)
          throw new Error(`tRNS chunk contains more alpha values than there are pixels (${t / 2} vs ${this._png.width * this._png.height})`);
        this._hasTransparency = !0, this._transparency = new Uint16Array(t / 2);
        for (let r = 0; r < t / 2; r++)
          this._transparency[r] = this.readUint16();
        break;
      }
      case ColorType.INDEXED_COLOUR: {
        if (t > this._palette.length)
          throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${t} vs ${this._palette.length})`);
        let r = 0;
        for (; r < t; r++) {
          const n = this.readByte();
          this._palette[r].push(n);
        }
        for (; r < this._palette.length; r++)
          this._palette[r].push(255);
        break;
      }
      // Kept for exhaustiveness.
      /* eslint-disable unicorn/no-useless-switch-case */
      case ColorType.UNKNOWN:
      case ColorType.GREYSCALE_ALPHA:
      case ColorType.TRUECOLOUR_ALPHA:
      default:
        throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);
    }
  }
  // https://www.w3.org/TR/PNG/#11iCCP
  decodeiCCP(t) {
    const r = readKeyword(this), n = this.readUint8();
    if (n !== CompressionMethod.DEFLATE)
      throw new Error(`Unsupported iCCP compression method: ${n}`);
    const a = this.readBytes(t - r.length - 2);
    this._png.iccEmbeddedProfile = {
      name: r,
      profile: inflate_1$3(a)
    };
  }
  // https://www.w3.org/TR/PNG/#11pHYs
  decodepHYs() {
    const t = this.readUint32(), r = this.readUint32(), n = this.readByte();
    this._png.resolution = { x: t, y: r, unit: n };
  }
  decodeImage() {
    if (this._inflator.err)
      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
    const t = this._inflator.result;
    if (this._filterMethod !== FilterMethod.ADAPTIVE)
      throw new Error(`Filter method ${this._filterMethod} not supported`);
    if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE)
      this._png.data = decodeInterlaceNull({
        data: t,
        width: this._png.width,
        height: this._png.height,
        channels: this._png.channels,
        depth: this._png.depth
      });
    else
      throw new Error(`Interlace method ${this._interlaceMethod} not supported`);
    this._hasPalette && (this._png.palette = this._palette), this._hasTransparency && (this._png.transparency = this._transparency);
  }
}
function checkBitDepth(e) {
  if (e !== 1 && e !== 2 && e !== 4 && e !== 8 && e !== 16)
    throw new Error(`invalid bit depth: ${e}`);
  return e;
}
const defaultZlibOptions = {
  level: 3
};
class PngEncoder extends IOBuffer {
  constructor(t, r = {}) {
    super();
    $e(this, "_png");
    $e(this, "_zlibOptions");
    $e(this, "_colorType");
    this._colorType = ColorType.UNKNOWN, this._zlibOptions = { ...defaultZlibOptions, ...r.zlib }, this._png = this._checkData(t), this.setBigEndian();
  }
  encode() {
    if (writeSignature(this), this.encodeIHDR(), this.encodeData(), this._png.text)
      for (const [t, r] of Object.entries(this._png.text))
        encodetEXt(this, t, r);
    return this.encodeIEND(), this.toArray();
  }
  // https://www.w3.org/TR/PNG/#11IHDR
  encodeIHDR() {
    this.writeUint32(13), this.writeChars("IHDR"), this.writeUint32(this._png.width), this.writeUint32(this._png.height), this.writeByte(this._png.depth), this.writeByte(this._colorType), this.writeByte(CompressionMethod.DEFLATE), this.writeByte(FilterMethod.ADAPTIVE), this.writeByte(InterlaceMethod.NO_INTERLACE), writeCrc(this, 17);
  }
  // https://www.w3.org/TR/PNG/#11IEND
  encodeIEND() {
    this.writeUint32(0), this.writeChars("IEND"), writeCrc(this, 4);
  }
  // https://www.w3.org/TR/PNG/#11IDAT
  encodeIDAT(t) {
    this.writeUint32(t.length), this.writeChars("IDAT"), this.writeBytes(t), writeCrc(this, t.length + 4);
  }
  encodeData() {
    const { width: t, height: r, channels: n, depth: a, data: s } = this._png, o = n * t, h = new IOBuffer().setBigEndian();
    let l = 0;
    for (let w = 0; w < r; w++)
      if (h.writeByte(0), a === 8)
        l = writeDataBytes(s, h, o, l);
      else if (a === 16)
        l = writeDataUint16(s, h, o, l);
      else
        throw new Error("unreachable");
    const f = h.toArray(), b = deflate_1(f, this._zlibOptions);
    this.encodeIDAT(b);
  }
  _checkData(t) {
    const { colorType: r, channels: n, depth: a } = getColorType(t), s = {
      width: checkInteger(t.width, "width"),
      height: checkInteger(t.height, "height"),
      channels: n,
      data: t.data,
      depth: a,
      text: t.text
    };
    this._colorType = r;
    const o = s.width * s.height * n;
    if (s.data.length !== o)
      throw new RangeError(`wrong data size. Found ${s.data.length}, expected ${o}`);
    return s;
  }
}
function checkInteger(e, i) {
  if (Number.isInteger(e) && e > 0)
    return e;
  throw new TypeError(`${i} must be a positive integer`);
}
function getColorType(e) {
  const { channels: i = 4, depth: t = 8 } = e;
  if (i !== 4 && i !== 3 && i !== 2 && i !== 1)
    throw new RangeError(`unsupported number of channels: ${i}`);
  if (t !== 8 && t !== 16)
    throw new RangeError(`unsupported bit depth: ${t}`);
  const r = {
    channels: i,
    depth: t,
    colorType: ColorType.UNKNOWN
  };
  switch (i) {
    case 4:
      r.colorType = ColorType.TRUECOLOUR_ALPHA;
      break;
    case 3:
      r.colorType = ColorType.TRUECOLOUR;
      break;
    case 1:
      r.colorType = ColorType.GREYSCALE;
      break;
    case 2:
      r.colorType = ColorType.GREYSCALE_ALPHA;
      break;
    default:
      throw new Error("unsupported number of channels");
  }
  return r;
}
function writeDataBytes(e, i, t, r) {
  for (let n = 0; n < t; n++)
    i.writeByte(e[r++]);
  return r;
}
function writeDataUint16(e, i, t, r) {
  for (let n = 0; n < t; n++)
    i.writeUint16(e[r++]);
  return r;
}
var ResolutionUnitSpecifier;
(function(e) {
  e[e.UNKNOWN = 0] = "UNKNOWN", e[e.METRE = 1] = "METRE";
})(ResolutionUnitSpecifier || (ResolutionUnitSpecifier = {}));
function decodePng(e, i) {
  return new PngDecoder(e, i).decode();
}
function encodePng$1(e, i) {
  return new PngEncoder(e, i).encode();
}
var encoder = { exports: {} }, hasRequiredEncoder;
function requireEncoder() {
  return hasRequiredEncoder || (hasRequiredEncoder = 1, function(e) {
    function i(r) {
      var n = Math.floor, a = new Array(64), s = new Array(64), o = new Array(64), h = new Array(64), l, f, b, w, g = new Array(65535), E = new Array(65535), k = new Array(64), A = new Array(64), T = [], C = 0, D = 7, $ = new Array(64), P = new Array(64), z = new Array(64), B = new Array(256), F = new Array(2048), O, N = [
        0,
        1,
        5,
        6,
        14,
        15,
        27,
        28,
        2,
        4,
        7,
        13,
        16,
        26,
        29,
        42,
        3,
        8,
        12,
        17,
        25,
        30,
        41,
        43,
        9,
        11,
        18,
        24,
        31,
        40,
        44,
        53,
        10,
        19,
        23,
        32,
        39,
        45,
        52,
        54,
        20,
        22,
        33,
        38,
        46,
        51,
        55,
        60,
        21,
        34,
        37,
        47,
        50,
        56,
        59,
        61,
        35,
        36,
        48,
        49,
        57,
        58,
        62,
        63
      ], G = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], V = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], J = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], Q = [
        1,
        2,
        3,
        0,
        4,
        17,
        5,
        18,
        33,
        49,
        65,
        6,
        19,
        81,
        97,
        7,
        34,
        113,
        20,
        50,
        129,
        145,
        161,
        8,
        35,
        66,
        177,
        193,
        21,
        82,
        209,
        240,
        36,
        51,
        98,
        114,
        130,
        9,
        10,
        22,
        23,
        24,
        25,
        26,
        37,
        38,
        39,
        40,
        41,
        42,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ], W = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], ne = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], pe = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], be = [
        0,
        1,
        2,
        3,
        17,
        4,
        5,
        33,
        49,
        6,
        18,
        65,
        81,
        7,
        97,
        113,
        19,
        34,
        50,
        129,
        8,
        20,
        66,
        145,
        161,
        177,
        193,
        9,
        35,
        51,
        82,
        240,
        21,
        98,
        114,
        209,
        10,
        22,
        36,
        52,
        225,
        37,
        241,
        23,
        24,
        25,
        26,
        38,
        39,
        40,
        41,
        42,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      function ve(he) {
        for (var Qe = [
          16,
          11,
          10,
          16,
          24,
          40,
          51,
          61,
          12,
          12,
          14,
          19,
          26,
          58,
          60,
          55,
          14,
          13,
          16,
          24,
          40,
          57,
          69,
          56,
          14,
          17,
          22,
          29,
          51,
          87,
          80,
          62,
          18,
          22,
          37,
          56,
          68,
          109,
          103,
          77,
          24,
          35,
          55,
          64,
          81,
          104,
          113,
          92,
          49,
          64,
          78,
          87,
          103,
          121,
          120,
          101,
          72,
          92,
          95,
          98,
          112,
          100,
          103,
          99
        ], Ze = 0; Ze < 64; Ze++) {
          var He = n((Qe[Ze] * he + 50) / 100);
          He < 1 ? He = 1 : He > 255 && (He = 255), a[N[Ze]] = He;
        }
        for (var De = [
          17,
          18,
          24,
          47,
          99,
          99,
          99,
          99,
          18,
          21,
          26,
          66,
          99,
          99,
          99,
          99,
          24,
          26,
          56,
          99,
          99,
          99,
          99,
          99,
          47,
          66,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99
        ], lt = 0; lt < 64; lt++) {
          var ot = n((De[lt] * he + 50) / 100);
          ot < 1 ? ot = 1 : ot > 255 && (ot = 255), s[N[lt]] = ot;
        }
        for (var Le = [
          1,
          1.387039845,
          1.306562965,
          1.175875602,
          1,
          0.785694958,
          0.5411961,
          0.275899379
        ], ze = 0, je = 0; je < 8; je++)
          for (var Oe = 0; Oe < 8; Oe++)
            o[ze] = 1 / (a[N[ze]] * Le[je] * Le[Oe] * 8), h[ze] = 1 / (s[N[ze]] * Le[je] * Le[Oe] * 8), ze++;
      }
      function Ee(he, Qe) {
        for (var Ze = 0, He = 0, De = new Array(), lt = 1; lt <= 16; lt++) {
          for (var ot = 1; ot <= he[lt]; ot++)
            De[Qe[He]] = [], De[Qe[He]][0] = Ze, De[Qe[He]][1] = lt, He++, Ze++;
          Ze *= 2;
        }
        return De;
      }
      function Ae() {
        l = Ee(G, V), f = Ee(W, ne), b = Ee(J, Q), w = Ee(pe, be);
      }
      function _e() {
        for (var he = 1, Qe = 2, Ze = 1; Ze <= 15; Ze++) {
          for (var He = he; He < Qe; He++)
            E[32767 + He] = Ze, g[32767 + He] = [], g[32767 + He][1] = Ze, g[32767 + He][0] = He;
          for (var De = -(Qe - 1); De <= -he; De++)
            E[32767 + De] = Ze, g[32767 + De] = [], g[32767 + De][1] = Ze, g[32767 + De][0] = Qe - 1 + De;
          he <<= 1, Qe <<= 1;
        }
      }
      function Be() {
        for (var he = 0; he < 256; he++)
          F[he] = 19595 * he, F[he + 256 >> 0] = 38470 * he, F[he + 512 >> 0] = 7471 * he + 32768, F[he + 768 >> 0] = -11059 * he, F[he + 1024 >> 0] = -21709 * he, F[he + 1280 >> 0] = 32768 * he + 8421375, F[he + 1536 >> 0] = -27439 * he, F[he + 1792 >> 0] = -5329 * he;
      }
      function Me(he) {
        for (var Qe = he[0], Ze = he[1] - 1; Ze >= 0; )
          Qe & 1 << Ze && (C |= 1 << D), Ze--, D--, D < 0 && (C == 255 ? (re(255), re(0)) : re(C), D = 7, C = 0);
      }
      function re(he) {
        T.push(he);
      }
      function Te(he) {
        re(he >> 8 & 255), re(he & 255);
      }
      function Fe(he, Qe) {
        var Ze, He, De, lt, ot, Le, ze, je, Oe = 0, st, Z = 8, ue = 64;
        for (st = 0; st < Z; ++st) {
          Ze = he[Oe], He = he[Oe + 1], De = he[Oe + 2], lt = he[Oe + 3], ot = he[Oe + 4], Le = he[Oe + 5], ze = he[Oe + 6], je = he[Oe + 7];
          var xe = Ze + je, ke = Ze - je, te = He + ze, me = He - ze, U = De + Le, ye = De - Le, it = lt + ot, I = lt - ot, fe = xe + it, de = xe - it, H = te + U, ee = te - U;
          he[Oe] = fe + H, he[Oe + 4] = fe - H;
          var oe = (ee + de) * 0.707106781;
          he[Oe + 2] = de + oe, he[Oe + 6] = de - oe, fe = I + ye, H = ye + me, ee = me + ke;
          var We = (fe - ee) * 0.382683433, M = 0.5411961 * fe + We, _ = 1.306562965 * ee + We, d = H * 0.707106781, u = ke + d, v = ke - d;
          he[Oe + 5] = v + M, he[Oe + 3] = v - M, he[Oe + 1] = u + _, he[Oe + 7] = u - _, Oe += 8;
        }
        for (Oe = 0, st = 0; st < Z; ++st) {
          Ze = he[Oe], He = he[Oe + 8], De = he[Oe + 16], lt = he[Oe + 24], ot = he[Oe + 32], Le = he[Oe + 40], ze = he[Oe + 48], je = he[Oe + 56];
          var S = Ze + je, L = Ze - je, q = He + ze, X = He - ze, j = De + Le, ae = De - Le, K = lt + ot, ce = lt - ot, we = S + K, le = S - K, ge = q + j, Ue = q - j;
          he[Oe] = we + ge, he[Oe + 32] = we - ge;
          var ie = (Ue + le) * 0.707106781;
          he[Oe + 16] = le + ie, he[Oe + 48] = le - ie, we = ce + ae, ge = ae + X, Ue = X + L;
          var Ce = (we - Ue) * 0.382683433, Xe = 0.5411961 * we + Ce, ht = 1.306562965 * Ue + Ce, ft = ge * 0.707106781, dt = L + ft, rt = L - ft;
          he[Oe + 40] = rt + Xe, he[Oe + 24] = rt - Xe, he[Oe + 8] = dt + ht, he[Oe + 56] = dt - ht, Oe++;
        }
        var at;
        for (st = 0; st < ue; ++st)
          at = he[st] * Qe[st], k[st] = at > 0 ? at + 0.5 | 0 : at - 0.5 | 0;
        return k;
      }
      function Se() {
        Te(65504), Te(16), re(74), re(70), re(73), re(70), re(0), re(1), re(1), re(0), Te(1), Te(1), re(0), re(0);
      }
      function Ye(he) {
        if (he) {
          Te(65505), he[0] === 69 && he[1] === 120 && he[2] === 105 && he[3] === 102 ? Te(he.length + 2) : (Te(he.length + 5 + 2), re(69), re(120), re(105), re(102), re(0));
          for (var Qe = 0; Qe < he.length; Qe++)
            re(he[Qe]);
        }
      }
      function Je(he, Qe) {
        Te(65472), Te(17), re(8), Te(Qe), Te(he), re(3), re(1), re(17), re(0), re(2), re(17), re(1), re(3), re(17), re(1);
      }
      function et() {
        Te(65499), Te(132), re(0);
        for (var he = 0; he < 64; he++)
          re(a[he]);
        re(1);
        for (var Qe = 0; Qe < 64; Qe++)
          re(s[Qe]);
      }
      function Ve() {
        Te(65476), Te(418), re(0);
        for (var he = 0; he < 16; he++)
          re(G[he + 1]);
        for (var Qe = 0; Qe <= 11; Qe++)
          re(V[Qe]);
        re(16);
        for (var Ze = 0; Ze < 16; Ze++)
          re(J[Ze + 1]);
        for (var He = 0; He <= 161; He++)
          re(Q[He]);
        re(1);
        for (var De = 0; De < 16; De++)
          re(W[De + 1]);
        for (var lt = 0; lt <= 11; lt++)
          re(ne[lt]);
        re(17);
        for (var ot = 0; ot < 16; ot++)
          re(pe[ot + 1]);
        for (var Le = 0; Le <= 161; Le++)
          re(be[Le]);
      }
      function tt(he) {
        typeof he > "u" || he.constructor !== Array || he.forEach((Qe) => {
          if (typeof Qe == "string") {
            Te(65534);
            var Ze = Qe.length;
            Te(Ze + 2);
            var He;
            for (He = 0; He < Ze; He++)
              re(Qe.charCodeAt(He));
          }
        });
      }
      function qe() {
        Te(65498), Te(12), re(3), re(1), re(0), re(2), re(17), re(3), re(17), re(0), re(63), re(0);
      }
      function Re(he, Qe, Ze, He, De) {
        for (var lt = De[0], ot = De[240], Le, ze = 16, je = 63, Oe = 64, st = Fe(he, Qe), Z = 0; Z < Oe; ++Z)
          A[N[Z]] = st[Z];
        var ue = A[0] - Ze;
        Ze = A[0], ue == 0 ? Me(He[0]) : (Le = 32767 + ue, Me(He[E[Le]]), Me(g[Le]));
        for (var xe = 63; xe > 0 && A[xe] == 0; xe--)
          ;
        if (xe == 0)
          return Me(lt), Ze;
        for (var ke = 1, te; ke <= xe; ) {
          for (var me = ke; A[ke] == 0 && ke <= xe; ++ke)
            ;
          var U = ke - me;
          if (U >= ze) {
            te = U >> 4;
            for (var ye = 1; ye <= te; ++ye)
              Me(ot);
            U = U & 15;
          }
          Le = 32767 + A[ke], Me(De[(U << 4) + E[Le]]), Me(g[Le]), ke++;
        }
        return xe != je && Me(lt), Ze;
      }
      function nt() {
        for (var he = String.fromCharCode, Qe = 0; Qe < 256; Qe++)
          B[Qe] = he(Qe);
      }
      this.encode = function(he, Qe) {
        (/* @__PURE__ */ new Date()).getTime(), Qe && Ge(Qe), T = new Array(), C = 0, D = 7, Te(65496), Se(), tt(he.comments), Ye(he.exifBuffer), et(), Je(he.width, he.height), Ve(), qe();
        var Ze = 0, He = 0, De = 0;
        C = 0, D = 7, this.encode.displayName = "_encode_";
        for (var lt = he.data, ot = he.width, Le = he.height, ze = ot * 4, je, Oe = 0, st, Z, ue, xe, ke, te, me, U; Oe < Le; ) {
          for (je = 0; je < ze; ) {
            for (xe = ze * Oe + je, ke = xe, te = -1, me = 0, U = 0; U < 64; U++)
              me = U >> 3, te = (U & 7) * 4, ke = xe + me * ze + te, Oe + me >= Le && (ke -= ze * (Oe + 1 + me - Le)), je + te >= ze && (ke -= je + te - ze + 4), st = lt[ke++], Z = lt[ke++], ue = lt[ke++], $[U] = (F[st] + F[Z + 256 >> 0] + F[ue + 512 >> 0] >> 16) - 128, P[U] = (F[st + 768 >> 0] + F[Z + 1024 >> 0] + F[ue + 1280 >> 0] >> 16) - 128, z[U] = (F[st + 1280 >> 0] + F[Z + 1536 >> 0] + F[ue + 1792 >> 0] >> 16) - 128;
            Ze = Re($, o, Ze, l, b), He = Re(P, h, He, f, w), De = Re(z, h, De, f, w), je += 32;
          }
          Oe += 8;
        }
        if (D >= 0) {
          var ye = [];
          ye[1] = D + 1, ye[0] = (1 << D + 1) - 1, Me(ye);
        }
        return Te(65497), Buffer.from(T);
      };
      function Ge(he) {
        if (he <= 0 && (he = 1), he > 100 && (he = 100), O != he) {
          var Qe = 0;
          he < 50 ? Qe = Math.floor(5e3 / he) : Qe = Math.floor(200 - he * 2), ve(Qe), O = he;
        }
      }
      function Ne() {
        var he = (/* @__PURE__ */ new Date()).getTime();
        r || (r = 50), nt(), Ae(), _e(), Be(), Ge(r), (/* @__PURE__ */ new Date()).getTime() - he;
      }
      Ne();
    }
    e.exports = t;
    function t(r, n) {
      typeof n > "u" && (n = 50);
      var a = new i(n), s = a.encode(r, n);
      return {
        data: s,
        width: r.width,
        height: r.height
      };
    }
  }(encoder)), encoder.exports;
}
var decoder = { exports: {} }, hasRequiredDecoder;
function requireDecoder() {
  return hasRequiredDecoder || (hasRequiredDecoder = 1, function(e) {
    var i = function() {
      var n = new Int32Array([
        0,
        1,
        8,
        16,
        9,
        2,
        3,
        10,
        17,
        24,
        32,
        25,
        18,
        11,
        4,
        5,
        12,
        19,
        26,
        33,
        40,
        48,
        41,
        34,
        27,
        20,
        13,
        6,
        7,
        14,
        21,
        28,
        35,
        42,
        49,
        56,
        57,
        50,
        43,
        36,
        29,
        22,
        15,
        23,
        30,
        37,
        44,
        51,
        58,
        59,
        52,
        45,
        38,
        31,
        39,
        46,
        53,
        60,
        61,
        54,
        47,
        55,
        62,
        63
      ]), a = 4017, s = 799, o = 3406, h = 2276, l = 1567, f = 3784, b = 5793, w = 2896;
      function g() {
      }
      function E(P, z) {
        for (var B = 0, F = [], O, N, G = 16; G > 0 && !P[G - 1]; )
          G--;
        F.push({ children: [], index: 0 });
        var V = F[0], J;
        for (O = 0; O < G; O++) {
          for (N = 0; N < P[O]; N++) {
            for (V = F.pop(), V.children[V.index] = z[B]; V.index > 0; ) {
              if (F.length === 0)
                throw new Error("Could not recreate Huffman Table");
              V = F.pop();
            }
            for (V.index++, F.push(V); F.length <= O; )
              F.push(J = { children: [], index: 0 }), V.children[V.index] = J.children, V = J;
            B++;
          }
          O + 1 < G && (F.push(J = { children: [], index: 0 }), V.children[V.index] = J.children, V = J);
        }
        return F[0].children;
      }
      function k(P, z, B, F, O, N, G, V, J, Q) {
        B.precision, B.samplesPerLine, B.scanLines;
        var W = B.mcusPerLine, ne = B.progressive;
        B.maxH, B.maxV;
        var pe = z, be = 0, ve = 0;
        function Ee() {
          if (ve > 0)
            return ve--, be >> ve & 1;
          if (be = P[z++], be == 255) {
            var Le = P[z++];
            if (Le)
              throw new Error("unexpected marker: " + (be << 8 | Le).toString(16));
          }
          return ve = 7, be >>> 7;
        }
        function Ae(Le) {
          for (var ze = Le, je; (je = Ee()) !== null; ) {
            if (ze = ze[je], typeof ze == "number")
              return ze;
            if (typeof ze != "object")
              throw new Error("invalid huffman sequence");
          }
          return null;
        }
        function _e(Le) {
          for (var ze = 0; Le > 0; ) {
            var je = Ee();
            if (je === null) return;
            ze = ze << 1 | je, Le--;
          }
          return ze;
        }
        function Be(Le) {
          var ze = _e(Le);
          return ze >= 1 << Le - 1 ? ze : ze + (-1 << Le) + 1;
        }
        function Me(Le, ze) {
          var je = Ae(Le.huffmanTableDC), Oe = je === 0 ? 0 : Be(je);
          ze[0] = Le.pred += Oe;
          for (var st = 1; st < 64; ) {
            var Z = Ae(Le.huffmanTableAC), ue = Z & 15, xe = Z >> 4;
            if (ue === 0) {
              if (xe < 15)
                break;
              st += 16;
              continue;
            }
            st += xe;
            var ke = n[st];
            ze[ke] = Be(ue), st++;
          }
        }
        function re(Le, ze) {
          var je = Ae(Le.huffmanTableDC), Oe = je === 0 ? 0 : Be(je) << J;
          ze[0] = Le.pred += Oe;
        }
        function Te(Le, ze) {
          ze[0] |= Ee() << J;
        }
        var Fe = 0;
        function Se(Le, ze) {
          if (Fe > 0) {
            Fe--;
            return;
          }
          for (var je = N, Oe = G; je <= Oe; ) {
            var st = Ae(Le.huffmanTableAC), Z = st & 15, ue = st >> 4;
            if (Z === 0) {
              if (ue < 15) {
                Fe = _e(ue) + (1 << ue) - 1;
                break;
              }
              je += 16;
              continue;
            }
            je += ue;
            var xe = n[je];
            ze[xe] = Be(Z) * (1 << J), je++;
          }
        }
        var Ye = 0, Je;
        function et(Le, ze) {
          for (var je = N, Oe = G, st = 0; je <= Oe; ) {
            var Z = n[je], ue = ze[Z] < 0 ? -1 : 1;
            switch (Ye) {
              case 0:
                var xe = Ae(Le.huffmanTableAC), ke = xe & 15, st = xe >> 4;
                if (ke === 0)
                  st < 15 ? (Fe = _e(st) + (1 << st), Ye = 4) : (st = 16, Ye = 1);
                else {
                  if (ke !== 1)
                    throw new Error("invalid ACn encoding");
                  Je = Be(ke), Ye = st ? 2 : 3;
                }
                continue;
              case 1:
              // skipping r zero items
              case 2:
                ze[Z] ? ze[Z] += (Ee() << J) * ue : (st--, st === 0 && (Ye = Ye == 2 ? 3 : 0));
                break;
              case 3:
                ze[Z] ? ze[Z] += (Ee() << J) * ue : (ze[Z] = Je << J, Ye = 0);
                break;
              case 4:
                ze[Z] && (ze[Z] += (Ee() << J) * ue);
                break;
            }
            je++;
          }
          Ye === 4 && (Fe--, Fe === 0 && (Ye = 0));
        }
        function Ve(Le, ze, je, Oe, st) {
          var Z = je / W | 0, ue = je % W, xe = Z * Le.v + Oe, ke = ue * Le.h + st;
          Le.blocks[xe] === void 0 && Q.tolerantDecoding || ze(Le, Le.blocks[xe][ke]);
        }
        function tt(Le, ze, je) {
          var Oe = je / Le.blocksPerLine | 0, st = je % Le.blocksPerLine;
          Le.blocks[Oe] === void 0 && Q.tolerantDecoding || ze(Le, Le.blocks[Oe][st]);
        }
        var qe = F.length, Re, nt, Ge, Ne, he, Qe;
        ne ? N === 0 ? Qe = V === 0 ? re : Te : Qe = V === 0 ? Se : et : Qe = Me;
        var Ze = 0, He, De;
        qe == 1 ? De = F[0].blocksPerLine * F[0].blocksPerColumn : De = W * B.mcusPerColumn, O || (O = De);
        for (var lt, ot; Ze < De; ) {
          for (nt = 0; nt < qe; nt++)
            F[nt].pred = 0;
          if (Fe = 0, qe == 1)
            for (Re = F[0], he = 0; he < O; he++)
              tt(Re, Qe, Ze), Ze++;
          else
            for (he = 0; he < O; he++) {
              for (nt = 0; nt < qe; nt++)
                for (Re = F[nt], lt = Re.h, ot = Re.v, Ge = 0; Ge < ot; Ge++)
                  for (Ne = 0; Ne < lt; Ne++)
                    Ve(Re, Qe, Ze, Ge, Ne);
              if (Ze++, Ze === De) break;
            }
          if (Ze === De)
            do {
              if (P[z] === 255 && P[z + 1] !== 0)
                break;
              z += 1;
            } while (z < P.length - 2);
          if (ve = 0, He = P[z] << 8 | P[z + 1], He < 65280)
            throw new Error("marker was not found");
          if (He >= 65488 && He <= 65495)
            z += 2;
          else
            break;
        }
        return z - pe;
      }
      function A(P, z) {
        var B = [], F = z.blocksPerLine, O = z.blocksPerColumn, N = F << 3, G = new Int32Array(64), V = new Uint8Array(64);
        function J(_e, Be, Me) {
          var re = z.quantizationTable, Te, Fe, Se, Ye, Je, et, Ve, tt, qe, Re = Me, nt;
          for (nt = 0; nt < 64; nt++)
            Re[nt] = _e[nt] * re[nt];
          for (nt = 0; nt < 8; ++nt) {
            var Ge = 8 * nt;
            if (Re[1 + Ge] == 0 && Re[2 + Ge] == 0 && Re[3 + Ge] == 0 && Re[4 + Ge] == 0 && Re[5 + Ge] == 0 && Re[6 + Ge] == 0 && Re[7 + Ge] == 0) {
              qe = b * Re[0 + Ge] + 512 >> 10, Re[0 + Ge] = qe, Re[1 + Ge] = qe, Re[2 + Ge] = qe, Re[3 + Ge] = qe, Re[4 + Ge] = qe, Re[5 + Ge] = qe, Re[6 + Ge] = qe, Re[7 + Ge] = qe;
              continue;
            }
            Te = b * Re[0 + Ge] + 128 >> 8, Fe = b * Re[4 + Ge] + 128 >> 8, Se = Re[2 + Ge], Ye = Re[6 + Ge], Je = w * (Re[1 + Ge] - Re[7 + Ge]) + 128 >> 8, tt = w * (Re[1 + Ge] + Re[7 + Ge]) + 128 >> 8, et = Re[3 + Ge] << 4, Ve = Re[5 + Ge] << 4, qe = Te - Fe + 1 >> 1, Te = Te + Fe + 1 >> 1, Fe = qe, qe = Se * f + Ye * l + 128 >> 8, Se = Se * l - Ye * f + 128 >> 8, Ye = qe, qe = Je - Ve + 1 >> 1, Je = Je + Ve + 1 >> 1, Ve = qe, qe = tt + et + 1 >> 1, et = tt - et + 1 >> 1, tt = qe, qe = Te - Ye + 1 >> 1, Te = Te + Ye + 1 >> 1, Ye = qe, qe = Fe - Se + 1 >> 1, Fe = Fe + Se + 1 >> 1, Se = qe, qe = Je * h + tt * o + 2048 >> 12, Je = Je * o - tt * h + 2048 >> 12, tt = qe, qe = et * s + Ve * a + 2048 >> 12, et = et * a - Ve * s + 2048 >> 12, Ve = qe, Re[0 + Ge] = Te + tt, Re[7 + Ge] = Te - tt, Re[1 + Ge] = Fe + Ve, Re[6 + Ge] = Fe - Ve, Re[2 + Ge] = Se + et, Re[5 + Ge] = Se - et, Re[3 + Ge] = Ye + Je, Re[4 + Ge] = Ye - Je;
          }
          for (nt = 0; nt < 8; ++nt) {
            var Ne = nt;
            if (Re[8 + Ne] == 0 && Re[16 + Ne] == 0 && Re[24 + Ne] == 0 && Re[32 + Ne] == 0 && Re[40 + Ne] == 0 && Re[48 + Ne] == 0 && Re[56 + Ne] == 0) {
              qe = b * Me[nt + 0] + 8192 >> 14, Re[0 + Ne] = qe, Re[8 + Ne] = qe, Re[16 + Ne] = qe, Re[24 + Ne] = qe, Re[32 + Ne] = qe, Re[40 + Ne] = qe, Re[48 + Ne] = qe, Re[56 + Ne] = qe;
              continue;
            }
            Te = b * Re[0 + Ne] + 2048 >> 12, Fe = b * Re[32 + Ne] + 2048 >> 12, Se = Re[16 + Ne], Ye = Re[48 + Ne], Je = w * (Re[8 + Ne] - Re[56 + Ne]) + 2048 >> 12, tt = w * (Re[8 + Ne] + Re[56 + Ne]) + 2048 >> 12, et = Re[24 + Ne], Ve = Re[40 + Ne], qe = Te - Fe + 1 >> 1, Te = Te + Fe + 1 >> 1, Fe = qe, qe = Se * f + Ye * l + 2048 >> 12, Se = Se * l - Ye * f + 2048 >> 12, Ye = qe, qe = Je - Ve + 1 >> 1, Je = Je + Ve + 1 >> 1, Ve = qe, qe = tt + et + 1 >> 1, et = tt - et + 1 >> 1, tt = qe, qe = Te - Ye + 1 >> 1, Te = Te + Ye + 1 >> 1, Ye = qe, qe = Fe - Se + 1 >> 1, Fe = Fe + Se + 1 >> 1, Se = qe, qe = Je * h + tt * o + 2048 >> 12, Je = Je * o - tt * h + 2048 >> 12, tt = qe, qe = et * s + Ve * a + 2048 >> 12, et = et * a - Ve * s + 2048 >> 12, Ve = qe, Re[0 + Ne] = Te + tt, Re[56 + Ne] = Te - tt, Re[8 + Ne] = Fe + Ve, Re[48 + Ne] = Fe - Ve, Re[16 + Ne] = Se + et, Re[40 + Ne] = Se - et, Re[24 + Ne] = Ye + Je, Re[32 + Ne] = Ye - Je;
          }
          for (nt = 0; nt < 64; ++nt) {
            var he = 128 + (Re[nt] + 8 >> 4);
            Be[nt] = he < 0 ? 0 : he > 255 ? 255 : he;
          }
        }
        $(N * O * 8);
        for (var Q, W, ne = 0; ne < O; ne++) {
          var pe = ne << 3;
          for (Q = 0; Q < 8; Q++)
            B.push(new Uint8Array(N));
          for (var be = 0; be < F; be++) {
            J(z.blocks[ne][be], V, G);
            var ve = 0, Ee = be << 3;
            for (W = 0; W < 8; W++) {
              var Ae = B[pe + W];
              for (Q = 0; Q < 8; Q++)
                Ae[Ee + Q] = V[ve++];
            }
          }
        }
        return B;
      }
      function T(P) {
        return P < 0 ? 0 : P > 255 ? 255 : P;
      }
      g.prototype = {
        load: function(z) {
          var B = new XMLHttpRequest();
          B.open("GET", z, !0), B.responseType = "arraybuffer", B.onload = (function() {
            var F = new Uint8Array(B.response || B.mozResponseArrayBuffer);
            this.parse(F), this.onload && this.onload();
          }).bind(this), B.send(null);
        },
        parse: function(z) {
          var B = this.opts.maxResolutionInMP * 1e3 * 1e3, F = 0;
          z.length;
          function O() {
            var ue = z[F] << 8 | z[F + 1];
            return F += 2, ue;
          }
          function N() {
            var ue = O(), xe = z.subarray(F, F + ue - 2);
            return F += xe.length, xe;
          }
          function G(ue) {
            var xe = 1, ke = 1, te, me;
            for (me in ue.components)
              ue.components.hasOwnProperty(me) && (te = ue.components[me], xe < te.h && (xe = te.h), ke < te.v && (ke = te.v));
            var U = Math.ceil(ue.samplesPerLine / 8 / xe), ye = Math.ceil(ue.scanLines / 8 / ke);
            for (me in ue.components)
              if (ue.components.hasOwnProperty(me)) {
                te = ue.components[me];
                var it = Math.ceil(Math.ceil(ue.samplesPerLine / 8) * te.h / xe), I = Math.ceil(Math.ceil(ue.scanLines / 8) * te.v / ke), fe = U * te.h, de = ye * te.v, H = de * fe, ee = [];
                $(H * 256);
                for (var oe = 0; oe < de; oe++) {
                  for (var We = [], M = 0; M < fe; M++)
                    We.push(new Int32Array(64));
                  ee.push(We);
                }
                te.blocksPerLine = it, te.blocksPerColumn = I, te.blocks = ee;
              }
            ue.maxH = xe, ue.maxV = ke, ue.mcusPerLine = U, ue.mcusPerColumn = ye;
          }
          var V = null, J = null, Q, W, ne = [], pe = [], be = [], ve = [], Ee = O(), Ae = -1;
          if (this.comments = [], Ee != 65496)
            throw new Error("SOI not found");
          for (Ee = O(); Ee != 65497; ) {
            var _e, Be;
            switch (Ee) {
              case 65280:
                break;
              case 65504:
              // APP0 (Application Specific)
              case 65505:
              // APP1
              case 65506:
              // APP2
              case 65507:
              // APP3
              case 65508:
              // APP4
              case 65509:
              // APP5
              case 65510:
              // APP6
              case 65511:
              // APP7
              case 65512:
              // APP8
              case 65513:
              // APP9
              case 65514:
              // APP10
              case 65515:
              // APP11
              case 65516:
              // APP12
              case 65517:
              // APP13
              case 65518:
              // APP14
              case 65519:
              // APP15
              case 65534:
                var Me = N();
                if (Ee === 65534) {
                  var re = String.fromCharCode.apply(null, Me);
                  this.comments.push(re);
                }
                Ee === 65504 && Me[0] === 74 && Me[1] === 70 && Me[2] === 73 && Me[3] === 70 && Me[4] === 0 && (V = {
                  version: { major: Me[5], minor: Me[6] },
                  densityUnits: Me[7],
                  xDensity: Me[8] << 8 | Me[9],
                  yDensity: Me[10] << 8 | Me[11],
                  thumbWidth: Me[12],
                  thumbHeight: Me[13],
                  thumbData: Me.subarray(14, 14 + 3 * Me[12] * Me[13])
                }), Ee === 65505 && Me[0] === 69 && Me[1] === 120 && Me[2] === 105 && Me[3] === 102 && Me[4] === 0 && (this.exifBuffer = Me.subarray(5, Me.length)), Ee === 65518 && Me[0] === 65 && Me[1] === 100 && Me[2] === 111 && Me[3] === 98 && Me[4] === 101 && Me[5] === 0 && (J = {
                  version: Me[6],
                  flags0: Me[7] << 8 | Me[8],
                  flags1: Me[9] << 8 | Me[10],
                  transformCode: Me[11]
                });
                break;
              case 65499:
                for (var Te = O(), Fe = Te + F - 2; F < Fe; ) {
                  var Se = z[F++];
                  $(256);
                  var Ye = new Int32Array(64);
                  if (Se >> 4 === 0)
                    for (Be = 0; Be < 64; Be++) {
                      var Je = n[Be];
                      Ye[Je] = z[F++];
                    }
                  else if (Se >> 4 === 1)
                    for (Be = 0; Be < 64; Be++) {
                      var Je = n[Be];
                      Ye[Je] = O();
                    }
                  else
                    throw new Error("DQT: invalid table spec");
                  ne[Se & 15] = Ye;
                }
                break;
              case 65472:
              // SOF0 (Start of Frame, Baseline DCT)
              case 65473:
              // SOF1 (Start of Frame, Extended DCT)
              case 65474:
                O(), Q = {}, Q.extended = Ee === 65473, Q.progressive = Ee === 65474, Q.precision = z[F++], Q.scanLines = O(), Q.samplesPerLine = O(), Q.components = {}, Q.componentsOrder = [];
                var et = Q.scanLines * Q.samplesPerLine;
                if (et > B) {
                  var Ve = Math.ceil((et - B) / 1e6);
                  throw new Error(`maxResolutionInMP limit exceeded by ${Ve}MP`);
                }
                var tt = z[F++], qe;
                for (_e = 0; _e < tt; _e++) {
                  qe = z[F];
                  var Re = z[F + 1] >> 4, nt = z[F + 1] & 15, Ge = z[F + 2];
                  if (Re <= 0 || nt <= 0)
                    throw new Error("Invalid sampling factor, expected values above 0");
                  Q.componentsOrder.push(qe), Q.components[qe] = {
                    h: Re,
                    v: nt,
                    quantizationIdx: Ge
                  }, F += 3;
                }
                G(Q), pe.push(Q);
                break;
              case 65476:
                var Ne = O();
                for (_e = 2; _e < Ne; ) {
                  var he = z[F++], Qe = new Uint8Array(16), Ze = 0;
                  for (Be = 0; Be < 16; Be++, F++)
                    Ze += Qe[Be] = z[F];
                  $(16 + Ze);
                  var He = new Uint8Array(Ze);
                  for (Be = 0; Be < Ze; Be++, F++)
                    He[Be] = z[F];
                  _e += 17 + Ze, (he >> 4 === 0 ? ve : be)[he & 15] = E(Qe, He);
                }
                break;
              case 65501:
                O(), W = O();
                break;
              case 65500:
                O(), O();
                break;
              case 65498:
                O();
                var De = z[F++], lt = [], ot;
                for (_e = 0; _e < De; _e++) {
                  ot = Q.components[z[F++]];
                  var Le = z[F++];
                  ot.huffmanTableDC = ve[Le >> 4], ot.huffmanTableAC = be[Le & 15], lt.push(ot);
                }
                var ze = z[F++], je = z[F++], Oe = z[F++], st = k(
                  z,
                  F,
                  Q,
                  lt,
                  W,
                  ze,
                  je,
                  Oe >> 4,
                  Oe & 15,
                  this.opts
                );
                F += st;
                break;
              case 65535:
                z[F] !== 255 && F--;
                break;
              default:
                if (z[F - 3] == 255 && z[F - 2] >= 192 && z[F - 2] <= 254) {
                  F -= 3;
                  break;
                } else if (Ee === 224 || Ee == 225) {
                  if (Ae !== -1)
                    throw new Error(`first unknown JPEG marker at offset ${Ae.toString(16)}, second unknown JPEG marker ${Ee.toString(16)} at offset ${(F - 1).toString(16)}`);
                  Ae = F - 1;
                  const ue = O();
                  if (z[F + ue - 2] === 255) {
                    F += ue - 2;
                    break;
                  }
                }
                throw new Error("unknown JPEG marker " + Ee.toString(16));
            }
            Ee = O();
          }
          if (pe.length != 1)
            throw new Error("only single frame JPEGs supported");
          for (var _e = 0; _e < pe.length; _e++) {
            var Z = pe[_e].components;
            for (var Be in Z)
              Z[Be].quantizationTable = ne[Z[Be].quantizationIdx], delete Z[Be].quantizationIdx;
          }
          this.width = Q.samplesPerLine, this.height = Q.scanLines, this.jfif = V, this.adobe = J, this.components = [];
          for (var _e = 0; _e < Q.componentsOrder.length; _e++) {
            var ot = Q.components[Q.componentsOrder[_e]];
            this.components.push({
              lines: A(Q, ot),
              scaleX: ot.h / Q.maxH,
              scaleY: ot.v / Q.maxV
            });
          }
        },
        getData: function(z, B) {
          var F = this.width / z, O = this.height / B, N, G, V, J, Q, W, ne, pe, be, ve, Ee = 0, Ae, _e, Be, Me, re, Te, Fe, Se, Ye, Je, et, Ve = z * B * this.components.length;
          $(Ve);
          var tt = new Uint8Array(Ve);
          switch (this.components.length) {
            case 1:
              for (N = this.components[0], ve = 0; ve < B; ve++)
                for (Q = N.lines[0 | ve * N.scaleY * O], be = 0; be < z; be++)
                  Ae = Q[0 | be * N.scaleX * F], tt[Ee++] = Ae;
              break;
            case 2:
              for (N = this.components[0], G = this.components[1], ve = 0; ve < B; ve++)
                for (Q = N.lines[0 | ve * N.scaleY * O], W = G.lines[0 | ve * G.scaleY * O], be = 0; be < z; be++)
                  Ae = Q[0 | be * N.scaleX * F], tt[Ee++] = Ae, Ae = W[0 | be * G.scaleX * F], tt[Ee++] = Ae;
              break;
            case 3:
              for (et = !0, this.adobe && this.adobe.transformCode ? et = !0 : typeof this.opts.colorTransform < "u" && (et = !!this.opts.colorTransform), N = this.components[0], G = this.components[1], V = this.components[2], ve = 0; ve < B; ve++)
                for (Q = N.lines[0 | ve * N.scaleY * O], W = G.lines[0 | ve * G.scaleY * O], ne = V.lines[0 | ve * V.scaleY * O], be = 0; be < z; be++)
                  et ? (Ae = Q[0 | be * N.scaleX * F], _e = W[0 | be * G.scaleX * F], Be = ne[0 | be * V.scaleX * F], Se = T(Ae + 1.402 * (Be - 128)), Ye = T(Ae - 0.3441363 * (_e - 128) - 0.71413636 * (Be - 128)), Je = T(Ae + 1.772 * (_e - 128))) : (Se = Q[0 | be * N.scaleX * F], Ye = W[0 | be * G.scaleX * F], Je = ne[0 | be * V.scaleX * F]), tt[Ee++] = Se, tt[Ee++] = Ye, tt[Ee++] = Je;
              break;
            case 4:
              if (!this.adobe)
                throw new Error("Unsupported color mode (4 components)");
              for (et = !1, this.adobe && this.adobe.transformCode ? et = !0 : typeof this.opts.colorTransform < "u" && (et = !!this.opts.colorTransform), N = this.components[0], G = this.components[1], V = this.components[2], J = this.components[3], ve = 0; ve < B; ve++)
                for (Q = N.lines[0 | ve * N.scaleY * O], W = G.lines[0 | ve * G.scaleY * O], ne = V.lines[0 | ve * V.scaleY * O], pe = J.lines[0 | ve * J.scaleY * O], be = 0; be < z; be++)
                  et ? (Ae = Q[0 | be * N.scaleX * F], _e = W[0 | be * G.scaleX * F], Be = ne[0 | be * V.scaleX * F], Me = pe[0 | be * J.scaleX * F], re = 255 - T(Ae + 1.402 * (Be - 128)), Te = 255 - T(Ae - 0.3441363 * (_e - 128) - 0.71413636 * (Be - 128)), Fe = 255 - T(Ae + 1.772 * (_e - 128))) : (re = Q[0 | be * N.scaleX * F], Te = W[0 | be * G.scaleX * F], Fe = ne[0 | be * V.scaleX * F], Me = pe[0 | be * J.scaleX * F]), tt[Ee++] = 255 - re, tt[Ee++] = 255 - Te, tt[Ee++] = 255 - Fe, tt[Ee++] = 255 - Me;
              break;
            default:
              throw new Error("Unsupported color mode");
          }
          return tt;
        },
        copyToImageData: function(z, B) {
          var F = z.width, O = z.height, N = z.data, G = this.getData(F, O), V = 0, J = 0, Q, W, ne, pe, be, ve, Ee, Ae, _e;
          switch (this.components.length) {
            case 1:
              for (W = 0; W < O; W++)
                for (Q = 0; Q < F; Q++)
                  ne = G[V++], N[J++] = ne, N[J++] = ne, N[J++] = ne, B && (N[J++] = 255);
              break;
            case 3:
              for (W = 0; W < O; W++)
                for (Q = 0; Q < F; Q++)
                  Ee = G[V++], Ae = G[V++], _e = G[V++], N[J++] = Ee, N[J++] = Ae, N[J++] = _e, B && (N[J++] = 255);
              break;
            case 4:
              for (W = 0; W < O; W++)
                for (Q = 0; Q < F; Q++)
                  be = G[V++], ve = G[V++], ne = G[V++], pe = G[V++], Ee = 255 - T(be * (1 - pe / 255) + pe), Ae = 255 - T(ve * (1 - pe / 255) + pe), _e = 255 - T(ne * (1 - pe / 255) + pe), N[J++] = Ee, N[J++] = Ae, N[J++] = _e, B && (N[J++] = 255);
              break;
            default:
              throw new Error("Unsupported color mode");
          }
        }
      };
      var C = 0, D = 0;
      function $(P = 0) {
        var z = C + P;
        if (z > D) {
          var B = Math.ceil((z - D) / 1024 / 1024);
          throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${B}MB`);
        }
        C = z;
      }
      return g.resetMaxMemoryUsage = function(P) {
        C = 0, D = P;
      }, g.getBytesAllocated = function() {
        return C;
      }, g.requestMemoryAllocation = $, g;
    }();
    e.exports = t;
    function t(r, n = {}) {
      var a = {
        // "undefined" means "Choose whether to transform colors based on the images color model."
        colorTransform: void 0,
        useTArray: !1,
        formatAsRGBA: !0,
        tolerantDecoding: !0,
        maxResolutionInMP: 100,
        // Don't decode more than 100 megapixels
        maxMemoryUsageInMB: 512
        // Don't decode if memory footprint is more than 512MB
      }, s = { ...a, ...n }, o = new Uint8Array(r), h = new i();
      h.opts = s, i.resetMaxMemoryUsage(s.maxMemoryUsageInMB * 1024 * 1024), h.parse(o);
      var l = s.formatAsRGBA ? 4 : 3, f = h.width * h.height * l;
      try {
        i.requestMemoryAllocation(f);
        var b = {
          width: h.width,
          height: h.height,
          exifBuffer: h.exifBuffer,
          data: s.useTArray ? new Uint8Array(f) : Buffer.alloc(f)
        };
        h.comments.length > 0 && (b.comments = h.comments);
      } catch (w) {
        throw w instanceof RangeError ? new Error("Could not allocate enough memory for the image. Required: " + f) : w instanceof ReferenceError && w.message === "Buffer is not defined" ? new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true") : w;
      }
      return h.copyToImageData(b, s.formatAsRGBA), b;
    }
  }(decoder)), decoder.exports;
}
var jpegJs, hasRequiredJpegJs;
function requireJpegJs() {
  if (hasRequiredJpegJs) return jpegJs;
  hasRequiredJpegJs = 1;
  var e = requireEncoder(), i = requireDecoder();
  return jpegJs = {
    encode: e,
    decode: i
  }, jpegJs;
}
var jpegJsExports = requireJpegJs();
const jpeg = /* @__PURE__ */ getDefaultExportFromCjs(jpegJsExports);
let chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lookup = new Uint8Array(256);
for (let e = 0; e < chars.length; e++)
  lookup[chars.charCodeAt(e)] = e;
function encode(e) {
  let i, t = e.length, r = "";
  for (i = 0; i < t; i += 3)
    r += chars[e[i] >> 2], r += chars[(e[i] & 3) << 4 | e[i + 1] >> 4], r += chars[(e[i + 1] & 15) << 2 | e[i + 2] >> 6], r += chars[e[i + 2] & 63];
  return t % 3 === 2 ? r = `${r.substring(0, r.length - 1)}=` : t % 3 === 1 && (r = `${r.substring(0, r.length - 2)}==`), r;
}
function decode$1(e) {
  let i = e.length * 0.75, t = e.length, r = 0, n, a, s, o;
  e[e.length - 1] === "=" && (i--, e[e.length - 2] === "=" && i--);
  const h = new Uint8Array(i);
  for (let l = 0; l < t; l += 4)
    n = lookup[e.charCodeAt(l)], a = lookup[e.charCodeAt(l + 1)], s = lookup[e.charCodeAt(l + 2)], o = lookup[e.charCodeAt(l + 3)], h[r++] = n << 2 | a >> 4, h[r++] = (a & 15) << 4 | s >> 2, h[r++] = (s & 3) << 6 | o & 63;
  return h;
}
function toBase64URL(e, i) {
  const t = encode(e);
  return `data:${i};base64,${t}`;
}
const ImageData$1 = self.ImageData, DOMImage = self.Image;
function createCanvas(e, i) {
  let t = self.document.createElement("canvas");
  return t.width = e, t.height = i, t;
}
function fetchBinary(e, { withCredentials: i = !1 } = {}) {
  return new Promise(function(t, r) {
    let n = new self.XMLHttpRequest();
    n.open("GET", e, !0), n.responseType = "arraybuffer", n.withCredentials = i, n.onload = function(a) {
      this.status !== 200 ? r(a) : t(this.response);
    }, n.onerror = r, n.send();
  });
}
function createWriteStream() {
  throw new Error("createWriteStream does not exist in the browser");
}
function writeFile() {
  throw new Error("writeFile does not exist in the browser");
}
function getType(e) {
  return e.includes("/") || (e = `image/${e}`), e;
}
function encodeJpeg(e, i = {}) {
  const t = {
    width: e.width,
    height: e.height,
    data: e.getRGBAData()
  };
  return jpegJsExports.encode(t, i.quality).data;
}
function encodePng(e, i) {
  const t = {
    width: e.width,
    height: e.height,
    channels: e.channels,
    depth: e.bitDepth,
    data: e.data
  };
  return (t.depth === 1 || t.depth === 32) && (t.depth = 8, t.channels = 4, t.data = e.getRGBAData()), encodePng$1(t, i);
}
const exportMethods = {
  /**
   * Save the image to disk (Node.js only)
   * @memberof Image
   * @instance
   * @param {string} path
   * @param {object} [options]
   * @param {string} [options.format] - One of: png, jpg, bmp (limited support for bmp). If not specified will try to infer from filename
   * @param {boolean} [options.useCanvas=false] - Force use of the canvas API to save the image instead of a JavaScript implementation
   * @param {object} [options.encoder] - Specify options for the encoder if applicable.
   * @return {Promise} - Resolves when the file is fully written
   */
  save(e, i = {}) {
    const { useCanvas: t = !1, encoder: r = void 0 } = i;
    let { format: n } = i;
    if (!n) {
      const a = /\.(?<format>[a-zA-Z]+)$/.exec(e);
      a && (n = a.groups.format.toLowerCase());
    }
    if (!n)
      throw new Error("file format not provided");
    return new Promise((a, s) => {
      let o, h;
      switch (n.toLowerCase()) {
        case "png": {
          t ? o = this.getCanvas().pngStream() : h = encodePng(this, r);
          break;
        }
        case "jpg":
        case "jpeg":
          t ? o = this.getCanvas().jpegStream() : h = encodeJpeg(this, r);
          break;
        case "bmp":
          h = srcExports$3.encode(this, r);
          break;
        default:
          throw new RangeError(`invalid output format: ${n}`);
      }
      if (o) {
        let l = createWriteStream();
        l.on("finish", a), l.on("error", s), o.pipe(l);
      } else h && writeFile();
    });
  },
  /**
   * Creates a dataURL string from the image.
   * @memberof Image
   * @instance
   * @param {string} [type='image/png']
   * @param {object} [options]
   * @param {boolean} [options.useCanvas=false] - Force use of the canvas API to save the image instead of JavaScript implementation.
   * @param {object} [options.encoder] - Specify options for the encoder if applicable.
   * @return {string|Promise<string>}
   */
  toDataURL(e = "image/png", i = {}) {
    typeof e == "object" && (i = e, e = "image/png");
    const { useCanvas: t = !1, encoder: r = void 0 } = i;
    e = getType(e);
    function n(a, s) {
      const o = a(s, r);
      return toBase64URL(o, e);
    }
    return e === "image/bmp" ? n(srcExports$3.encode, this) : e === "image/png" && !t ? n(encodePng, this) : e === "image/jpeg" && !t ? n(encodeJpeg, this) : this.getCanvas().toDataURL(e);
  },
  /**
   * Encodes the image and returns a buffer
   * @memberof Image
   * @instance
   * @param {object} [options]
   * @param {string} [options.format='png']
   * @param {object} [options.encoder] - Specify options for the encoder if applicable.
   * @return {Uint8Array}
   */
  toBuffer(e = {}) {
    const { format: i = "png", encoder: t = void 0 } = e;
    switch (i.toLowerCase()) {
      case "png":
        return encodePng(this, t);
      case "jpeg":
      case "jpg":
        return encodeJpeg(this, t);
      case "bmp":
        return srcExports$3.encode(this, t);
      default:
        throw new RangeError(`invalid output format: ${i}`);
    }
  },
  /**
   * Creates a base64 string from the image.
   * @memberof Image
   * @instance
   * @param {string} [type='image/png']
   * @param {object} [options] - Same options as toDataURL
   * @return {string|Promise<string>}
   */
  toBase64(e = "image/png", i = {}) {
    if (i.async)
      return this.toDataURL(e, i).then(function(t) {
        return t.substring(t.indexOf(",") + 1);
      });
    {
      const t = this.toDataURL(e, i);
      return t.substring(t.indexOf(",") + 1);
    }
  },
  /**
   * Creates a blob from the image and return a Promise.
   * This function is only available in the browser.
   * @memberof Image
   * @instance
   * @param {string} [type='image/png'] A String indicating the image format. The default type is image/png.
   * @param {string} [quality=0.8] A Number between 0 and 1 indicating image quality if the requested type is image/jpeg or image/webp. If this argument is anything else, the default value for image quality is used. Other arguments are ignored.
   * @return {Promise}
   */
  toBlob(e = "image/png", i = 0.8) {
    return canvasToBlob(this.getCanvas(), e, i);
  },
  /**
   * Creates a new canvas element and draw the image inside it
   * @memberof Image
   * @instance
   * @return {Canvas}
   */
  getCanvas() {
    const e = new ImageData$1(
      this.getRGBAData({ clamped: !0 }),
      this.width,
      this.height
    );
    let i = createCanvas(this.width, this.height);
    return i.getContext("2d").putImageData(e, 0, 0), i;
  }
};
function setExportMethods(e) {
  for (const i in exportMethods)
    e.prototype[i] = exportMethods[i];
}
var hasOwn$1 = { exports: {} };
const version = "1.0.1", require$$0$2 = {
  version
};
var hasRequiredHasOwn;
function requireHasOwn() {
  return hasRequiredHasOwn || (hasRequiredHasOwn = 1, function(e, i) {
    var t = Object.prototype.hasOwnProperty;
    e.exports = i = function(n, a) {
      return t.call(a, n);
    }, i.version = require$$0$2.version;
  }(hasOwn$1, hasOwn$1.exports)), hasOwn$1.exports;
}
var hasOwnExports = requireHasOwn();
const hasOwn = /* @__PURE__ */ getDefaultExportFromCjs(hasOwnExports);
let computedPropertyDescriptor$1 = {
  configurable: !0,
  enumerable: !1,
  get: void 0
};
function extendMethod(e, i, t = {}) {
  let { inPlace: r = !1, returnThis: n = !0, partialArgs: a = [] } = t;
  return r ? Image.prototype[e] = function(...s) {
    this.computed = null;
    let o = i.apply(this, [...a, ...s]);
    return n ? this : o;
  } : Image.prototype[e] = function(...s) {
    return i.apply(this, [...a, ...s]);
  }, Image;
}
function extendProperty(e, i, t = {}) {
  let { partialArgs: r = [] } = t;
  return computedPropertyDescriptor$1.get = function() {
    if (this.computed === null)
      this.computed = {};
    else if (hasOwn(e, this.computed))
      return this.computed[e];
    let n = i.apply(this, r);
    return this.computed[e] = n, n;
  }, Object.defineProperty(Image.prototype, e, computedPropertyDescriptor$1), Image;
}
const GREY$1 = "GREY", RGB$1 = "RGB", HSL = "HSL", HSV = "HSV", CMYK$1 = "CMYK", ColorModel = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CMYK: CMYK$1,
  GREY: GREY$1,
  HSL,
  HSV,
  RGB: RGB$1
}, Symbol.toStringTag, { value: "Module" }));
function getRGBAData(e = {}) {
  const { clamped: i } = e;
  this.checkProcessable("getRGBAData", {
    components: [1, 3],
    bitDepth: [1, 8, 16, 32]
  });
  const t = this.width * this.height * 4;
  let r = i ? new Uint8ClampedArray(t) : new Uint8Array(t);
  return this.bitDepth === 1 ? fillDataFromBinary(this, r) : this.bitDepth === 32 ? (this.checkProcessable("getRGBAData", { alpha: 0 }), this.components === 1 ? fillDataFromGrey32(this, r) : this.components === 3 && (this.checkProcessable("getRGBAData", { colorModel: [RGB$1] }), fillDataFromRGB32(this, r))) : this.components === 1 ? fillDataFromGrey(this, r) : this.components === 3 && (this.checkProcessable("getRGBAData", { colorModel: [RGB$1] }), fillDataFromRGB(this, r)), this.alpha === 1 ? (this.checkProcessable("getRGBAData", { bitDepth: [8, 16] }), copyAlpha(this, r)) : fillAlpha(this, r), r;
}
function fillDataFromBinary(e, i) {
  for (let t = 0; t < e.size; t++) {
    const r = e.getBit(t);
    i[t * 4] = r * 255, i[t * 4 + 1] = r * 255, i[t * 4 + 2] = r * 255;
  }
}
function fillDataFromGrey32(e, i) {
  const t = e.min[0], n = e.max[0] - t;
  for (let a = 0; a < e.size; a++) {
    const s = Math.floor(255 * (e.data[a] - t) / n);
    i[a * 4] = s, i[a * 4 + 1] = s, i[a * 4 + 2] = s;
  }
}
function fillDataFromRGB32(e, i) {
  const t = Math.min(...e.min), n = Math.max(...e.max) - t;
  for (let a = 0; a < e.size; a++) {
    const s = Math.floor(255 * (e.data[a * 3] - t) / n), o = Math.floor(255 * (e.data[a * 3 + 1] - t) / n), h = Math.floor(255 * (e.data[a * 3 + 2] - t) / n);
    i[a * 4] = s, i[a * 4 + 1] = o, i[a * 4 + 2] = h;
  }
}
function fillDataFromGrey(e, i) {
  for (let t = 0; t < e.size; t++)
    i[t * 4] = e.data[t * e.channels] >>> e.bitDepth - 8, i[t * 4 + 1] = e.data[t * e.channels] >>> e.bitDepth - 8, i[t * 4 + 2] = e.data[t * e.channels] >>> e.bitDepth - 8;
}
function fillDataFromRGB(e, i) {
  for (let t = 0; t < e.size; t++)
    i[t * 4] = e.data[t * e.channels] >>> e.bitDepth - 8, i[t * 4 + 1] = e.data[t * e.channels + 1] >>> e.bitDepth - 8, i[t * 4 + 2] = e.data[t * e.channels + 2] >>> e.bitDepth - 8;
}
function copyAlpha(e, i) {
  for (let t = 0; t < e.size; t++)
    i[t * 4 + 3] = e.data[t * e.channels + e.components] >> e.bitDepth - 8;
}
function fillAlpha(e, i) {
  for (let t = 0; t < e.size; t++)
    i[t * 4 + 3] = 255;
}
const BINARY = "BINARY", GREY = "GREY", GREYA = "GREYA", RGB = "RGB", RGBA = "RGBA", CMYK = "CMYK", CMYKA = "CMYKA", kinds = {};
kinds[BINARY] = {
  components: 1,
  alpha: 0,
  bitDepth: 1,
  colorModel: GREY$1
};
kinds[GREYA] = {
  components: 1,
  alpha: 1,
  bitDepth: 8,
  colorModel: GREY$1
};
kinds[GREY] = {
  components: 1,
  alpha: 0,
  bitDepth: 8,
  colorModel: GREY$1
};
kinds[RGBA] = {
  components: 3,
  alpha: 1,
  bitDepth: 8,
  colorModel: RGB$1
};
kinds[RGB] = {
  components: 3,
  alpha: 0,
  bitDepth: 8,
  colorModel: RGB$1
};
kinds[CMYK] = {
  components: 4,
  alpha: 0,
  bitDepth: 8,
  colorModel: CMYK$1
};
kinds[CMYKA] = {
  components: 4,
  alpha: 1,
  bitDepth: 8,
  colorModel: CMYK$1
};
function getKind(e) {
  const i = kinds[e];
  if (!i)
    throw new RangeError(`invalid image kind: ${e}`);
  return i;
}
const validBitDepth = [1, 8, 16, 32];
function verifyKindDefinition(e) {
  const { components: i, alpha: t, bitDepth: r, colorModel: n } = e;
  if (!Number.isInteger(i) || i <= 0)
    throw new RangeError(
      `invalid components: ${i}. Must be a positive integer`
    );
  if (t !== 0 && t !== 1 && typeof t != "boolean")
    throw new TypeError(`invalid alpha: ${t}: must be a boolean, 0 or 1`);
  if (!validBitDepth.includes(r))
    throw new RangeError(
      `invalid bitDepth: ${r}. Must be one of ${validBitDepth.join(
        ", "
      )}`
    );
  if (!ColorModel[n])
    throw new RangeError(
      `invalid colorModel: ${n}. Must be one of ${Object.keys(
        ColorModel
      ).join(", ")}`
    );
}
function getTheoreticalPixelArraySize(e, i, t) {
  let r = i * e;
  return t === 1 && (r = Math.ceil(r / 8)), r;
}
function createPixelArray(e, i, t, r, n, a) {
  const s = r * e;
  let o;
  switch (n) {
    case 1:
      o = new Uint8Array(Math.ceil(s / 8));
      break;
    case 8:
      o = new Uint8Array(s);
      break;
    case 16:
      o = new Uint16Array(s);
      break;
    case 32:
      o = new Float32Array(s);
      break;
    default:
      throw new Error(`Cannot create pixel array for bit depth ${n}`);
  }
  if (t)
    for (let h = i; h < o.length; h += r)
      o[h] = a;
  return o;
}
var src$4 = {}, IOBuffer_1, hasRequiredIOBuffer;
function requireIOBuffer() {
  if (hasRequiredIOBuffer) return IOBuffer_1;
  hasRequiredIOBuffer = 1;
  const e = 1024 * 8, i = [];
  class t {
    constructor(n, a) {
      a = a || {}, n === void 0 && (n = e), typeof n == "number" && (n = new ArrayBuffer(n));
      let s = n.byteLength;
      const o = a.offset ? a.offset >>> 0 : 0;
      n.buffer && (s = n.byteLength - o, n.byteLength !== n.buffer.byteLength ? n = n.buffer.slice(n.byteOffset + o, n.byteOffset + n.byteLength) : o ? n = n.buffer.slice(o) : n = n.buffer), this.buffer = n, this.length = s, this.byteLength = s, this.byteOffset = 0, this.offset = 0, this.littleEndian = !0, this._data = new DataView(this.buffer), this._increment = s || e, this._mark = 0;
    }
    available(n) {
      return n === void 0 && (n = 1), this.offset + n <= this.length;
    }
    isLittleEndian() {
      return this.littleEndian;
    }
    setLittleEndian() {
      this.littleEndian = !0;
    }
    isBigEndian() {
      return !this.littleEndian;
    }
    setBigEndian() {
      this.littleEndian = !1;
    }
    skip(n) {
      n === void 0 && (n = 1), this.offset += n;
    }
    seek(n) {
      this.offset = n;
    }
    mark() {
      this._mark = this.offset;
    }
    reset() {
      this.offset = this._mark;
    }
    rewind() {
      this.offset = 0;
    }
    ensureAvailable(n) {
      if (n === void 0 && (n = 1), !this.available(n)) {
        const a = this._increment + this._increment;
        this._increment = a;
        const s = this.length + a, o = new Uint8Array(s);
        o.set(new Uint8Array(this.buffer)), this.buffer = o.buffer, this.length = s, this._data = new DataView(this.buffer);
      }
    }
    readBoolean() {
      return this.readUint8() !== 0;
    }
    readInt8() {
      return this._data.getInt8(this.offset++);
    }
    readUint8() {
      return this._data.getUint8(this.offset++);
    }
    readByte() {
      return this.readUint8();
    }
    readBytes(n) {
      n === void 0 && (n = 1);
      for (var a = new Uint8Array(n), s = 0; s < n; s++)
        a[s] = this.readByte();
      return a;
    }
    readInt16() {
      var n = this._data.getInt16(this.offset, this.littleEndian);
      return this.offset += 2, n;
    }
    readUint16() {
      var n = this._data.getUint16(this.offset, this.littleEndian);
      return this.offset += 2, n;
    }
    readInt32() {
      var n = this._data.getInt32(this.offset, this.littleEndian);
      return this.offset += 4, n;
    }
    readUint32() {
      var n = this._data.getUint32(this.offset, this.littleEndian);
      return this.offset += 4, n;
    }
    readFloat32() {
      var n = this._data.getFloat32(this.offset, this.littleEndian);
      return this.offset += 4, n;
    }
    readFloat64() {
      var n = this._data.getFloat64(this.offset, this.littleEndian);
      return this.offset += 8, n;
    }
    readChar() {
      return String.fromCharCode(this.readInt8());
    }
    readChars(n) {
      n === void 0 && (n = 1), i.length = n;
      for (var a = 0; a < n; a++)
        i[a] = this.readChar();
      return i.join("");
    }
    writeBoolean(n) {
      this.writeUint8(n ? 255 : 0);
    }
    writeInt8(n) {
      this.ensureAvailable(1), this._data.setInt8(this.offset++, n);
    }
    writeUint8(n) {
      this.ensureAvailable(1), this._data.setUint8(this.offset++, n);
    }
    writeByte(n) {
      this.writeUint8(n);
    }
    writeBytes(n) {
      this.ensureAvailable(n.length);
      for (var a = 0; a < n.length; a++)
        this._data.setUint8(this.offset++, n[a]);
    }
    writeInt16(n) {
      this.ensureAvailable(2), this._data.setInt16(this.offset, n, this.littleEndian), this.offset += 2;
    }
    writeUint16(n) {
      this.ensureAvailable(2), this._data.setUint16(this.offset, n, this.littleEndian), this.offset += 2;
    }
    writeInt32(n) {
      this.ensureAvailable(4), this._data.setInt32(this.offset, n, this.littleEndian), this.offset += 4;
    }
    writeUint32(n) {
      this.ensureAvailable(4), this._data.setUint32(this.offset, n, this.littleEndian), this.offset += 4;
    }
    writeFloat32(n) {
      this.ensureAvailable(4), this._data.setFloat32(this.offset, n, this.littleEndian), this.offset += 4;
    }
    writeFloat64(n) {
      this.ensureAvailable(8), this._data.setFloat64(this.offset, n, this.littleEndian), this.offset += 8;
    }
    writeChar(n) {
      this.writeUint8(n.charCodeAt(0));
    }
    writeChars(n) {
      for (var a = 0; a < n.length; a++)
        this.writeUint8(n.charCodeAt(a));
    }
    toArray() {
      return new Uint8Array(this.buffer, 0, this.offset);
    }
  }
  return IOBuffer_1 = t, IOBuffer_1;
}
var src$3 = {}, standard$1, hasRequiredStandard;
function requireStandard() {
  if (hasRequiredStandard) return standard$1;
  hasRequiredStandard = 1;
  const e = {
    // Baseline tags
    254: "NewSubfileType",
    255: "SubfileType",
    256: "ImageWidth",
    257: "ImageLength",
    258: "BitsPerSample",
    259: "Compression",
    262: "PhotometricInterpretation",
    263: "Threshholding",
    264: "CellWidth",
    265: "CellLength",
    266: "FillOrder",
    270: "ImageDescription",
    271: "Make",
    272: "Model",
    273: "StripOffsets",
    274: "Orientation",
    277: "SamplesPerPixel",
    278: "RowsPerStrip",
    279: "StripByteCounts",
    280: "MinSampleValue",
    281: "MaxSampleValue",
    282: "XResolution",
    283: "YResolution",
    284: "PlanarConfiguration",
    288: "FreeOffsets",
    289: "FreeByteCounts",
    290: "GrayResponseUnit",
    291: "GrayResponseCurve",
    296: "ResolutionUnit",
    305: "Software",
    306: "DateTime",
    315: "Artist",
    316: "HostComputer",
    320: "ColorMap",
    338: "ExtraSamples",
    33432: "Copyright",
    // Extension tags
    269: "DocumentName",
    285: "PageName",
    286: "XPosition",
    287: "YPosition",
    292: "T4Options",
    293: "T6Options",
    297: "PageNumber",
    301: "TransferFunction",
    317: "Predictor",
    318: "WhitePoint",
    319: "PrimaryChromaticities",
    321: "HalftoneHints",
    322: "TileWidth",
    323: "TileLength",
    324: "TileOffsets",
    325: "TileByteCounts",
    326: "BadFaxLines",
    327: "CleanFaxData",
    328: "ConsecutiveBadFaxLines",
    330: "SubIFDs",
    332: "InkSet",
    333: "InkNames",
    334: "NumberOfInks",
    336: "DotRange",
    337: "TargetPrinter",
    339: "SampleFormat",
    340: "SMinSampleValue",
    341: "SMaxSampleValue",
    342: "TransferRange",
    343: "ClipPath",
    344: "XClipPathUnits",
    345: "YClipPathUnits",
    346: "Indexed",
    347: "JPEGTables",
    351: "OPIProxy",
    400: "GlobalParametersIFD",
    401: "ProfileType",
    402: "FaxProfile",
    403: "CodingMethods",
    404: "VersionYear",
    405: "ModeNumber",
    433: "Decode",
    434: "DefaultImageColor",
    512: "JPEGProc",
    513: "JPEGInterchangeFormat",
    514: "JPEGInterchangeFormatLength",
    515: "JPEGRestartInterval",
    517: "JPEGLosslessPredictors",
    518: "JPEGPointTransforms",
    519: "JPEGQTables",
    520: "JPEGDCTables",
    521: "JPEGACTables",
    529: "YCbCrCoefficients",
    530: "YCbCrSubSampling",
    531: "YCbCrPositioning",
    532: "ReferenceBlackWhite",
    559: "StripRowCounts",
    700: "XMP",
    32781: "ImageID",
    34732: "ImageLayer",
    // Private tags
    32932: "WangAnnotatio",
    33445: "MDFileTag",
    33446: "MDScalePixel",
    33447: "MDColorTable",
    33448: "MDLabName",
    33449: "MDSampleInfo",
    33450: "MDPrepDate",
    33451: "MDPrepTime",
    33452: "MDFileUnits",
    33550: "ModelPixelScaleTag",
    33723: "IPTC",
    33918: "INGRPacketDataTag",
    33919: "INGRFlagRegisters",
    33920: "IrasBTransformationMatrix",
    33922: "ModelTiepointTag",
    34264: "ModelTransformationTag",
    34377: "Photoshop",
    34665: "ExifIFD",
    34675: "ICCProfile",
    34735: "GeoKeyDirectoryTag",
    34736: "GeoDoubleParamsTag",
    34737: "GeoAsciiParamsTag",
    34853: "GPSIFD",
    34908: "HylaFAXFaxRecvParams",
    34909: "HylaFAXFaxSubAddress",
    34910: "HylaFAXFaxRecvTime",
    37724: "ImageSourceData",
    40965: "InteroperabilityIFD",
    42112: "GDAL_METADATA",
    42113: "GDAL_NODATA",
    50215: "OceScanjobDescription",
    50216: "OceApplicationSelector",
    50217: "OceIdentificationNumber",
    50218: "OceImageLogicCharacteristics",
    50706: "DNGVersion",
    50707: "DNGBackwardVersion",
    50708: "UniqueCameraModel",
    50709: "LocalizedCameraModel",
    50710: "CFAPlaneColor",
    50711: "CFALayout",
    50712: "LinearizationTable",
    50713: "BlackLevelRepeatDim",
    50714: "BlackLevel",
    50715: "BlackLevelDeltaH",
    50716: "BlackLevelDeltaV",
    50717: "WhiteLevel",
    50718: "DefaultScale",
    50719: "DefaultCropOrigin",
    50720: "DefaultCropSize",
    50721: "ColorMatrix1",
    50722: "ColorMatrix2",
    50723: "CameraCalibration1",
    50724: "CameraCalibration2",
    50725: "ReductionMatrix1",
    50726: "ReductionMatrix2",
    50727: "AnalogBalance",
    50728: "AsShotNeutral",
    50729: "AsShotWhiteXY",
    50730: "BaselineExposure",
    50731: "BaselineNoise",
    50732: "BaselineSharpness",
    50733: "BayerGreenSplit",
    50734: "LinearResponseLimit",
    50735: "CameraSerialNumber",
    50736: "LensInfo",
    50737: "ChromaBlurRadius",
    50738: "AntiAliasStrength",
    50740: "DNGPrivateData",
    50741: "MakerNoteSafety",
    50778: "CalibrationIlluminant1",
    50779: "CalibrationIlluminant2",
    50780: "BestQualityScale",
    50784: "AliasLayerMetadata"
  }, i = {};
  for (var t in e)
    i[e[t]] = t;
  return standard$1 = {
    tagsById: e,
    tagsByName: i
  }, standard$1;
}
var exif$1, hasRequiredExif;
function requireExif() {
  if (hasRequiredExif) return exif$1;
  hasRequiredExif = 1;
  const e = {
    33434: "ExposureTime",
    33437: "FNumber",
    34850: "ExposureProgram",
    34852: "SpectralSensitivity",
    34855: "ISOSpeedRatings",
    34856: "OECF",
    34864: "SensitivityType",
    34865: "StandardOutputSensitivity",
    34866: "RecommendedExposureIndex",
    34867: "ISOSpeed",
    34868: "ISOSpeedLatitudeyyy",
    34869: "ISOSpeedLatitudezzz",
    36864: "ExifVersion",
    36867: "DateTimeOriginal",
    36868: "DateTimeDigitized",
    37121: "ComponentsConfiguration",
    37122: "CompressedBitsPerPixel",
    37377: "ShutterSpeedValue",
    37378: "ApertureValue",
    37379: "BrightnessValue",
    37380: "ExposureBiasValue",
    37381: "MaxApertureValue",
    37382: "SubjectDistance",
    37383: "MeteringMode",
    37384: "LightSource",
    37385: "Flash",
    37386: "FocalLength",
    37396: "SubjectArea",
    37500: "MakerNote",
    37510: "UserComment",
    37520: "SubsecTime",
    37521: "SubsecTimeOriginal",
    37522: "SubsecTimeDigitized",
    40960: "FlashpixVersion",
    40961: "ColorSpace",
    40962: "PixelXDimension",
    40963: "PixelYDimension",
    40964: "RelatedSoundFile",
    41483: "FlashEnergy",
    41484: "SpatialFrequencyResponse",
    41486: "FocalPlaneXResolution",
    41487: "FocalPlaneYResolution",
    41488: "FocalPlaneResolutionUnit",
    41492: "SubjectLocation",
    41493: "ExposureIndex",
    41495: "SensingMethod",
    41728: "FileSource",
    41729: "SceneType",
    41730: "CFAPattern",
    41985: "CustomRendered",
    41986: "ExposureMode",
    41987: "WhiteBalance",
    41988: "DigitalZoomRatio",
    41989: "FocalLengthIn35mmFilm",
    41990: "SceneCaptureType",
    41991: "GainControl",
    41992: "Contrast",
    41993: "Saturation",
    41994: "Sharpness",
    41995: "DeviceSettingDescription",
    41996: "SubjectDistanceRange",
    42016: "ImageUniqueID",
    42032: "CameraOwnerName",
    42033: "BodySerialNumber",
    42034: "LensSpecification",
    42035: "LensMake",
    42036: "LensModel",
    42037: "LensSerialNumber",
    42240: "Gamma"
  }, i = {};
  for (var t in e)
    i[e[t]] = t;
  return exif$1 = {
    tagsById: e,
    tagsByName: i
  }, exif$1;
}
var gps$1, hasRequiredGps;
function requireGps() {
  if (hasRequiredGps) return gps$1;
  hasRequiredGps = 1;
  const e = {
    0: "GPSVersionID",
    1: "GPSLatitudeRef",
    2: "GPSLatitude",
    3: "GPSLongitudeRef",
    4: "GPSLongitude",
    5: "GPSAltitudeRef",
    6: "GPSAltitude",
    7: "GPSTimeStamp",
    8: "GPSSatellites",
    9: "GPSStatus",
    10: "GPSMeasureMode",
    11: "GPSDOP",
    12: "GPSSpeedRef",
    13: "GPSSpeed",
    14: "GPSTrackRef",
    15: "GPSTrack",
    16: "GPSImgDirectionRef",
    17: "GPSImgDirection",
    18: "GPSMapDatum",
    19: "GPSDestLatitudeRef",
    20: "GPSDestLatitude",
    21: "GPSDestLongitudeRef",
    22: "GPSDestLongitude",
    23: "GPSDestBearingRef",
    24: "GPSDestBearing",
    25: "GPSDestDistanceRef",
    26: "GPSDestDistance",
    27: "GPSProcessingMethod",
    28: "GPSAreaInformation",
    29: "GPSDateStamp",
    30: "GPSDifferential",
    31: "GPSHPositioningError"
  }, i = {};
  for (var t in e)
    i[e[t]] = t;
  return gps$1 = {
    tagsById: e,
    tagsByName: i
  }, gps$1;
}
var ifd, hasRequiredIfd;
function requireIfd() {
  if (hasRequiredIfd) return ifd;
  hasRequiredIfd = 1;
  const e = {
    standard: requireStandard(),
    exif: requireExif(),
    gps: requireGps()
  };
  class i {
    constructor(r) {
      if (!r)
        throw new Error("missing kind");
      this.data = null, this.fields = /* @__PURE__ */ new Map(), this.kind = r, this._map = null;
    }
    get(r) {
      if (typeof r == "number")
        return this.fields.get(r);
      if (typeof r == "string")
        return this.fields.get(e[this.kind].tagsByName[r]);
      throw new Error("expected a number or string");
    }
    get map() {
      if (!this._map) {
        this._map = {};
        const n = e[this.kind].tagsById;
        for (var r of this.fields.keys())
          n[r] && (this._map[n[r]] = this.fields.get(r));
      }
      return this._map;
    }
  }
  return ifd = i, ifd;
}
var tiffIfd, hasRequiredTiffIfd;
function requireTiffIfd() {
  if (hasRequiredTiffIfd) return tiffIfd;
  hasRequiredTiffIfd = 1;
  const e = requireIfd(), i = /^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})$/;
  class t extends e {
    constructor() {
      super("standard");
    }
    // Custom fields
    get size() {
      return this.width * this.height;
    }
    get width() {
      return this.imageWidth;
    }
    get height() {
      return this.imageLength;
    }
    get components() {
      return this.samplesPerPixel;
    }
    get date() {
      var a = /* @__PURE__ */ new Date(), s = i.exec(this.dateTime);
      return a.setFullYear(s[1], s[2] - 1, s[3]), a.setHours(s[4], s[5], s[6]), a;
    }
    // IFD fields
    get newSubfileType() {
      return this.get(254);
    }
    get imageWidth() {
      return this.get(256);
    }
    get imageLength() {
      return this.get(257);
    }
    get bitsPerSample() {
      return this.get(258);
    }
    get compression() {
      return this.get(259) || 1;
    }
    get type() {
      return this.get(262);
    }
    get fillOrder() {
      return this.get(266) || 1;
    }
    get documentName() {
      return this.get(269);
    }
    get imageDescription() {
      return this.get(270);
    }
    get stripOffsets() {
      return r(this.get(273));
    }
    get orientation() {
      return this.get(274);
    }
    get samplesPerPixel() {
      return this.get(277);
    }
    get rowsPerStrip() {
      return this.get(278);
    }
    get stripByteCounts() {
      return r(this.get(279));
    }
    get minSampleValue() {
      return this.get(280) || 0;
    }
    get maxSampleValue() {
      return this.get(281) || Math.pow(2, this.bitsPerSample) - 1;
    }
    get xResolution() {
      return this.get(282);
    }
    get yResolution() {
      return this.get(283);
    }
    get planarConfiguration() {
      return this.get(284) || 1;
    }
    get resolutionUnit() {
      return this.get(296) || 2;
    }
    get dateTime() {
      return this.get(306);
    }
    get predictor() {
      return this.get(317) || 1;
    }
    get sampleFormat() {
      return this.get(339) || 1;
    }
    get sMinSampleValue() {
      return this.get(340) || this.minSampleValue;
    }
    get sMaxSampleValue() {
      return this.get(341) || this.maxSampleValue;
    }
  }
  function r(n) {
    return typeof n == "number" ? [n] : n;
  }
  return tiffIfd = t, tiffIfd;
}
var ifdValue = {}, hasRequiredIfdValue;
function requireIfdValue() {
  if (hasRequiredIfdValue) return ifdValue;
  hasRequiredIfdValue = 1;
  var e = /* @__PURE__ */ new Map([
    [1, [1, i]],
    // BYTE
    [2, [1, t]],
    // ASCII
    [3, [2, r]],
    // SHORT
    [4, [4, n]],
    // LONG
    [5, [8, a]],
    // RATIONAL
    [6, [1, s]],
    // SBYTE
    [7, [1, i]],
    // UNDEFINED
    [8, [2, o]],
    // SSHORT
    [9, [4, h]],
    // SLONG
    [10, [8, l]],
    // SRATIONAL
    [11, [4, f]],
    // FLOAT
    [12, [8, b]]
    // DOUBLE
  ]);
  ifdValue.getByteLength = function(w, g) {
    return e.get(w)[0] * g;
  }, ifdValue.readData = function(w, g, E) {
    return e.get(g)[1](w, E);
  };
  function i(w, g) {
    if (g === 1) return w.readUint8();
    for (var E = new Uint8Array(g), k = 0; k < g; k++)
      E[k] = w.readUint8();
    return E;
  }
  function t(w, g) {
    for (var E = [], k = "", A = 0; A < g; A++) {
      var T = String.fromCharCode(w.readUint8());
      T === "\0" ? (E.push(k), k = "") : k += T;
    }
    return E.length === 1 ? E[0] : E;
  }
  function r(w, g) {
    if (g === 1) return w.readUint16();
    for (var E = new Uint16Array(g), k = 0; k < g; k++)
      E[k] = w.readUint16();
    return E;
  }
  function n(w, g) {
    if (g === 1) return w.readUint32();
    for (var E = new Uint32Array(g), k = 0; k < g; k++)
      E[k] = w.readUint32();
    return E;
  }
  function a(w, g) {
    if (g === 1)
      return w.readUint32() / w.readUint32();
    for (var E = new Array(g), k = 0; k < g; k++)
      E[k] = w.readUint32() / w.readUint32();
    return E;
  }
  function s(w, g) {
    if (g === 1) return w.readInt8();
    for (var E = new Int8Array(g), k = 0; k < g; k++)
      E[k] = w.readInt8();
    return E;
  }
  function o(w, g) {
    if (g === 1) return w.readInt16();
    for (var E = new Int16Array(g), k = 0; k < g; k++)
      E[k] = w.readInt16();
    return E;
  }
  function h(w, g) {
    if (g === 1) return w.readInt32();
    for (var E = new Int32Array(g), k = 0; k < g; k++)
      E[k] = w.readInt32();
    return E;
  }
  function l(w, g) {
    if (g === 1)
      return w.readInt32() / w.readInt32();
    for (var E = new Array(g), k = 0; k < g; k++)
      E[k] = w.readInt32() / w.readInt32();
    return E;
  }
  function f(w, g) {
    if (g === 1) return w.readFloat32();
    for (var E = new Float32Array(g), k = 0; k < g; k++)
      E[k] = w.readFloat32();
    return E;
  }
  function b(w, g) {
    if (g === 1) return w.readFloat64();
    for (var E = new Float64Array(g), k = 0; k < g; k++)
      E[k] = w.readFloat64();
    return E;
  }
  return ifdValue;
}
var tiffDecoder, hasRequiredTiffDecoder;
function requireTiffDecoder() {
  if (hasRequiredTiffDecoder) return tiffDecoder;
  hasRequiredTiffDecoder = 1;
  const e = requireIOBuffer(), i = requireIfd(), t = requireTiffIfd(), r = requireIfdValue(), n = {
    ignoreImageData: !1,
    onlyFirst: !1
  };
  class a extends e {
    constructor(g, E) {
      super(g, E), this._nextIFD = 0;
    }
    decode(g) {
      g = Object.assign({}, n, g);
      const E = [];
      for (this.decodeHeader(); this._nextIFD; )
        if (E.push(this.decodeIFD(g)), g.onlyFirst)
          return E[0];
      return E;
    }
    decodeHeader() {
      let g = this.readUint16();
      if (g === 18761)
        this.setLittleEndian();
      else if (g === 19789)
        this.setBigEndian();
      else
        throw new Error("invalid byte order: 0x" + g.toString(16));
      if (g = this.readUint16(), g !== 42)
        throw new Error("not a TIFF file");
      this._nextIFD = this.readUint32();
    }
    decodeIFD(g) {
      this.seek(this._nextIFD);
      var E;
      g.kind ? E = new i(g.kind) : E = new t();
      const k = this.readUint16();
      for (var A = 0; A < k; A++)
        this.decodeIFDEntry(E);
      return g.ignoreImageData || this.decodeImageData(E), this._nextIFD = this.readUint32(), E;
    }
    decodeIFDEntry(g) {
      const E = this.offset, k = this.readUint16(), A = this.readUint16(), T = this.readUint32();
      if (A < 1 || A > 12) {
        this.skip(4);
        return;
      }
      r.getByteLength(A, T) > 4 && this.seek(this.readUint32());
      const D = r.readData(this, A, T);
      if (g.fields.set(k, D), k === 34665 || k === 34853) {
        let $ = this.offset, P;
        k === 34665 ? P = "exif" : k === 34853 && (P = "gps"), this._nextIFD = D, g[P] = this.decodeIFD({
          kind: P,
          ignoreImageData: !0
        }), this.offset = $;
      }
      this.seek(E), this.skip(12);
    }
    decodeImageData(g) {
      const E = g.orientation;
      switch (E && E !== 1 && f("orientation", E), g.type) {
        case 1:
        // BlackIsZero
        case 2:
          this.readStripData(g);
          break;
        default:
          f("image type", g.type);
          break;
      }
    }
    readStripData(g) {
      const E = g.width, k = g.height, A = b(g.bitsPerSample), T = g.sampleFormat;
      let C = E * k;
      const D = s(C, 1, A, T), $ = g.compression, z = g.rowsPerStrip * E, B = g.stripOffsets, F = g.stripByteCounts;
      for (var O = 0, N = 0; N < B.length; N++) {
        var G = this.getStripData($, B[N], F[N]), V = C > z ? z : C;
        C -= V, A === 8 ? O = o(D, G, O, V) : A === 16 ? O = h(D, G, O, V, this.isLittleEndian()) : A === 32 && T === 3 ? O = l(D, G, O, V, this.isLittleEndian()) : f("bitDepth", A);
      }
      g.data = D;
    }
    getStripData(g, E, k) {
      switch (g) {
        case 1:
          return new DataView(this.buffer, E, k);
        case 2:
        // CCITT Group 3 1-Dimensional Modified Huffman run length encoding
        case 32773:
          return f("Compression", g);
        default:
          throw new Error("invalid compression: " + g);
      }
    }
  }
  tiffDecoder = a;
  function s(w, g, E, k) {
    return E === 8 ? new Uint8Array(w * g) : E === 16 ? new Uint16Array(w * g) : E === 32 && k === 3 ? new Float32Array(w * g) : f("bit depth / sample format", E + " / " + k);
  }
  function o(w, g, E, k) {
    for (var A = 0; A < k; A++)
      w[E++] = g.getUint8(A);
    return E;
  }
  function h(w, g, E, k, A) {
    for (var T = 0; T < k * 2; T += 2)
      w[E++] = g.getUint16(T, A);
    return E;
  }
  function l(w, g, E, k, A) {
    for (var T = 0; T < k * 4; T += 4)
      w[E++] = g.getFloat32(T, A);
    return E;
  }
  function f(w, g) {
    throw new Error("Unsupported " + w + ": " + g);
  }
  function b(w) {
    if (w.length) {
      const E = w;
      w = E[0];
      for (var g = 0; g < E.length; g++)
        E[g] !== w && f("bit depth", E);
    }
    return w;
  }
  return tiffDecoder;
}
var decode, hasRequiredDecode$1;
function requireDecode$1() {
  if (hasRequiredDecode$1) return decode;
  hasRequiredDecode$1 = 1;
  const e = requireTiffDecoder();
  return decode = function(t, r) {
    return new e(t, r).decode(r);
  }, decode;
}
var hasRequiredSrc$4;
function requireSrc$4() {
  return hasRequiredSrc$4 || (hasRequiredSrc$4 = 1, src$3.decode = requireDecode$1()), src$3;
}
var decode_1, hasRequiredDecode;
function requireDecode() {
  if (hasRequiredDecode) return decode_1;
  hasRequiredDecode = 1;
  const e = requireIOBuffer(), i = requireSrc$4();
  function t(r) {
    const n = new e(r), a = {};
    if (n.setBigEndian(), n.readUint16() !== 65496)
      throw new Error("SOI marker not found. Not a valid JPEG file");
    if (n.readUint16() === 65505) {
      n.readUint16();
      const h = n.readBytes(6);
      if (h[0] === 69 && // E
      h[1] === 120 && // x
      h[2] === 105 && // i
      h[3] === 102 && // f
      h[4] === 0 && h[5] === 0) {
        const l = i.decode(n, {
          onlyFirst: !0,
          ignoreImageData: !0,
          offset: n.offset
        });
        a.exif = l;
      }
    }
    return a;
  }
  return decode_1 = t, decode_1;
}
var hasRequiredSrc$3;
function requireSrc$3() {
  return hasRequiredSrc$3 || (hasRequiredSrc$3 = 1, src$4.decode = requireDecode()), src$4;
}
var srcExports$2 = requireSrc$3(), imageType$1 = { exports: {} }, fileType = { exports: {} }, hasRequiredFileType;
function requireFileType() {
  return hasRequiredFileType || (hasRequiredFileType = 1, function(module) {
    const toBytes = (e) => [...e].map((i) => i.charCodeAt(0)), xpiZipFilename = toBytes("META-INF/mozilla.rsa"), oxmlContentTypes = toBytes("[Content_Types].xml"), oxmlRels = toBytes("_rels/.rels");
    function readUInt64LE(e, i = 0) {
      let t = e[i], r = 1, n = 0;
      for (; ++n < 8; )
        r *= 256, t += e[i + n] * r;
      return t;
    }
    const fileType = (e) => {
      if (!(e instanceof Uint8Array || e instanceof ArrayBuffer || Buffer.isBuffer(e)))
        throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof e}\``);
      const i = e instanceof Uint8Array ? e : new Uint8Array(e);
      if (!(i && i.length > 1))
        return null;
      const t = (n, a) => {
        a = Object.assign({
          offset: 0
        }, a);
        for (let s = 0; s < n.length; s++)
          if (a.mask) {
            if (n[s] !== (a.mask[s] & i[s + a.offset]))
              return !1;
          } else if (n[s] !== i[s + a.offset])
            return !1;
        return !0;
      }, r = (n, a) => t(toBytes(n), a);
      if (t([255, 216, 255]))
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      if (t([137, 80, 78, 71, 13, 10, 26, 10]))
        return {
          ext: "png",
          mime: "image/png"
        };
      if (t([71, 73, 70]))
        return {
          ext: "gif",
          mime: "image/gif"
        };
      if (t([87, 69, 66, 80], { offset: 8 }))
        return {
          ext: "webp",
          mime: "image/webp"
        };
      if (t([70, 76, 73, 70]))
        return {
          ext: "flif",
          mime: "image/flif"
        };
      if ((t([73, 73, 42, 0]) || t([77, 77, 0, 42])) && t([67, 82], { offset: 8 }))
        return {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        };
      if (t([73, 73, 42, 0]) || t([77, 77, 0, 42]))
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      if (t([66, 77]))
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      if (t([73, 73, 188]))
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      if (t([56, 66, 80, 83]))
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      if (t([80, 75, 3, 4])) {
        if (t([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], { offset: 30 }))
          return {
            ext: "epub",
            mime: "application/epub+zip"
          };
        if (t(xpiZipFilename, { offset: 30 }))
          return {
            ext: "xpi",
            mime: "application/x-xpinstall"
          };
        if (r("mimetypeapplication/vnd.oasis.opendocument.text", { offset: 30 }))
          return {
            ext: "odt",
            mime: "application/vnd.oasis.opendocument.text"
          };
        if (r("mimetypeapplication/vnd.oasis.opendocument.spreadsheet", { offset: 30 }))
          return {
            ext: "ods",
            mime: "application/vnd.oasis.opendocument.spreadsheet"
          };
        if (r("mimetypeapplication/vnd.oasis.opendocument.presentation", { offset: 30 }))
          return {
            ext: "odp",
            mime: "application/vnd.oasis.opendocument.presentation"
          };
        const n = (h, l = 0) => h.findIndex((f, b, w) => b >= l && w[b] === 80 && w[b + 1] === 75 && w[b + 2] === 3 && w[b + 3] === 4);
        let a = 0, s = !1, o = null;
        do {
          const h = a + 30;
          if (s || (s = t(oxmlContentTypes, { offset: h }) || t(oxmlRels, { offset: h })), o || (r("word/", { offset: h }) ? o = {
            ext: "docx",
            mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
          } : r("ppt/", { offset: h }) ? o = {
            ext: "pptx",
            mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
          } : r("xl/", { offset: h }) && (o = {
            ext: "xlsx",
            mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
          })), s && o)
            return o;
          a = n(i, h);
        } while (a >= 0);
        if (o)
          return o;
      }
      if (t([80, 75]) && (i[2] === 3 || i[2] === 5 || i[2] === 7) && (i[3] === 4 || i[3] === 6 || i[3] === 8))
        return {
          ext: "zip",
          mime: "application/zip"
        };
      if (t([117, 115, 116, 97, 114], { offset: 257 }))
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      if (t([82, 97, 114, 33, 26, 7]) && (i[6] === 0 || i[6] === 1))
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      if (t([31, 139, 8]))
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      if (t([66, 90, 104]))
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      if (t([55, 122, 188, 175, 39, 28]))
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      if (t([120, 1]))
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      if (t([51, 103, 112, 53]) || // 3gp5
      t([0, 0, 0]) && t([102, 116, 121, 112], { offset: 4 }) && (t([109, 112, 52, 49], { offset: 8 }) || // MP41
      t([109, 112, 52, 50], { offset: 8 }) || // MP42
      t([105, 115, 111, 109], { offset: 8 }) || // ISOM
      t([105, 115, 111, 50], { offset: 8 }) || // ISO2
      t([109, 109, 112, 52], { offset: 8 }) || // MMP4
      t([77, 52, 86], { offset: 8 }) || // M4V
      t([100, 97, 115, 104], { offset: 8 })))
        return {
          ext: "mp4",
          mime: "video/mp4"
        };
      if (t([77, 84, 104, 100]))
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      if (t([26, 69, 223, 163])) {
        const n = i.subarray(4, 4100), a = n.findIndex((s, o, h) => h[o] === 66 && h[o + 1] === 130);
        if (a !== -1) {
          const s = a + 3, o = (h) => [...h].every((l, f) => n[s + f] === l.charCodeAt(0));
          if (o("matroska"))
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          if (o("webm"))
            return {
              ext: "webm",
              mime: "video/webm"
            };
        }
      }
      if (t([0, 0, 0, 20, 102, 116, 121, 112, 113, 116, 32, 32]) || t([102, 114, 101, 101], { offset: 4 }) || // Type: `free`
      t([102, 116, 121, 112, 113, 116, 32, 32], { offset: 4 }) || t([109, 100, 97, 116], { offset: 4 }) || // MJPEG
      t([109, 111, 111, 118], { offset: 4 }) || // Type: `moov`
      t([119, 105, 100, 101], { offset: 4 }))
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      if (t([82, 73, 70, 70])) {
        if (t([65, 86, 73], { offset: 8 }))
          return {
            ext: "avi",
            mime: "video/vnd.avi"
          };
        if (t([87, 65, 86, 69], { offset: 8 }))
          return {
            ext: "wav",
            mime: "audio/vnd.wave"
          };
        if (t([81, 76, 67, 77], { offset: 8 }))
          return {
            ext: "qcp",
            mime: "audio/qcelp"
          };
      }
      if (t([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        let n = 30;
        do {
          const a = readUInt64LE(i, n + 16);
          if (t([145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101], { offset: n })) {
            if (t([64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43], { offset: n + 24 }))
              return {
                ext: "wma",
                mime: "audio/x-ms-wma"
              };
            if (t([192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43], { offset: n + 24 }))
              return {
                ext: "wmv",
                mime: "video/x-ms-asf"
              };
            break;
          }
          n += a;
        } while (n + 24 <= i.length);
        return {
          ext: "asf",
          mime: "application/vnd.ms-asf"
        };
      }
      if (t([0, 0, 1, 186]) || t([0, 0, 1, 179]))
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      if (t([102, 116, 121, 112, 51, 103], { offset: 4 }))
        return {
          ext: "3gp",
          mime: "video/3gpp"
        };
      for (let n = 0; n < 2 && n < i.length - 16; n++) {
        if (t([73, 68, 51], { offset: n }) || // ID3 header
        t([255, 226], { offset: n, mask: [255, 226] }))
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        if (t([255, 228], { offset: n, mask: [255, 228] }))
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        if (t([255, 248], { offset: n, mask: [255, 252] }))
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        if (t([255, 240], { offset: n, mask: [255, 252] }))
          return {
            ext: "mp4",
            mime: "audio/mpeg"
          };
      }
      if (t([102, 116, 121, 112, 77, 52, 65], { offset: 4 }))
        return {
          // MPEG-4 layer 3 (audio)
          ext: "m4a",
          mime: "audio/mp4"
          // RFC 4337
        };
      if (t([79, 112, 117, 115, 72, 101, 97, 100], { offset: 28 }))
        return {
          ext: "opus",
          mime: "audio/opus"
        };
      if (t([79, 103, 103, 83]))
        return t([128, 116, 104, 101, 111, 114, 97], { offset: 28 }) ? {
          ext: "ogv",
          mime: "video/ogg"
        } : t([1, 118, 105, 100, 101, 111, 0], { offset: 28 }) ? {
          ext: "ogm",
          mime: "video/ogg"
        } : t([127, 70, 76, 65, 67], { offset: 28 }) ? {
          ext: "oga",
          mime: "audio/ogg"
        } : t([83, 112, 101, 101, 120, 32, 32], { offset: 28 }) ? {
          ext: "spx",
          mime: "audio/ogg"
        } : t([1, 118, 111, 114, 98, 105, 115], { offset: 28 }) ? {
          ext: "ogg",
          mime: "audio/ogg"
        } : {
          ext: "ogx",
          mime: "application/ogg"
        };
      if (t([102, 76, 97, 67]))
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      if (t([77, 65, 67, 32]))
        return {
          ext: "ape",
          mime: "audio/ape"
        };
      if (t([119, 118, 112, 107]))
        return {
          ext: "wv",
          mime: "audio/wavpack"
        };
      if (t([35, 33, 65, 77, 82, 10]))
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      if (t([37, 80, 68, 70]))
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      if (t([77, 90]))
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      if ((i[0] === 67 || i[0] === 70) && t([87, 83], { offset: 1 }))
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      if (t([123, 92, 114, 116, 102]))
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      if (t([0, 97, 115, 109]))
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      if (t([119, 79, 70, 70]) && (t([0, 1, 0, 0], { offset: 4 }) || t([79, 84, 84, 79], { offset: 4 })))
        return {
          ext: "woff",
          mime: "font/woff"
        };
      if (t([119, 79, 70, 50]) && (t([0, 1, 0, 0], { offset: 4 }) || t([79, 84, 84, 79], { offset: 4 })))
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      if (t([76, 80], { offset: 34 }) && (t([0, 0, 1], { offset: 8 }) || t([1, 0, 2], { offset: 8 }) || t([2, 0, 2], { offset: 8 })))
        return {
          ext: "eot",
          mime: "application/vnd.ms-fontobject"
        };
      if (t([0, 1, 0, 0, 0]))
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      if (t([79, 84, 84, 79, 0]))
        return {
          ext: "otf",
          mime: "font/otf"
        };
      if (t([0, 0, 1, 0]))
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      if (t([0, 0, 2, 0]))
        return {
          ext: "cur",
          mime: "image/x-icon"
        };
      if (t([70, 76, 86, 1]))
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      if (t([37, 33]))
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      if (t([253, 55, 122, 88, 90, 0]))
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      if (t([83, 81, 76, 105]))
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      if (t([78, 69, 83, 26]))
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      if (t([67, 114, 50, 52]))
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      if (t([77, 83, 67, 70]) || t([73, 83, 99, 40]))
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      if (t([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121]))
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      if (t([33, 60, 97, 114, 99, 104, 62]))
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      if (t([237, 171, 238, 219]))
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      if (t([31, 160]) || t([31, 157]))
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      if (t([76, 90, 73, 80]))
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      if (t([208, 207, 17, 224, 161, 177, 26, 225]))
        return {
          ext: "msi",
          mime: "application/x-msi"
        };
      if (t([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2]))
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      if (t([71], { offset: 4 }) && (t([71], { offset: 192 }) || t([71], { offset: 196 })))
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      if (t([66, 76, 69, 78, 68, 69, 82]))
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      if (t([66, 80, 71, 251]))
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      if (t([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
        if (t([106, 112, 50, 32], { offset: 20 }))
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        if (t([106, 112, 120, 32], { offset: 20 }))
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        if (t([106, 112, 109, 32], { offset: 20 }))
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        if (t([109, 106, 112, 50], { offset: 20 }))
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
      }
      if (t([70, 79, 82, 77]))
        return {
          ext: "aif",
          mime: "audio/aiff"
        };
      if (r("<?xml "))
        return {
          ext: "xml",
          mime: "application/xml"
        };
      if (t([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 }))
        return {
          ext: "mobi",
          mime: "application/x-mobipocket-ebook"
        };
      if (t([102, 116, 121, 112], { offset: 4 })) {
        if (t([109, 105, 102, 49], { offset: 8 }))
          return {
            ext: "heic",
            mime: "image/heif"
          };
        if (t([109, 115, 102, 49], { offset: 8 }))
          return {
            ext: "heic",
            mime: "image/heif-sequence"
          };
        if (t([104, 101, 105, 99], { offset: 8 }) || t([104, 101, 105, 120], { offset: 8 }))
          return {
            ext: "heic",
            mime: "image/heic"
          };
        if (t([104, 101, 118, 99], { offset: 8 }) || t([104, 101, 118, 120], { offset: 8 }))
          return {
            ext: "heic",
            mime: "image/heic-sequence"
          };
      }
      return t([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]) ? {
        ext: "ktx",
        mime: "image/ktx"
      } : t([68, 73, 67, 77], { offset: 128 }) ? {
        ext: "dcm",
        mime: "application/dicom"
      } : t([77, 80, 43]) ? {
        ext: "mpc",
        mime: "audio/x-musepack"
      } : t([77, 80, 67, 75]) ? {
        ext: "mpc",
        mime: "audio/x-musepack"
      } : t([66, 69, 71, 73, 78, 58]) ? {
        ext: "ics",
        mime: "text/calendar"
      } : t([103, 108, 84, 70, 2, 0, 0, 0]) ? {
        ext: "glb",
        mime: "model/gltf-binary"
      } : t([212, 195, 178, 161]) || t([161, 178, 195, 212]) ? {
        ext: "pcap",
        mime: "application/vnd.tcpdump.pcap"
      } : null;
    };
    module.exports = fileType, module.exports.default = fileType, Object.defineProperty(fileType, "minimumBytes", { value: 4100 }), module.exports.stream = (readableStream) => new Promise((resolve, reject) => {
      const stream = eval("require")("stream");
      readableStream.once("readable", () => {
        const e = new stream.PassThrough(), i = readableStream.read(module.exports.minimumBytes) || readableStream.read();
        try {
          e.fileType = fileType(i);
        } catch (t) {
          reject(t);
        }
        readableStream.unshift(i), stream.pipeline ? resolve(stream.pipeline(readableStream, e, () => {
        })) : resolve(readableStream.pipe(e));
      });
    });
  }(fileType)), fileType.exports;
}
var hasRequiredImageType;
function requireImageType() {
  if (hasRequiredImageType) return imageType$1.exports;
  hasRequiredImageType = 1;
  const e = requireFileType(), i = /* @__PURE__ */ new Set([
    "jpg",
    "png",
    "gif",
    "webp",
    "flif",
    "cr2",
    "tif",
    "bmp",
    "jxr",
    "psd",
    "ico",
    "bpg",
    "jp2",
    "jpm",
    "jpx",
    "heic",
    "cur",
    "dcm"
  ]), t = (r) => {
    const n = e(r);
    return i.has(n && n.ext) ? n : null;
  };
  return imageType$1.exports = t, imageType$1.exports.default = t, Object.defineProperty(t, "minimumBytes", { value: e.minimumBytes }), imageType$1.exports;
}
var imageTypeExports = requireImageType();
const imageType = /* @__PURE__ */ getDefaultExportFromCjs(imageTypeExports);
function guessStripByteCounts(e) {
  if (e.compression !== 1)
    throw new Error("missing mandatory StripByteCounts field in compressed image");
  const i = e.rowsPerStrip * e.width * e.samplesPerPixel * (e.bitsPerSample / 8);
  return new Array(e.stripOffsets.length).fill(i);
}
function applyHorizontalDifferencing8Bit(e, i, t) {
  let r = 0;
  for (; r < e.length; ) {
    for (let n = t; n < i * t; n += t)
      for (let a = 0; a < t; a++)
        e[r + n + a] = e[r + n + a] + e[r + n - (t - a)] & 255;
    r += i * t;
  }
}
function applyHorizontalDifferencing16Bit(e, i, t) {
  let r = 0;
  for (; r < e.length; ) {
    for (let n = t; n < i * t; n += t)
      for (let a = 0; a < t; a++)
        e[r + n + a] = e[r + n + a] + e[r + n - (t - a)] & 65535;
    r += i * t;
  }
}
const tagsById$2 = {
  33434: "ExposureTime",
  33437: "FNumber",
  34850: "ExposureProgram",
  34852: "SpectralSensitivity",
  34855: "ISOSpeedRatings",
  34856: "OECF",
  34864: "SensitivityType",
  34865: "StandardOutputSensitivity",
  34866: "RecommendedExposureIndex",
  34867: "ISOSpeed",
  34868: "ISOSpeedLatitudeyyy",
  34869: "ISOSpeedLatitudezzz",
  36864: "ExifVersion",
  36867: "DateTimeOriginal",
  36868: "DateTimeDigitized",
  37121: "ComponentsConfiguration",
  37122: "CompressedBitsPerPixel",
  37377: "ShutterSpeedValue",
  37378: "ApertureValue",
  37379: "BrightnessValue",
  37380: "ExposureBiasValue",
  37381: "MaxApertureValue",
  37382: "SubjectDistance",
  37383: "MeteringMode",
  37384: "LightSource",
  37385: "Flash",
  37386: "FocalLength",
  37396: "SubjectArea",
  37500: "MakerNote",
  37510: "UserComment",
  37520: "SubsecTime",
  37521: "SubsecTimeOriginal",
  37522: "SubsecTimeDigitized",
  40960: "FlashpixVersion",
  40961: "ColorSpace",
  40962: "PixelXDimension",
  40963: "PixelYDimension",
  40964: "RelatedSoundFile",
  41483: "FlashEnergy",
  41484: "SpatialFrequencyResponse",
  41486: "FocalPlaneXResolution",
  41487: "FocalPlaneYResolution",
  41488: "FocalPlaneResolutionUnit",
  41492: "SubjectLocation",
  41493: "ExposureIndex",
  41495: "SensingMethod",
  41728: "FileSource",
  41729: "SceneType",
  41730: "CFAPattern",
  41985: "CustomRendered",
  41986: "ExposureMode",
  41987: "WhiteBalance",
  41988: "DigitalZoomRatio",
  41989: "FocalLengthIn35mmFilm",
  41990: "SceneCaptureType",
  41991: "GainControl",
  41992: "Contrast",
  41993: "Saturation",
  41994: "Sharpness",
  41995: "DeviceSettingDescription",
  41996: "SubjectDistanceRange",
  42016: "ImageUniqueID",
  42032: "CameraOwnerName",
  42033: "BodySerialNumber",
  42034: "LensSpecification",
  42035: "LensMake",
  42036: "LensModel",
  42037: "LensSerialNumber",
  42240: "Gamma"
}, tagsByName$2 = {};
for (let e in tagsById$2)
  tagsByName$2[tagsById$2[e]] = Number(e);
const exif = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  tagsById: tagsById$2,
  tagsByName: tagsByName$2
}, Symbol.toStringTag, { value: "Module" })), tagsById$1 = {
  0: "GPSVersionID",
  1: "GPSLatitudeRef",
  2: "GPSLatitude",
  3: "GPSLongitudeRef",
  4: "GPSLongitude",
  5: "GPSAltitudeRef",
  6: "GPSAltitude",
  7: "GPSTimeStamp",
  8: "GPSSatellites",
  9: "GPSStatus",
  10: "GPSMeasureMode",
  11: "GPSDOP",
  12: "GPSSpeedRef",
  13: "GPSSpeed",
  14: "GPSTrackRef",
  15: "GPSTrack",
  16: "GPSImgDirectionRef",
  17: "GPSImgDirection",
  18: "GPSMapDatum",
  19: "GPSDestLatitudeRef",
  20: "GPSDestLatitude",
  21: "GPSDestLongitudeRef",
  22: "GPSDestLongitude",
  23: "GPSDestBearingRef",
  24: "GPSDestBearing",
  25: "GPSDestDistanceRef",
  26: "GPSDestDistance",
  27: "GPSProcessingMethod",
  28: "GPSAreaInformation",
  29: "GPSDateStamp",
  30: "GPSDifferential",
  31: "GPSHPositioningError"
}, tagsByName$1 = {};
for (let e in tagsById$1)
  tagsByName$1[tagsById$1[e]] = Number(e);
const gps = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  tagsById: tagsById$1,
  tagsByName: tagsByName$1
}, Symbol.toStringTag, { value: "Module" })), tagsById = {
  // Baseline tags
  254: "NewSubfileType",
  255: "SubfileType",
  256: "ImageWidth",
  257: "ImageLength",
  258: "BitsPerSample",
  259: "Compression",
  262: "PhotometricInterpretation",
  263: "Threshholding",
  264: "CellWidth",
  265: "CellLength",
  266: "FillOrder",
  270: "ImageDescription",
  271: "Make",
  272: "Model",
  273: "StripOffsets",
  274: "Orientation",
  277: "SamplesPerPixel",
  278: "RowsPerStrip",
  279: "StripByteCounts",
  280: "MinSampleValue",
  281: "MaxSampleValue",
  282: "XResolution",
  283: "YResolution",
  284: "PlanarConfiguration",
  288: "FreeOffsets",
  289: "FreeByteCounts",
  290: "GrayResponseUnit",
  291: "GrayResponseCurve",
  296: "ResolutionUnit",
  305: "Software",
  306: "DateTime",
  315: "Artist",
  316: "HostComputer",
  320: "ColorMap",
  338: "ExtraSamples",
  33432: "Copyright",
  // Extension tags
  269: "DocumentName",
  285: "PageName",
  286: "XPosition",
  287: "YPosition",
  292: "T4Options",
  293: "T6Options",
  297: "PageNumber",
  301: "TransferFunction",
  317: "Predictor",
  318: "WhitePoint",
  319: "PrimaryChromaticities",
  321: "HalftoneHints",
  322: "TileWidth",
  323: "TileLength",
  324: "TileOffsets",
  325: "TileByteCounts",
  326: "BadFaxLines",
  327: "CleanFaxData",
  328: "ConsecutiveBadFaxLines",
  330: "SubIFDs",
  332: "InkSet",
  333: "InkNames",
  334: "NumberOfInks",
  336: "DotRange",
  337: "TargetPrinter",
  339: "SampleFormat",
  340: "SMinSampleValue",
  341: "SMaxSampleValue",
  342: "TransferRange",
  343: "ClipPath",
  344: "XClipPathUnits",
  345: "YClipPathUnits",
  346: "Indexed",
  347: "JPEGTables",
  351: "OPIProxy",
  400: "GlobalParametersIFD",
  401: "ProfileType",
  402: "FaxProfile",
  403: "CodingMethods",
  404: "VersionYear",
  405: "ModeNumber",
  433: "Decode",
  434: "DefaultImageColor",
  512: "JPEGProc",
  513: "JPEGInterchangeFormat",
  514: "JPEGInterchangeFormatLength",
  515: "JPEGRestartInterval",
  517: "JPEGLosslessPredictors",
  518: "JPEGPointTransforms",
  519: "JPEGQTables",
  520: "JPEGDCTables",
  521: "JPEGACTables",
  529: "YCbCrCoefficients",
  530: "YCbCrSubSampling",
  531: "YCbCrPositioning",
  532: "ReferenceBlackWhite",
  559: "StripRowCounts",
  700: "XMP",
  32781: "ImageID",
  34732: "ImageLayer",
  // Private tags
  32932: "WangAnnotatio",
  33445: "MDFileTag",
  33446: "MDScalePixel",
  33447: "MDColorTable",
  33448: "MDLabName",
  33449: "MDSampleInfo",
  33450: "MDPrepDate",
  33451: "MDPrepTime",
  33452: "MDFileUnits",
  33550: "ModelPixelScaleTag",
  33723: "IPTC",
  33918: "INGRPacketDataTag",
  33919: "INGRFlagRegisters",
  33920: "IrasBTransformationMatrix",
  33922: "ModelTiepointTag",
  34264: "ModelTransformationTag",
  34377: "Photoshop",
  34665: "ExifIFD",
  34675: "ICCProfile",
  34735: "GeoKeyDirectoryTag",
  34736: "GeoDoubleParamsTag",
  34737: "GeoAsciiParamsTag",
  34853: "GPSIFD",
  34908: "HylaFAXFaxRecvParams",
  34909: "HylaFAXFaxSubAddress",
  34910: "HylaFAXFaxRecvTime",
  37724: "ImageSourceData",
  40965: "InteroperabilityIFD",
  42112: "GDAL_METADATA",
  42113: "GDAL_NODATA",
  50215: "OceScanjobDescription",
  50216: "OceApplicationSelector",
  50217: "OceIdentificationNumber",
  50218: "OceImageLogicCharacteristics",
  50706: "DNGVersion",
  50707: "DNGBackwardVersion",
  50708: "UniqueCameraModel",
  50709: "LocalizedCameraModel",
  50710: "CFAPlaneColor",
  50711: "CFALayout",
  50712: "LinearizationTable",
  50713: "BlackLevelRepeatDim",
  50714: "BlackLevel",
  50715: "BlackLevelDeltaH",
  50716: "BlackLevelDeltaV",
  50717: "WhiteLevel",
  50718: "DefaultScale",
  50719: "DefaultCropOrigin",
  50720: "DefaultCropSize",
  50721: "ColorMatrix1",
  50722: "ColorMatrix2",
  50723: "CameraCalibration1",
  50724: "CameraCalibration2",
  50725: "ReductionMatrix1",
  50726: "ReductionMatrix2",
  50727: "AnalogBalance",
  50728: "AsShotNeutral",
  50729: "AsShotWhiteXY",
  50730: "BaselineExposure",
  50731: "BaselineNoise",
  50732: "BaselineSharpness",
  50733: "BayerGreenSplit",
  50734: "LinearResponseLimit",
  50735: "CameraSerialNumber",
  50736: "LensInfo",
  50737: "ChromaBlurRadius",
  50738: "AntiAliasStrength",
  50740: "DNGPrivateData",
  50741: "MakerNoteSafety",
  50778: "CalibrationIlluminant1",
  50779: "CalibrationIlluminant2",
  50780: "BestQualityScale",
  50784: "AliasLayerMetadata"
}, tagsByName = {};
for (let e in tagsById)
  tagsByName[tagsById[e]] = Number(e);
const standard = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  tagsById,
  tagsByName
}, Symbol.toStringTag, { value: "Module" })), tags = {
  standard,
  exif,
  gps
};
class IFD {
  constructor(i) {
    if (!i)
      throw new Error("missing kind");
    this.data = new Uint8Array(), this.fields = /* @__PURE__ */ new Map(), this.kind = i, this._hasMap = !1, this._map = {};
  }
  get(i) {
    if (typeof i == "number")
      return this.fields.get(i);
    if (typeof i == "string")
      return this.fields.get(tags[this.kind].tagsByName[i]);
    throw new Error("expected a number or string");
  }
  get map() {
    if (!this._hasMap) {
      const i = tags[this.kind].tagsById;
      for (let t of this.fields.keys())
        i[t] && (this._map[i[t]] = this.fields.get(t));
      this._hasMap = !0;
    }
    return this._map;
  }
}
let types = /* @__PURE__ */ new Map([
  [1, [1, readByte]],
  [2, [1, readASCII]],
  [3, [2, readShort]],
  [4, [4, readLong]],
  [5, [8, readRational]],
  [6, [1, readSByte]],
  [7, [1, readByte]],
  [8, [2, readSShort]],
  [9, [4, readSLong]],
  [10, [8, readSRational]],
  [11, [4, readFloat]],
  [12, [8, readDouble]]
  // DOUBLE
]);
function getByteLength(e, i) {
  const t = types.get(e);
  if (!t)
    throw new Error(`type not found: ${e}`);
  return t[0] * i;
}
function readData(e, i, t) {
  const r = types.get(i);
  if (!r)
    throw new Error(`type not found: ${i}`);
  return r[1](e, t);
}
function readByte(e, i) {
  if (i === 1)
    return e.readUint8();
  let t = new Uint8Array(i);
  for (let r = 0; r < i; r++)
    t[r] = e.readUint8();
  return t;
}
function readASCII(e, i) {
  let t = [], r = "";
  for (let n = 0; n < i; n++) {
    let a = String.fromCharCode(e.readUint8());
    a === "\0" ? (t.push(r), r = "") : r += a;
  }
  return t.length === 1 ? t[0] : t;
}
function readShort(e, i) {
  if (i === 1)
    return e.readUint16();
  let t = new Uint16Array(i);
  for (let r = 0; r < i; r++)
    t[r] = e.readUint16();
  return t;
}
function readLong(e, i) {
  if (i === 1)
    return e.readUint32();
  let t = new Uint32Array(i);
  for (let r = 0; r < i; r++)
    t[r] = e.readUint32();
  return t;
}
function readRational(e, i) {
  if (i === 1)
    return e.readUint32() / e.readUint32();
  let t = new Array(i);
  for (let r = 0; r < i; r++)
    t[r] = e.readUint32() / e.readUint32();
  return t;
}
function readSByte(e, i) {
  if (i === 1)
    return e.readInt8();
  let t = new Int8Array(i);
  for (let r = 0; r < i; r++)
    t[r] = e.readInt8();
  return t;
}
function readSShort(e, i) {
  if (i === 1)
    return e.readInt16();
  let t = new Int16Array(i);
  for (let r = 0; r < i; r++)
    t[r] = e.readInt16();
  return t;
}
function readSLong(e, i) {
  if (i === 1)
    return e.readInt32();
  let t = new Int32Array(i);
  for (let r = 0; r < i; r++)
    t[r] = e.readInt32();
  return t;
}
function readSRational(e, i) {
  if (i === 1)
    return e.readInt32() / e.readInt32();
  let t = new Array(i);
  for (let r = 0; r < i; r++)
    t[r] = e.readInt32() / e.readInt32();
  return t;
}
function readFloat(e, i) {
  if (i === 1)
    return e.readFloat32();
  let t = new Float32Array(i);
  for (let r = 0; r < i; r++)
    t[r] = e.readFloat32();
  return t;
}
function readDouble(e, i) {
  if (i === 1)
    return e.readFloat64();
  let t = new Float64Array(i);
  for (let r = 0; r < i; r++)
    t[r] = e.readFloat64();
  return t;
}
const CLEAR_CODE = 256, EOI_CODE = 257, TABLE_START = 258, MIN_BIT_LENGTH = 9;
let stringTable = [];
function initializeStringTable() {
  if (stringTable.length === 0) {
    for (let i = 0; i < 256; i++)
      stringTable.push([i]);
    const e = [];
    for (let i = 256; i < 4096; i++)
      stringTable.push(e);
  }
}
const andTable = [511, 1023, 2047, 4095], bitJumps = [0, 0, 0, 0, 0, 0, 0, 0, 0, 511, 1023, 2047, 4095];
class LzwDecoder {
  constructor(i) {
    this.nextData = 0, this.nextBits = 0, this.bytePointer = 0, this.tableLength = TABLE_START, this.currentBitLength = MIN_BIT_LENGTH, this.stripArray = new Uint8Array(i.buffer, i.byteOffset, i.byteLength), this.outData = new IOBuffer(i.byteLength), this.initializeTable();
  }
  decode() {
    let i = 0, t = 0;
    for (; (i = this.getNextCode()) !== EOI_CODE; )
      if (i === CLEAR_CODE) {
        if (this.initializeTable(), i = this.getNextCode(), i === EOI_CODE)
          break;
        this.writeString(this.stringFromCode(i)), t = i;
      } else if (this.isInTable(i))
        this.writeString(this.stringFromCode(i)), this.addStringToTable(this.stringFromCode(t).concat(this.stringFromCode(i)[0])), t = i;
      else {
        const n = this.stringFromCode(t).concat(this.stringFromCode(t)[0]);
        this.writeString(n), this.addStringToTable(n), t = i;
      }
    const r = this.outData.toArray();
    return new DataView(r.buffer, r.byteOffset, r.byteLength);
  }
  initializeTable() {
    initializeStringTable(), this.tableLength = TABLE_START, this.currentBitLength = MIN_BIT_LENGTH;
  }
  writeString(i) {
    this.outData.writeBytes(i);
  }
  stringFromCode(i) {
    return stringTable[i];
  }
  isInTable(i) {
    return i < this.tableLength;
  }
  addStringToTable(i) {
    if (stringTable[this.tableLength++] = i, stringTable.length > 4096)
      throw stringTable = [], new Error("LZW decoding error. Please open an issue at https://github.com/image-js/tiff/issues/new/choose (include a test image).");
    this.tableLength === bitJumps[this.currentBitLength] && this.currentBitLength++;
  }
  getNextCode() {
    this.nextData = this.nextData << 8 | this.stripArray[this.bytePointer++] & 255, this.nextBits += 8, this.nextBits < this.currentBitLength && (this.nextData = this.nextData << 8 | this.stripArray[this.bytePointer++] & 255, this.nextBits += 8);
    const i = this.nextData >> this.nextBits - this.currentBitLength & andTable[this.currentBitLength - 9];
    return this.nextBits -= this.currentBitLength, this.bytePointer > this.stripArray.length ? 257 : i;
  }
}
function decompressLzw(e) {
  return new LzwDecoder(e).decode();
}
const dateTimeRegex = /^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})$/;
class TiffIfd extends IFD {
  constructor() {
    super("standard");
  }
  // Custom fields
  get size() {
    return this.width * this.height;
  }
  get width() {
    return this.imageWidth;
  }
  get height() {
    return this.imageLength;
  }
  get components() {
    return this.samplesPerPixel;
  }
  get date() {
    let i = /* @__PURE__ */ new Date(), t = dateTimeRegex.exec(this.dateTime);
    if (t === null)
      throw new Error(`invalid dateTime: ${this.dateTime}`);
    return i.setFullYear(Number(t[1]), Number(t[2]) - 1, Number(t[3])), i.setHours(Number(t[4]), Number(t[5]), Number(t[6])), i;
  }
  // IFD fields
  get newSubfileType() {
    return this.get("NewSubfileType");
  }
  get imageWidth() {
    return this.get("ImageWidth");
  }
  get imageLength() {
    return this.get("ImageLength");
  }
  get bitsPerSample() {
    const i = this.get("BitsPerSample");
    return i && typeof i != "number" ? i[0] : i;
  }
  get alpha() {
    const i = this.extraSamples;
    return i ? i[0] !== 0 : !1;
  }
  get associatedAlpha() {
    const i = this.extraSamples;
    return i ? i[0] === 1 : !1;
  }
  get extraSamples() {
    return alwaysArray(this.get("ExtraSamples"));
  }
  get compression() {
    return this.get("Compression") || 1;
  }
  get type() {
    return this.get("PhotometricInterpretation");
  }
  get fillOrder() {
    return this.get("FillOrder") || 1;
  }
  get documentName() {
    return this.get("DocumentName");
  }
  get imageDescription() {
    return this.get("ImageDescription");
  }
  get stripOffsets() {
    return alwaysArray(this.get("StripOffsets"));
  }
  get orientation() {
    return this.get("Orientation");
  }
  get samplesPerPixel() {
    return this.get("SamplesPerPixel") || 1;
  }
  get rowsPerStrip() {
    return this.get("RowsPerStrip");
  }
  get stripByteCounts() {
    return alwaysArray(this.get("StripByteCounts"));
  }
  get minSampleValue() {
    return this.get("MinSampleValue") || 0;
  }
  get maxSampleValue() {
    return this.get("MaxSampleValue") || Math.pow(2, this.bitsPerSample) - 1;
  }
  get xResolution() {
    return this.get("XResolution");
  }
  get yResolution() {
    return this.get("YResolution");
  }
  get planarConfiguration() {
    return this.get("PlanarConfiguration") || 1;
  }
  get resolutionUnit() {
    return this.get("ResolutionUnit") || 2;
  }
  get dateTime() {
    return this.get("DateTime");
  }
  get predictor() {
    return this.get("Predictor") || 1;
  }
  get sampleFormat() {
    return this.get("SampleFormat") || 1;
  }
  get sMinSampleValue() {
    return this.get("SMinSampleValue") || this.minSampleValue;
  }
  get sMaxSampleValue() {
    return this.get("SMaxSampleValue") || this.maxSampleValue;
  }
  get palette() {
    const i = 2 ** this.bitsPerSample, t = this.get("ColorMap");
    if (!t)
      return;
    if (t.length !== 3 * i)
      throw new Error(`ColorMap size must be ${i}`);
    const r = [];
    for (let n = 0; n < i; n++)
      r.push([
        t[n],
        t[n + i],
        t[n + 2 * i]
      ]);
    return r;
  }
}
function alwaysArray(e) {
  return typeof e == "number" ? [e] : e;
}
function zero$1(e) {
  let i = e.length;
  for (; --i >= 0; )
    e[i] = 0;
}
const MIN_MATCH$1 = 3, MAX_MATCH$1 = 258, LENGTH_CODES$1 = 29, LITERALS$1 = 256, L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1, D_CODES$1 = 30, DIST_CODE_LEN = 512, static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
const adler32 = (e, i, t, r) => {
  let n = e & 65535 | 0, a = e >>> 16 & 65535 | 0, s = 0;
  for (; t !== 0; ) {
    s = t > 2e3 ? 2e3 : t, t -= s;
    do
      n = n + i[r++] | 0, a = a + n | 0;
    while (--s);
    n %= 65521, a %= 65521;
  }
  return n | a << 16 | 0;
};
var adler32_1$1 = adler32;
const makeTable = () => {
  let e, i = [];
  for (var t = 0; t < 256; t++) {
    e = t;
    for (var r = 0; r < 8; r++)
      e = e & 1 ? 3988292384 ^ e >>> 1 : e >>> 1;
    i[t] = e;
  }
  return i;
}, crcTable = new Uint32Array(makeTable()), crc32 = (e, i, t, r) => {
  const n = crcTable, a = r + t;
  e ^= -1;
  for (let s = r; s < a; s++)
    e = e >>> 8 ^ n[(e ^ i[s]) & 255];
  return e ^ -1;
};
var crc32_1$1 = crc32, messages$1 = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const _has = (e, i) => Object.prototype.hasOwnProperty.call(e, i);
var assign = function(e) {
  const i = Array.prototype.slice.call(arguments, 1);
  for (; i.length; ) {
    const t = i.shift();
    if (t) {
      if (typeof t != "object")
        throw new TypeError(t + "must be non-object");
      for (const r in t)
        _has(t, r) && (e[r] = t[r]);
    }
  }
  return e;
}, flattenChunks = (e) => {
  let i = 0;
  for (let r = 0, n = e.length; r < n; r++)
    i += e[r].length;
  const t = new Uint8Array(i);
  for (let r = 0, n = 0, a = e.length; r < a; r++) {
    let s = e[r];
    t.set(s, n), n += s.length;
  }
  return t;
}, common$1 = {
  assign,
  flattenChunks
};
let STR_APPLY_UIA_OK = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (e) {
  STR_APPLY_UIA_OK = !1;
}
const _utf8len = new Uint8Array(256);
for (let e = 0; e < 256; e++)
  _utf8len[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (e) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(e);
  let i, t, r, n, a, s = e.length, o = 0;
  for (n = 0; n < s; n++)
    t = e.charCodeAt(n), (t & 64512) === 55296 && n + 1 < s && (r = e.charCodeAt(n + 1), (r & 64512) === 56320 && (t = 65536 + (t - 55296 << 10) + (r - 56320), n++)), o += t < 128 ? 1 : t < 2048 ? 2 : t < 65536 ? 3 : 4;
  for (i = new Uint8Array(o), a = 0, n = 0; a < o; n++)
    t = e.charCodeAt(n), (t & 64512) === 55296 && n + 1 < s && (r = e.charCodeAt(n + 1), (r & 64512) === 56320 && (t = 65536 + (t - 55296 << 10) + (r - 56320), n++)), t < 128 ? i[a++] = t : t < 2048 ? (i[a++] = 192 | t >>> 6, i[a++] = 128 | t & 63) : t < 65536 ? (i[a++] = 224 | t >>> 12, i[a++] = 128 | t >>> 6 & 63, i[a++] = 128 | t & 63) : (i[a++] = 240 | t >>> 18, i[a++] = 128 | t >>> 12 & 63, i[a++] = 128 | t >>> 6 & 63, i[a++] = 128 | t & 63);
  return i;
};
const buf2binstring = (e, i) => {
  if (i < 65534 && e.subarray && STR_APPLY_UIA_OK)
    return String.fromCharCode.apply(null, e.length === i ? e : e.subarray(0, i));
  let t = "";
  for (let r = 0; r < i; r++)
    t += String.fromCharCode(e[r]);
  return t;
};
var buf2string = (e, i) => {
  const t = i || e.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(e.subarray(0, i));
  let r, n;
  const a = new Array(t * 2);
  for (n = 0, r = 0; r < t; ) {
    let s = e[r++];
    if (s < 128) {
      a[n++] = s;
      continue;
    }
    let o = _utf8len[s];
    if (o > 4) {
      a[n++] = 65533, r += o - 1;
      continue;
    }
    for (s &= o === 2 ? 31 : o === 3 ? 15 : 7; o > 1 && r < t; )
      s = s << 6 | e[r++] & 63, o--;
    if (o > 1) {
      a[n++] = 65533;
      continue;
    }
    s < 65536 ? a[n++] = s : (s -= 65536, a[n++] = 55296 | s >> 10 & 1023, a[n++] = 56320 | s & 1023);
  }
  return buf2binstring(a, n);
}, utf8border = (e, i) => {
  i = i || e.length, i > e.length && (i = e.length);
  let t = i - 1;
  for (; t >= 0 && (e[t] & 192) === 128; )
    t--;
  return t < 0 || t === 0 ? i : t + _utf8len[e[t]] > i ? t : i;
}, strings$1 = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var zstream$1 = ZStream;
const BAD$1 = 16209, TYPE$1 = 16191;
var inffast$1 = function e(i, t) {
  let r, n, a, s, o, h, l, f, b, w, g, E, k, A, T, C, D, $, P, z, B, F, O, N;
  const G = i.state;
  r = i.next_in, O = i.input, n = r + (i.avail_in - 5), a = i.next_out, N = i.output, s = a - (t - i.avail_out), o = a + (i.avail_out - 257), h = G.dmax, l = G.wsize, f = G.whave, b = G.wnext, w = G.window, g = G.hold, E = G.bits, k = G.lencode, A = G.distcode, T = (1 << G.lenbits) - 1, C = (1 << G.distbits) - 1;
  e:
    do {
      E < 15 && (g += O[r++] << E, E += 8, g += O[r++] << E, E += 8), D = k[g & T];
      t:
        for (; ; ) {
          if ($ = D >>> 24, g >>>= $, E -= $, $ = D >>> 16 & 255, $ === 0)
            N[a++] = D & 65535;
          else if ($ & 16) {
            P = D & 65535, $ &= 15, $ && (E < $ && (g += O[r++] << E, E += 8), P += g & (1 << $) - 1, g >>>= $, E -= $), E < 15 && (g += O[r++] << E, E += 8, g += O[r++] << E, E += 8), D = A[g & C];
            i:
              for (; ; ) {
                if ($ = D >>> 24, g >>>= $, E -= $, $ = D >>> 16 & 255, $ & 16) {
                  if (z = D & 65535, $ &= 15, E < $ && (g += O[r++] << E, E += 8, E < $ && (g += O[r++] << E, E += 8)), z += g & (1 << $) - 1, z > h) {
                    i.msg = "invalid distance too far back", G.mode = BAD$1;
                    break e;
                  }
                  if (g >>>= $, E -= $, $ = a - s, z > $) {
                    if ($ = z - $, $ > f && G.sane) {
                      i.msg = "invalid distance too far back", G.mode = BAD$1;
                      break e;
                    }
                    if (B = 0, F = w, b === 0) {
                      if (B += l - $, $ < P) {
                        P -= $;
                        do
                          N[a++] = w[B++];
                        while (--$);
                        B = a - z, F = N;
                      }
                    } else if (b < $) {
                      if (B += l + b - $, $ -= b, $ < P) {
                        P -= $;
                        do
                          N[a++] = w[B++];
                        while (--$);
                        if (B = 0, b < P) {
                          $ = b, P -= $;
                          do
                            N[a++] = w[B++];
                          while (--$);
                          B = a - z, F = N;
                        }
                      }
                    } else if (B += b - $, $ < P) {
                      P -= $;
                      do
                        N[a++] = w[B++];
                      while (--$);
                      B = a - z, F = N;
                    }
                    for (; P > 2; )
                      N[a++] = F[B++], N[a++] = F[B++], N[a++] = F[B++], P -= 3;
                    P && (N[a++] = F[B++], P > 1 && (N[a++] = F[B++]));
                  } else {
                    B = a - z;
                    do
                      N[a++] = N[B++], N[a++] = N[B++], N[a++] = N[B++], P -= 3;
                    while (P > 2);
                    P && (N[a++] = N[B++], P > 1 && (N[a++] = N[B++]));
                  }
                } else if (($ & 64) === 0) {
                  D = A[(D & 65535) + (g & (1 << $) - 1)];
                  continue i;
                } else {
                  i.msg = "invalid distance code", G.mode = BAD$1;
                  break e;
                }
                break;
              }
          } else if (($ & 64) === 0) {
            D = k[(D & 65535) + (g & (1 << $) - 1)];
            continue t;
          } else if ($ & 32) {
            G.mode = TYPE$1;
            break e;
          } else {
            i.msg = "invalid literal/length code", G.mode = BAD$1;
            break e;
          }
          break;
        }
    } while (r < n && a < o);
  P = E >> 3, r -= P, E -= P << 3, g &= (1 << E) - 1, i.next_in = r, i.next_out = a, i.avail_in = r < n ? 5 + (n - r) : 5 - (r - n), i.avail_out = a < o ? 257 + (o - a) : 257 - (a - o), G.hold = g, G.bits = E;
};
const MAXBITS = 15, ENOUGH_LENS$1 = 852, ENOUGH_DISTS$1 = 592, CODES$1 = 0, LENS$1 = 1, DISTS$1 = 2, lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]), lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]), dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]), dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]), inflate_table = (e, i, t, r, n, a, s, o) => {
  const h = o.bits;
  let l = 0, f = 0, b = 0, w = 0, g = 0, E = 0, k = 0, A = 0, T = 0, C = 0, D, $, P, z, B, F = null, O;
  const N = new Uint16Array(MAXBITS + 1), G = new Uint16Array(MAXBITS + 1);
  let V = null, J, Q, W;
  for (l = 0; l <= MAXBITS; l++)
    N[l] = 0;
  for (f = 0; f < r; f++)
    N[i[t + f]]++;
  for (g = h, w = MAXBITS; w >= 1 && N[w] === 0; w--)
    ;
  if (g > w && (g = w), w === 0)
    return n[a++] = 1 << 24 | 64 << 16 | 0, n[a++] = 1 << 24 | 64 << 16 | 0, o.bits = 1, 0;
  for (b = 1; b < w && N[b] === 0; b++)
    ;
  for (g < b && (g = b), A = 1, l = 1; l <= MAXBITS; l++)
    if (A <<= 1, A -= N[l], A < 0)
      return -1;
  if (A > 0 && (e === CODES$1 || w !== 1))
    return -1;
  for (G[1] = 0, l = 1; l < MAXBITS; l++)
    G[l + 1] = G[l] + N[l];
  for (f = 0; f < r; f++)
    i[t + f] !== 0 && (s[G[i[t + f]]++] = f);
  if (e === CODES$1 ? (F = V = s, O = 20) : e === LENS$1 ? (F = lbase, V = lext, O = 257) : (F = dbase, V = dext, O = 0), C = 0, f = 0, l = b, B = a, E = g, k = 0, P = -1, T = 1 << g, z = T - 1, e === LENS$1 && T > ENOUGH_LENS$1 || e === DISTS$1 && T > ENOUGH_DISTS$1)
    return 1;
  for (; ; ) {
    J = l - k, s[f] + 1 < O ? (Q = 0, W = s[f]) : s[f] >= O ? (Q = V[s[f] - O], W = F[s[f] - O]) : (Q = 96, W = 0), D = 1 << l - k, $ = 1 << E, b = $;
    do
      $ -= D, n[B + (C >> k) + $] = J << 24 | Q << 16 | W | 0;
    while ($ !== 0);
    for (D = 1 << l - 1; C & D; )
      D >>= 1;
    if (D !== 0 ? (C &= D - 1, C += D) : C = 0, f++, --N[l] === 0) {
      if (l === w)
        break;
      l = i[t + s[f]];
    }
    if (l > g && (C & z) !== P) {
      for (k === 0 && (k = g), B += b, E = l - k, A = 1 << E; E + k < w && (A -= N[E + k], !(A <= 0)); )
        E++, A <<= 1;
      if (T += 1 << E, e === LENS$1 && T > ENOUGH_LENS$1 || e === DISTS$1 && T > ENOUGH_DISTS$1)
        return 1;
      P = C & z, n[P] = g << 24 | E << 16 | B - a | 0;
    }
  }
  return C !== 0 && (n[B + C] = l - k << 24 | 64 << 16 | 0), o.bits = g, 0;
};
var inftrees$1 = inflate_table;
const CODES = 0, LENS = 1, DISTS = 2, {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2, HEAD = 16180, FLAGS = 16181, TIME = 16182, OS = 16183, EXLEN = 16184, EXTRA = 16185, NAME = 16186, COMMENT = 16187, HCRC = 16188, DICTID = 16189, DICT = 16190, TYPE = 16191, TYPEDO = 16192, STORED = 16193, COPY_ = 16194, COPY = 16195, TABLE = 16196, LENLENS = 16197, CODELENS = 16198, LEN_ = 16199, LEN = 16200, LENEXT = 16201, DIST = 16202, DISTEXT = 16203, MATCH = 16204, LIT = 16205, CHECK = 16206, LENGTH = 16207, DONE = 16208, BAD = 16209, MEM = 16210, SYNC = 16211, ENOUGH_LENS = 852, ENOUGH_DISTS = 592, MAX_WBITS = 15, DEF_WBITS = MAX_WBITS, zswap32 = (e) => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((e & 65280) << 8) + ((e & 255) << 24);
function InflateState() {
  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const inflateStateCheck = (e) => {
  if (!e)
    return 1;
  const i = e.state;
  return !i || i.strm !== e || i.mode < HEAD || i.mode > SYNC ? 1 : 0;
}, inflateResetKeep = (e) => {
  if (inflateStateCheck(e))
    return Z_STREAM_ERROR$1;
  const i = e.state;
  return e.total_in = e.total_out = i.total = 0, e.msg = "", i.wrap && (e.adler = i.wrap & 1), i.mode = HEAD, i.last = 0, i.havedict = 0, i.flags = -1, i.dmax = 32768, i.head = null, i.hold = 0, i.bits = 0, i.lencode = i.lendyn = new Int32Array(ENOUGH_LENS), i.distcode = i.distdyn = new Int32Array(ENOUGH_DISTS), i.sane = 1, i.back = -1, Z_OK$1;
}, inflateReset = (e) => {
  if (inflateStateCheck(e))
    return Z_STREAM_ERROR$1;
  const i = e.state;
  return i.wsize = 0, i.whave = 0, i.wnext = 0, inflateResetKeep(e);
}, inflateReset2 = (e, i) => {
  let t;
  if (inflateStateCheck(e))
    return Z_STREAM_ERROR$1;
  const r = e.state;
  return i < 0 ? (t = 0, i = -i) : (t = (i >> 4) + 5, i < 48 && (i &= 15)), i && (i < 8 || i > 15) ? Z_STREAM_ERROR$1 : (r.window !== null && r.wbits !== i && (r.window = null), r.wrap = t, r.wbits = i, inflateReset(e));
}, inflateInit2 = (e, i) => {
  if (!e)
    return Z_STREAM_ERROR$1;
  const t = new InflateState();
  e.state = t, t.strm = e, t.window = null, t.mode = HEAD;
  const r = inflateReset2(e, i);
  return r !== Z_OK$1 && (e.state = null), r;
}, inflateInit = (e) => inflateInit2(e, DEF_WBITS);
let virgin = !0, lenfix, distfix;
const fixedtables = (e) => {
  if (virgin) {
    lenfix = new Int32Array(512), distfix = new Int32Array(32);
    let i = 0;
    for (; i < 144; )
      e.lens[i++] = 8;
    for (; i < 256; )
      e.lens[i++] = 9;
    for (; i < 280; )
      e.lens[i++] = 7;
    for (; i < 288; )
      e.lens[i++] = 8;
    for (inftrees$1(LENS, e.lens, 0, 288, lenfix, 0, e.work, { bits: 9 }), i = 0; i < 32; )
      e.lens[i++] = 5;
    inftrees$1(DISTS, e.lens, 0, 32, distfix, 0, e.work, { bits: 5 }), virgin = !1;
  }
  e.lencode = lenfix, e.lenbits = 9, e.distcode = distfix, e.distbits = 5;
}, updatewindow = (e, i, t, r) => {
  let n;
  const a = e.state;
  return a.window === null && (a.wsize = 1 << a.wbits, a.wnext = 0, a.whave = 0, a.window = new Uint8Array(a.wsize)), r >= a.wsize ? (a.window.set(i.subarray(t - a.wsize, t), 0), a.wnext = 0, a.whave = a.wsize) : (n = a.wsize - a.wnext, n > r && (n = r), a.window.set(i.subarray(t - r, t - r + n), a.wnext), r -= n, r ? (a.window.set(i.subarray(t - r, t), 0), a.wnext = r, a.whave = a.wsize) : (a.wnext += n, a.wnext === a.wsize && (a.wnext = 0), a.whave < a.wsize && (a.whave += n))), 0;
}, inflate$2 = (e, i) => {
  let t, r, n, a, s, o, h, l, f, b, w, g, E, k, A = 0, T, C, D, $, P, z, B, F;
  const O = new Uint8Array(4);
  let N, G;
  const V = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(e) || !e.output || !e.input && e.avail_in !== 0)
    return Z_STREAM_ERROR$1;
  t = e.state, t.mode === TYPE && (t.mode = TYPEDO), s = e.next_out, n = e.output, h = e.avail_out, a = e.next_in, r = e.input, o = e.avail_in, l = t.hold, f = t.bits, b = o, w = h, F = Z_OK$1;
  e:
    for (; ; )
      switch (t.mode) {
        case HEAD:
          if (t.wrap === 0) {
            t.mode = TYPEDO;
            break;
          }
          for (; f < 16; ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          if (t.wrap & 2 && l === 35615) {
            t.wbits === 0 && (t.wbits = 15), t.check = 0, O[0] = l & 255, O[1] = l >>> 8 & 255, t.check = crc32_1$1(t.check, O, 2, 0), l = 0, f = 0, t.mode = FLAGS;
            break;
          }
          if (t.head && (t.head.done = !1), !(t.wrap & 1) || /* check if zlib header allowed */
          (((l & 255) << 8) + (l >> 8)) % 31) {
            e.msg = "incorrect header check", t.mode = BAD;
            break;
          }
          if ((l & 15) !== Z_DEFLATED) {
            e.msg = "unknown compression method", t.mode = BAD;
            break;
          }
          if (l >>>= 4, f -= 4, B = (l & 15) + 8, t.wbits === 0 && (t.wbits = B), B > 15 || B > t.wbits) {
            e.msg = "invalid window size", t.mode = BAD;
            break;
          }
          t.dmax = 1 << t.wbits, t.flags = 0, e.adler = t.check = 1, t.mode = l & 512 ? DICTID : TYPE, l = 0, f = 0;
          break;
        case FLAGS:
          for (; f < 16; ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          if (t.flags = l, (t.flags & 255) !== Z_DEFLATED) {
            e.msg = "unknown compression method", t.mode = BAD;
            break;
          }
          if (t.flags & 57344) {
            e.msg = "unknown header flags set", t.mode = BAD;
            break;
          }
          t.head && (t.head.text = l >> 8 & 1), t.flags & 512 && t.wrap & 4 && (O[0] = l & 255, O[1] = l >>> 8 & 255, t.check = crc32_1$1(t.check, O, 2, 0)), l = 0, f = 0, t.mode = TIME;
        /* falls through */
        case TIME:
          for (; f < 32; ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          t.head && (t.head.time = l), t.flags & 512 && t.wrap & 4 && (O[0] = l & 255, O[1] = l >>> 8 & 255, O[2] = l >>> 16 & 255, O[3] = l >>> 24 & 255, t.check = crc32_1$1(t.check, O, 4, 0)), l = 0, f = 0, t.mode = OS;
        /* falls through */
        case OS:
          for (; f < 16; ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          t.head && (t.head.xflags = l & 255, t.head.os = l >> 8), t.flags & 512 && t.wrap & 4 && (O[0] = l & 255, O[1] = l >>> 8 & 255, t.check = crc32_1$1(t.check, O, 2, 0)), l = 0, f = 0, t.mode = EXLEN;
        /* falls through */
        case EXLEN:
          if (t.flags & 1024) {
            for (; f < 16; ) {
              if (o === 0)
                break e;
              o--, l += r[a++] << f, f += 8;
            }
            t.length = l, t.head && (t.head.extra_len = l), t.flags & 512 && t.wrap & 4 && (O[0] = l & 255, O[1] = l >>> 8 & 255, t.check = crc32_1$1(t.check, O, 2, 0)), l = 0, f = 0;
          } else t.head && (t.head.extra = null);
          t.mode = EXTRA;
        /* falls through */
        case EXTRA:
          if (t.flags & 1024 && (g = t.length, g > o && (g = o), g && (t.head && (B = t.head.extra_len - t.length, t.head.extra || (t.head.extra = new Uint8Array(t.head.extra_len)), t.head.extra.set(
            r.subarray(
              a,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              a + g
            ),
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            B
          )), t.flags & 512 && t.wrap & 4 && (t.check = crc32_1$1(t.check, r, g, a)), o -= g, a += g, t.length -= g), t.length))
            break e;
          t.length = 0, t.mode = NAME;
        /* falls through */
        case NAME:
          if (t.flags & 2048) {
            if (o === 0)
              break e;
            g = 0;
            do
              B = r[a + g++], t.head && B && t.length < 65536 && (t.head.name += String.fromCharCode(B));
            while (B && g < o);
            if (t.flags & 512 && t.wrap & 4 && (t.check = crc32_1$1(t.check, r, g, a)), o -= g, a += g, B)
              break e;
          } else t.head && (t.head.name = null);
          t.length = 0, t.mode = COMMENT;
        /* falls through */
        case COMMENT:
          if (t.flags & 4096) {
            if (o === 0)
              break e;
            g = 0;
            do
              B = r[a + g++], t.head && B && t.length < 65536 && (t.head.comment += String.fromCharCode(B));
            while (B && g < o);
            if (t.flags & 512 && t.wrap & 4 && (t.check = crc32_1$1(t.check, r, g, a)), o -= g, a += g, B)
              break e;
          } else t.head && (t.head.comment = null);
          t.mode = HCRC;
        /* falls through */
        case HCRC:
          if (t.flags & 512) {
            for (; f < 16; ) {
              if (o === 0)
                break e;
              o--, l += r[a++] << f, f += 8;
            }
            if (t.wrap & 4 && l !== (t.check & 65535)) {
              e.msg = "header crc mismatch", t.mode = BAD;
              break;
            }
            l = 0, f = 0;
          }
          t.head && (t.head.hcrc = t.flags >> 9 & 1, t.head.done = !0), e.adler = t.check = 0, t.mode = TYPE;
          break;
        case DICTID:
          for (; f < 32; ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          e.adler = t.check = zswap32(l), l = 0, f = 0, t.mode = DICT;
        /* falls through */
        case DICT:
          if (t.havedict === 0)
            return e.next_out = s, e.avail_out = h, e.next_in = a, e.avail_in = o, t.hold = l, t.bits = f, Z_NEED_DICT$1;
          e.adler = t.check = 1, t.mode = TYPE;
        /* falls through */
        case TYPE:
          if (i === Z_BLOCK || i === Z_TREES)
            break e;
        /* falls through */
        case TYPEDO:
          if (t.last) {
            l >>>= f & 7, f -= f & 7, t.mode = CHECK;
            break;
          }
          for (; f < 3; ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          switch (t.last = l & 1, l >>>= 1, f -= 1, l & 3) {
            case 0:
              t.mode = STORED;
              break;
            case 1:
              if (fixedtables(t), t.mode = LEN_, i === Z_TREES) {
                l >>>= 2, f -= 2;
                break e;
              }
              break;
            case 2:
              t.mode = TABLE;
              break;
            case 3:
              e.msg = "invalid block type", t.mode = BAD;
          }
          l >>>= 2, f -= 2;
          break;
        case STORED:
          for (l >>>= f & 7, f -= f & 7; f < 32; ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          if ((l & 65535) !== (l >>> 16 ^ 65535)) {
            e.msg = "invalid stored block lengths", t.mode = BAD;
            break;
          }
          if (t.length = l & 65535, l = 0, f = 0, t.mode = COPY_, i === Z_TREES)
            break e;
        /* falls through */
        case COPY_:
          t.mode = COPY;
        /* falls through */
        case COPY:
          if (g = t.length, g) {
            if (g > o && (g = o), g > h && (g = h), g === 0)
              break e;
            n.set(r.subarray(a, a + g), s), o -= g, a += g, h -= g, s += g, t.length -= g;
            break;
          }
          t.mode = TYPE;
          break;
        case TABLE:
          for (; f < 14; ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          if (t.nlen = (l & 31) + 257, l >>>= 5, f -= 5, t.ndist = (l & 31) + 1, l >>>= 5, f -= 5, t.ncode = (l & 15) + 4, l >>>= 4, f -= 4, t.nlen > 286 || t.ndist > 30) {
            e.msg = "too many length or distance symbols", t.mode = BAD;
            break;
          }
          t.have = 0, t.mode = LENLENS;
        /* falls through */
        case LENLENS:
          for (; t.have < t.ncode; ) {
            for (; f < 3; ) {
              if (o === 0)
                break e;
              o--, l += r[a++] << f, f += 8;
            }
            t.lens[V[t.have++]] = l & 7, l >>>= 3, f -= 3;
          }
          for (; t.have < 19; )
            t.lens[V[t.have++]] = 0;
          if (t.lencode = t.lendyn, t.lenbits = 7, N = { bits: t.lenbits }, F = inftrees$1(CODES, t.lens, 0, 19, t.lencode, 0, t.work, N), t.lenbits = N.bits, F) {
            e.msg = "invalid code lengths set", t.mode = BAD;
            break;
          }
          t.have = 0, t.mode = CODELENS;
        /* falls through */
        case CODELENS:
          for (; t.have < t.nlen + t.ndist; ) {
            for (; A = t.lencode[l & (1 << t.lenbits) - 1], T = A >>> 24, C = A >>> 16 & 255, D = A & 65535, !(T <= f); ) {
              if (o === 0)
                break e;
              o--, l += r[a++] << f, f += 8;
            }
            if (D < 16)
              l >>>= T, f -= T, t.lens[t.have++] = D;
            else {
              if (D === 16) {
                for (G = T + 2; f < G; ) {
                  if (o === 0)
                    break e;
                  o--, l += r[a++] << f, f += 8;
                }
                if (l >>>= T, f -= T, t.have === 0) {
                  e.msg = "invalid bit length repeat", t.mode = BAD;
                  break;
                }
                B = t.lens[t.have - 1], g = 3 + (l & 3), l >>>= 2, f -= 2;
              } else if (D === 17) {
                for (G = T + 3; f < G; ) {
                  if (o === 0)
                    break e;
                  o--, l += r[a++] << f, f += 8;
                }
                l >>>= T, f -= T, B = 0, g = 3 + (l & 7), l >>>= 3, f -= 3;
              } else {
                for (G = T + 7; f < G; ) {
                  if (o === 0)
                    break e;
                  o--, l += r[a++] << f, f += 8;
                }
                l >>>= T, f -= T, B = 0, g = 11 + (l & 127), l >>>= 7, f -= 7;
              }
              if (t.have + g > t.nlen + t.ndist) {
                e.msg = "invalid bit length repeat", t.mode = BAD;
                break;
              }
              for (; g--; )
                t.lens[t.have++] = B;
            }
          }
          if (t.mode === BAD)
            break;
          if (t.lens[256] === 0) {
            e.msg = "invalid code -- missing end-of-block", t.mode = BAD;
            break;
          }
          if (t.lenbits = 9, N = { bits: t.lenbits }, F = inftrees$1(LENS, t.lens, 0, t.nlen, t.lencode, 0, t.work, N), t.lenbits = N.bits, F) {
            e.msg = "invalid literal/lengths set", t.mode = BAD;
            break;
          }
          if (t.distbits = 6, t.distcode = t.distdyn, N = { bits: t.distbits }, F = inftrees$1(DISTS, t.lens, t.nlen, t.ndist, t.distcode, 0, t.work, N), t.distbits = N.bits, F) {
            e.msg = "invalid distances set", t.mode = BAD;
            break;
          }
          if (t.mode = LEN_, i === Z_TREES)
            break e;
        /* falls through */
        case LEN_:
          t.mode = LEN;
        /* falls through */
        case LEN:
          if (o >= 6 && h >= 258) {
            e.next_out = s, e.avail_out = h, e.next_in = a, e.avail_in = o, t.hold = l, t.bits = f, inffast$1(e, w), s = e.next_out, n = e.output, h = e.avail_out, a = e.next_in, r = e.input, o = e.avail_in, l = t.hold, f = t.bits, t.mode === TYPE && (t.back = -1);
            break;
          }
          for (t.back = 0; A = t.lencode[l & (1 << t.lenbits) - 1], T = A >>> 24, C = A >>> 16 & 255, D = A & 65535, !(T <= f); ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          if (C && (C & 240) === 0) {
            for ($ = T, P = C, z = D; A = t.lencode[z + ((l & (1 << $ + P) - 1) >> $)], T = A >>> 24, C = A >>> 16 & 255, D = A & 65535, !($ + T <= f); ) {
              if (o === 0)
                break e;
              o--, l += r[a++] << f, f += 8;
            }
            l >>>= $, f -= $, t.back += $;
          }
          if (l >>>= T, f -= T, t.back += T, t.length = D, C === 0) {
            t.mode = LIT;
            break;
          }
          if (C & 32) {
            t.back = -1, t.mode = TYPE;
            break;
          }
          if (C & 64) {
            e.msg = "invalid literal/length code", t.mode = BAD;
            break;
          }
          t.extra = C & 15, t.mode = LENEXT;
        /* falls through */
        case LENEXT:
          if (t.extra) {
            for (G = t.extra; f < G; ) {
              if (o === 0)
                break e;
              o--, l += r[a++] << f, f += 8;
            }
            t.length += l & (1 << t.extra) - 1, l >>>= t.extra, f -= t.extra, t.back += t.extra;
          }
          t.was = t.length, t.mode = DIST;
        /* falls through */
        case DIST:
          for (; A = t.distcode[l & (1 << t.distbits) - 1], T = A >>> 24, C = A >>> 16 & 255, D = A & 65535, !(T <= f); ) {
            if (o === 0)
              break e;
            o--, l += r[a++] << f, f += 8;
          }
          if ((C & 240) === 0) {
            for ($ = T, P = C, z = D; A = t.distcode[z + ((l & (1 << $ + P) - 1) >> $)], T = A >>> 24, C = A >>> 16 & 255, D = A & 65535, !($ + T <= f); ) {
              if (o === 0)
                break e;
              o--, l += r[a++] << f, f += 8;
            }
            l >>>= $, f -= $, t.back += $;
          }
          if (l >>>= T, f -= T, t.back += T, C & 64) {
            e.msg = "invalid distance code", t.mode = BAD;
            break;
          }
          t.offset = D, t.extra = C & 15, t.mode = DISTEXT;
        /* falls through */
        case DISTEXT:
          if (t.extra) {
            for (G = t.extra; f < G; ) {
              if (o === 0)
                break e;
              o--, l += r[a++] << f, f += 8;
            }
            t.offset += l & (1 << t.extra) - 1, l >>>= t.extra, f -= t.extra, t.back += t.extra;
          }
          if (t.offset > t.dmax) {
            e.msg = "invalid distance too far back", t.mode = BAD;
            break;
          }
          t.mode = MATCH;
        /* falls through */
        case MATCH:
          if (h === 0)
            break e;
          if (g = w - h, t.offset > g) {
            if (g = t.offset - g, g > t.whave && t.sane) {
              e.msg = "invalid distance too far back", t.mode = BAD;
              break;
            }
            g > t.wnext ? (g -= t.wnext, E = t.wsize - g) : E = t.wnext - g, g > t.length && (g = t.length), k = t.window;
          } else
            k = n, E = s - t.offset, g = t.length;
          g > h && (g = h), h -= g, t.length -= g;
          do
            n[s++] = k[E++];
          while (--g);
          t.length === 0 && (t.mode = LEN);
          break;
        case LIT:
          if (h === 0)
            break e;
          n[s++] = t.length, h--, t.mode = LEN;
          break;
        case CHECK:
          if (t.wrap) {
            for (; f < 32; ) {
              if (o === 0)
                break e;
              o--, l |= r[a++] << f, f += 8;
            }
            if (w -= h, e.total_out += w, t.total += w, t.wrap & 4 && w && (e.adler = t.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
            t.flags ? crc32_1$1(t.check, n, w, s - w) : adler32_1$1(t.check, n, w, s - w)), w = h, t.wrap & 4 && (t.flags ? l : zswap32(l)) !== t.check) {
              e.msg = "incorrect data check", t.mode = BAD;
              break;
            }
            l = 0, f = 0;
          }
          t.mode = LENGTH;
        /* falls through */
        case LENGTH:
          if (t.wrap && t.flags) {
            for (; f < 32; ) {
              if (o === 0)
                break e;
              o--, l += r[a++] << f, f += 8;
            }
            if (t.wrap & 4 && l !== (t.total & 4294967295)) {
              e.msg = "incorrect length check", t.mode = BAD;
              break;
            }
            l = 0, f = 0;
          }
          t.mode = DONE;
        /* falls through */
        case DONE:
          F = Z_STREAM_END$1;
          break e;
        case BAD:
          F = Z_DATA_ERROR$1;
          break e;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        /* falls through */
        default:
          return Z_STREAM_ERROR$1;
      }
  return e.next_out = s, e.avail_out = h, e.next_in = a, e.avail_in = o, t.hold = l, t.bits = f, (t.wsize || w !== e.avail_out && t.mode < BAD && (t.mode < CHECK || i !== Z_FINISH$1)) && updatewindow(e, e.output, e.next_out, w - e.avail_out), b -= e.avail_in, w -= e.avail_out, e.total_in += b, e.total_out += w, t.total += w, t.wrap & 4 && w && (e.adler = t.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
  t.flags ? crc32_1$1(t.check, n, w, e.next_out - w) : adler32_1$1(t.check, n, w, e.next_out - w)), e.data_type = t.bits + (t.last ? 64 : 0) + (t.mode === TYPE ? 128 : 0) + (t.mode === LEN_ || t.mode === COPY_ ? 256 : 0), (b === 0 && w === 0 || i === Z_FINISH$1) && F === Z_OK$1 && (F = Z_BUF_ERROR), F;
}, inflateEnd = (e) => {
  if (inflateStateCheck(e))
    return Z_STREAM_ERROR$1;
  let i = e.state;
  return i.window && (i.window = null), e.state = null, Z_OK$1;
}, inflateGetHeader = (e, i) => {
  if (inflateStateCheck(e))
    return Z_STREAM_ERROR$1;
  const t = e.state;
  return (t.wrap & 2) === 0 ? Z_STREAM_ERROR$1 : (t.head = i, i.done = !1, Z_OK$1);
}, inflateSetDictionary = (e, i) => {
  const t = i.length;
  let r, n, a;
  return inflateStateCheck(e) || (r = e.state, r.wrap !== 0 && r.mode !== DICT) ? Z_STREAM_ERROR$1 : r.mode === DICT && (n = 1, n = adler32_1$1(n, i, t, 0), n !== r.check) ? Z_DATA_ERROR$1 : (a = updatewindow(e, i, t, t), a ? (r.mode = MEM, Z_MEM_ERROR$1) : (r.havedict = 1, Z_OK$1));
};
var inflateReset_1 = inflateReset, inflateReset2_1 = inflateReset2, inflateResetKeep_1 = inflateResetKeep, inflateInit_1 = inflateInit, inflateInit2_1 = inflateInit2, inflate_2$1 = inflate$2, inflateEnd_1 = inflateEnd, inflateGetHeader_1 = inflateGetHeader, inflateSetDictionary_1 = inflateSetDictionary, inflateInfo = "pako inflate (from Nodeca project)", inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var gzheader$1 = GZheader;
const toString$1 = Object.prototype.toString, {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(e) {
  this.options = common$1.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, e || {});
  const i = this.options;
  i.raw && i.windowBits >= 0 && i.windowBits < 16 && (i.windowBits = -i.windowBits, i.windowBits === 0 && (i.windowBits = -15)), i.windowBits >= 0 && i.windowBits < 16 && !(e && e.windowBits) && (i.windowBits += 32), i.windowBits > 15 && i.windowBits < 48 && (i.windowBits & 15) === 0 && (i.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new zstream$1(), this.strm.avail_out = 0;
  let t = inflate_1$2.inflateInit2(
    this.strm,
    i.windowBits
  );
  if (t !== Z_OK)
    throw new Error(messages$1[t]);
  if (this.header = new gzheader$1(), inflate_1$2.inflateGetHeader(this.strm, this.header), i.dictionary && (typeof i.dictionary == "string" ? i.dictionary = strings$1.string2buf(i.dictionary) : toString$1.call(i.dictionary) === "[object ArrayBuffer]" && (i.dictionary = new Uint8Array(i.dictionary)), i.raw && (t = inflate_1$2.inflateSetDictionary(this.strm, i.dictionary), t !== Z_OK)))
    throw new Error(messages$1[t]);
}
Inflate$1.prototype.push = function(e, i) {
  const t = this.strm, r = this.options.chunkSize, n = this.options.dictionary;
  let a, s, o;
  if (this.ended) return !1;
  for (i === ~~i ? s = i : s = i === !0 ? Z_FINISH : Z_NO_FLUSH, toString$1.call(e) === "[object ArrayBuffer]" ? t.input = new Uint8Array(e) : t.input = e, t.next_in = 0, t.avail_in = t.input.length; ; ) {
    for (t.avail_out === 0 && (t.output = new Uint8Array(r), t.next_out = 0, t.avail_out = r), a = inflate_1$2.inflate(t, s), a === Z_NEED_DICT && n && (a = inflate_1$2.inflateSetDictionary(t, n), a === Z_OK ? a = inflate_1$2.inflate(t, s) : a === Z_DATA_ERROR && (a = Z_NEED_DICT)); t.avail_in > 0 && a === Z_STREAM_END && t.state.wrap > 0 && e[t.next_in] !== 0; )
      inflate_1$2.inflateReset(t), a = inflate_1$2.inflate(t, s);
    switch (a) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        return this.onEnd(a), this.ended = !0, !1;
    }
    if (o = t.avail_out, t.next_out && (t.avail_out === 0 || a === Z_STREAM_END))
      if (this.options.to === "string") {
        let h = strings$1.utf8border(t.output, t.next_out), l = t.next_out - h, f = strings$1.buf2string(t.output, h);
        t.next_out = l, t.avail_out = r - l, l && t.output.set(t.output.subarray(h, h + l), 0), this.onData(f);
      } else
        this.onData(t.output.length === t.next_out ? t.output : t.output.subarray(0, t.next_out));
    if (!(a === Z_OK && o === 0)) {
      if (a === Z_STREAM_END)
        return a = inflate_1$2.inflateEnd(this.strm), this.onEnd(a), this.ended = !0, !0;
      if (t.avail_in === 0) break;
    }
  }
  return !0;
};
Inflate$1.prototype.onData = function(e) {
  this.chunks.push(e);
};
Inflate$1.prototype.onEnd = function(e) {
  e === Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = common$1.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function inflate$1$1(e, i) {
  const t = new Inflate$1(i);
  if (t.push(e), t.err) throw t.msg || messages$1[t.err];
  return t.result;
}
var inflate_2 = inflate$1$1, inflate_1$1 = {
  inflate: inflate_2
};
const { inflate: inflate$3 } = inflate_1$1;
var inflate_1 = inflate$3;
function decompressZlib(e) {
  const i = new Uint8Array(e.buffer, e.byteOffset, e.byteLength), t = inflate_1(i);
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
const defaultOptions$3 = {
  ignoreImageData: !1,
  onlyFirst: !1
};
class TIFFDecoder extends IOBuffer {
  constructor(i) {
    super(i), this._nextIFD = 0;
  }
  get isMultiPage() {
    let i = 0;
    for (this.decodeHeader(); this._nextIFD; )
      if (i++, this.decodeIFD({ ignoreImageData: !0 }, !0), i === 2)
        return !0;
    if (i === 1)
      return !1;
    throw unsupported("ifdCount", i);
  }
  get pageCount() {
    let i = 0;
    for (this.decodeHeader(); this._nextIFD; )
      i++, this.decodeIFD({ ignoreImageData: !0 }, !0);
    if (i > 0)
      return i;
    throw unsupported("ifdCount", i);
  }
  decode(i = {}) {
    i = Object.assign({}, defaultOptions$3, i);
    const t = [];
    for (this.decodeHeader(); this._nextIFD; )
      if (t.push(this.decodeIFD(i, !0)), i.onlyFirst)
        return [t[0]];
    return t;
  }
  decodeHeader() {
    const i = this.readUint16();
    if (i === 18761)
      this.setLittleEndian();
    else if (i === 19789)
      this.setBigEndian();
    else
      throw new Error(`invalid byte order: 0x${i.toString(16)}`);
    if (this.readUint16() !== 42)
      throw new Error("not a TIFF file");
    this._nextIFD = this.readUint32();
  }
  decodeIFD(i, t) {
    this.seek(this._nextIFD);
    let r;
    if (t)
      r = new TiffIfd();
    else {
      if (!i.kind)
        throw new Error("kind is missing");
      r = new IFD(i.kind);
    }
    const n = this.readUint16();
    for (let a = 0; a < n; a++)
      this.decodeIFDEntry(r);
    if (!i.ignoreImageData) {
      if (!(r instanceof TiffIfd))
        throw new Error("must be a tiff ifd");
      this.decodeImageData(r);
    }
    return this._nextIFD = this.readUint32(), r;
  }
  decodeIFDEntry(i) {
    const t = this.offset, r = this.readUint16(), n = this.readUint16(), a = this.readUint32();
    if (n < 1 || n > 12) {
      this.skip(4);
      return;
    }
    getByteLength(n, a) > 4 && this.seek(this.readUint32());
    const o = readData(this, n, a);
    if (i.fields.set(r, o), r === 34665 || r === 34853) {
      let h = this.offset, l = "exif";
      r === 34665 ? l = "exif" : r === 34853 && (l = "gps"), this._nextIFD = o, i[l] = this.decodeIFD({
        kind: l,
        ignoreImageData: !0
      }, !1), this.offset = h;
    }
    this.seek(t), this.skip(12);
  }
  decodeImageData(i) {
    const t = i.orientation;
    if (t && t !== 1)
      throw unsupported("orientation", t);
    switch (i.type) {
      case 0:
      // WhiteIsZero
      case 1:
      // BlackIsZero
      case 2:
      // RGB
      case 3:
        this.readStripData(i);
        break;
      default:
        throw unsupported("image type", i.type);
    }
    if (this.applyPredictor(i), this.convertAlpha(i), i.type === 0) {
      const r = i.bitsPerSample, n = Math.pow(2, r) - 1;
      for (let a = 0; a < i.data.length; a++)
        i.data[a] = n - i.data[a];
    }
  }
  readStripData(i) {
    const t = i.width, r = i.height, n = i.bitsPerSample, a = i.sampleFormat, s = t * r * i.samplesPerPixel, o = getDataArray(s, n, a), l = i.rowsPerStrip * t * i.samplesPerPixel, f = i.stripOffsets, b = i.stripByteCounts || guessStripByteCounts(i);
    let w = s, g = 0;
    for (let E = 0; E < f.length; E++) {
      let k = new DataView(this.buffer, this.byteOffset + f[E], b[E]), A = w > l ? l : w;
      w -= A;
      let T = k;
      switch (i.compression) {
        case 1:
          break;
        case 5: {
          T = decompressLzw(k);
          break;
        }
        case 8: {
          T = decompressZlib(k);
          break;
        }
        case 2:
          throw unsupported("Compression", "CCITT Group 3");
        case 32773:
          throw unsupported("Compression", "PackBits");
        default:
          throw unsupported("Compression", i.compression);
      }
      g = this.fillUncompressed(n, a, o, T, g, A);
    }
    i.data = o;
  }
  fillUncompressed(i, t, r, n, a, s) {
    if (i === 8)
      return fill8bit(r, n, a, s);
    if (i === 16)
      return fill16bit(r, n, a, s, this.isLittleEndian());
    if (i === 32 && t === 3)
      return fillFloat32(r, n, a, s, this.isLittleEndian());
    throw unsupported("bitDepth", i);
  }
  applyPredictor(i) {
    const t = i.bitsPerSample;
    switch (i.predictor) {
      case 1:
        break;
      case 2: {
        if (t === 8)
          applyHorizontalDifferencing8Bit(i.data, i.width, i.components);
        else if (t === 16)
          applyHorizontalDifferencing16Bit(i.data, i.width, i.components);
        else
          throw new Error(`Horizontal differencing is only supported for images with a bit depth of ${t}`);
        break;
      }
      default:
        throw new Error(`invalid predictor: ${i.predictor}`);
    }
  }
  convertAlpha(i) {
    if (i.alpha && i.associatedAlpha) {
      const { data: t, components: r, maxSampleValue: n } = i;
      for (let a = 0; a < t.length; a += r) {
        const s = t[a + r - 1];
        for (let o = 0; o < r - 1; o++)
          t[a + o] = Math.round(t[a + o] * n / s);
      }
    }
  }
}
function getDataArray(e, i, t) {
  if (i === 8)
    return new Uint8Array(e);
  if (i === 16)
    return new Uint16Array(e);
  if (i === 32 && t === 3)
    return new Float32Array(e);
  throw unsupported("bit depth / sample format", `${i} / ${t}`);
}
function fill8bit(e, i, t, r) {
  for (let n = 0; n < r; n++)
    e[t++] = i.getUint8(n);
  return t;
}
function fill16bit(e, i, t, r, n) {
  for (let a = 0; a < r * 2; a += 2)
    e[t++] = i.getUint16(a, n);
  return t;
}
function fillFloat32(e, i, t, r, n) {
  for (let a = 0; a < r * 4; a += 4)
    e[t++] = i.getFloat32(a, n);
  return t;
}
function unsupported(e, i) {
  return new Error(`Unsupported ${e}: ${i}`);
}
function decodeTIFF(e, i) {
  return new TIFFDecoder(e).decode(i);
}
function matchAndCrop(e = {}) {
  let { algorithm: i = "matchToPrevious", ignoreBorder: t = [0, 0] } = e;
  this.checkProcessable("matchAndCrop", {
    bitDepth: [8, 16]
  });
  let r = i === "matchToPrevious", n = this[0], a = [];
  a[0] = {
    position: [0, 0],
    image: this[0]
  };
  let s = [0, 0];
  for (let w = 1; w < this.length; w++) {
    let g = n.getBestMatch(this[w], { border: t });
    a[w] = {
      position: [
        g[0] + s[0],
        g[1] + s[1]
      ],
      image: this[w]
    }, r && (s[0] += g[0], s[1] += g[1], n = this[w]);
  }
  let o = 0, h = 0, l = 0, f = 0;
  for (let w = 0; w < a.length; w++) {
    let g = a[w];
    g.position[0] > o && (o = g.position[0]), g.position[0] < h && (h = g.position[0]), g.position[1] > l && (l = g.position[1]), g.position[1] < f && (f = g.position[1]);
  }
  h = 0 - h, f = 0 - f;
  for (let w = 0; w < a.length; w++) {
    let g = a[w];
    g.crop = g.image.crop({
      x: o - g.position[0],
      y: l - g.position[1],
      width: n.width - h - o,
      height: n.height - f - l
    });
  }
  let b = [];
  for (let w = 0; w < a.length; w++)
    b[w] = a[w].crop;
  return new Stack(b);
}
function min$2() {
  this.checkProcessable("min", {
    bitDepth: [8, 16]
  });
  let e = this[0].min;
  for (let i = 1; i < this.length; i++)
    for (let t = 0; t < e.length; t++)
      e[t] = Math.min(e[t], this[i].min[t]);
  return e;
}
function max$2() {
  this.checkProcessable("min", {
    bitDepth: [8, 16]
  });
  let e = this[0].max;
  for (let i = 1; i < this.length; i++)
    for (let t = 0; t < e.length; t++)
      e[t] = Math.max(e[t], this[i].max[t]);
  return e;
}
function median$2(e) {
  let i = e.reduce((s, o) => s + o);
  if (i === 0)
    throw new Error("unreachable");
  let t = 0, r = 0, n = i / 2, a;
  for (; ; ) {
    if (e[t] > 0) {
      if (a !== void 0)
        return (a + t) / 2;
      if (r += e[t], r > n)
        return t;
      r === n && (a = t);
    }
    t++;
  }
}
function mean$2(e) {
  let i = 0, t = 0;
  for (let r = 0; r < e.length; r++)
    i += e[r], t += e[r] * r;
  return i === 0 ? 0 : t / i;
}
function median$1() {
  this.checkProcessable("median", {
    bitDepth: [8, 16]
  });
  let e = this.getHistograms({ maxSlots: this[0].maxValue + 1 }), i = new Array(e.length);
  for (let t = 0; t < e.length; t++) {
    let r = e[t];
    i[t] = median$2(r);
  }
  return i;
}
function histogram(e) {
  this.checkProcessable("min", {
    bitDepth: [8, 16]
  });
  let i = this[0].getHistogram(e);
  for (let t = 1; t < this.length; t++) {
    let r = this[t].getHistogram(e);
    for (let n = 0; n < i.length; n++)
      i[n] += r[n];
  }
  return i;
}
function histograms(e) {
  this.checkProcessable("min", {
    bitDepth: [8, 16]
  });
  let i = this[0].getHistograms(e), t = i[0].length;
  for (let r = 1; r < this.length; r++) {
    let n = this[r].getHistograms(e);
    for (let a = 0; a < i.length; a++)
      for (let s = 0; s < t; s++)
        i[a][s] += n[a][s];
  }
  return i;
}
function averageImage() {
  this.checkProcessable("averageImage", {
    bitDepth: [8, 16]
  });
  let e = new Uint32Array(this[0].data.length);
  for (let r = 0; r < this.length; r++) {
    let n = this[r];
    for (let a = 0; a < this[0].data.length; a++)
      e[a] += n.data[a];
  }
  let i = Image.createFrom(this[0]), t = i.data;
  for (let r = 0; r < this[0].data.length; r++)
    t[r] = e[r] / this.length;
  return i;
}
function maxImage() {
  this.checkProcessable("max", {
    bitDepth: [8, 16]
  });
  let e = Image.createFrom(this[0]);
  e.data.fill(0);
  for (const i of this)
    for (let t = 0; t < e.data.length; t++)
      e.data[t] = Math.max(i.data[t], e.data[t]);
  return e;
}
function minImage() {
  this.checkProcessable("max", {
    bitDepth: [8, 16]
  });
  let e = Image.createFrom(this[0]);
  e.data.fill(e.maxValue);
  for (const i of this)
    for (let t = 0; t < e.data.length; t++)
      e.data[t] = Math.min(i.data[t], e.data[t]);
  return e;
}
function extend$2(e) {
  e.extendMethod("matchAndCrop", matchAndCrop), e.extendMethod("getMin", min$2), e.extendMethod("getMax", max$2), e.extendMethod("getMedian", median$1), e.extendMethod("getHistogram", histogram), e.extendMethod("getHistograms", histograms), e.extendMethod("getAverage", averageImage), e.extendMethod("getAverageImage", averageImage), e.extendMethod("getMaxImage", maxImage), e.extendMethod("getMinImage", minImage);
}
let computedPropertyDescriptor = {
  configurable: !0,
  enumerable: !1,
  get: void 0
};
class Stack extends Array {
  constructor(i) {
    if (Array.isArray(i)) {
      super(i.length);
      for (let t = 0; t < i.length; t++)
        this[t] = i[t];
    } else typeof i == "number" ? super(i) : super();
    this.computed = null;
  }
  static load(i) {
    return Promise.all(i.map(Image.load)).then(
      (t) => new Stack(t)
    );
  }
  static extendMethod(i, t, r = {}) {
    let { inPlace: n = !1, returnThis: a = !0, partialArgs: s = [] } = r;
    return n ? Stack.prototype[i] = function(...o) {
      this.computed = null;
      let h = t.apply(this, [...s, ...o]);
      return a ? this : h;
    } : Stack.prototype[i] = function(...o) {
      return t.apply(this, [...s, ...o]);
    }, Stack;
  }
  static extendProperty(i, t, r = {}) {
    let { partialArgs: n = [] } = r;
    return computedPropertyDescriptor.get = function() {
      if (this.computed === null)
        this.computed = {};
      else if (hasOwn(i, this.computed))
        return this.computed[i];
      let a = t.apply(this, n);
      return this.computed[i] = a, a;
    }, Object.defineProperty(Stack.prototype, i, computedPropertyDescriptor), Stack;
  }
  /**
   * Check if a process can be applied on the stack
   * @param {string} processName
   * @param {object} [options]
   * @private
   */
  checkProcessable(i, t = {}) {
    if (typeof i != "string")
      throw new TypeError(
        "checkProcessable requires as first parameter the processName (a string)"
      );
    if (this.size === 0)
      throw new TypeError(
        `The process: ${i} can not be applied on an empty stack`
      );
    this[0].checkProcessable(i, t);
    for (let r = 1; r < this.length; r++) {
      if ((t.sameSize === void 0 || t.sameSize) && this[0].width !== this[r].width)
        throw new TypeError(
          `The process: ${i} can not be applied if width is not identical in all images`
        );
      if ((t.sameSize === void 0 || t.sameSize) && this[0].height !== this[r].height)
        throw new TypeError(
          `The process: ${i} can not be applied if height is not identical in all images`
        );
      if ((t.sameAlpha === void 0 || t.sameAlpha) && this[0].alpha !== this[r].alpha)
        throw new TypeError(
          `The process: ${i} can not be applied if alpha is not identical in all images`
        );
      if ((t.sameBitDepth === void 0 || t.sameBitDepth) && this[0].bitDepth !== this[r].bitDepth)
        throw new TypeError(
          `The process: ${i} can not be applied if bitDepth is not identical in all images`
        );
      if ((t.sameColorModel === void 0 || t.sameColorModel) && this[0].colorModel !== this[r].colorModel)
        throw new TypeError(
          `The process: ${i} can not be applied if colorModel is not identical in all images`
        );
      if ((t.sameNumberChannels === void 0 || t.sameNumberChannels) && this[0].channels !== this[r].channels)
        throw new TypeError(
          `The process: ${i} can not be applied if channels is not identical in all images`
        );
    }
  }
}
Array[Symbol.species] || (Stack.prototype.map = function(e, i) {
  if (typeof e != "function")
    throw new TypeError(`${e} is not a function`);
  let t = new Stack(this.length);
  for (let r = 0; r < this.length; r++)
    t[r] = e.call(i, this[r], r, this);
  return t;
});
extend$2(Stack);
const isDataURL = /^data:[a-z]+\/(?:[a-z]+);base64,/;
function load(e, i) {
  if (typeof e == "string")
    return loadURL(e, i);
  if (e instanceof ArrayBuffer)
    return Promise.resolve(
      loadBinary(
        new Uint8Array(e),
        void 0,
        i && i.ignorePalette
      )
    );
  if (e.buffer)
    return Promise.resolve(
      loadBinary(e, void 0, i && i.ignorePalette)
    );
  throw new Error('argument to "load" must be a string or buffer.');
}
function loadBinary(e, i, t) {
  const r = imageType(e);
  if (r)
    switch (r.mime) {
      case "image/png":
        return loadPNG(e);
      case "image/jpeg":
        return loadJPEG(e);
      case "image/tiff":
        return loadTIFF(e, t);
      default:
        return loadGeneric(n(r.mime));
    }
  return loadGeneric(n("application/octet-stream"));
  function n(a) {
    return i || toBase64URL(e, a);
  }
}
function loadURL(e, i) {
  const t = e.slice(0, 64).match(isDataURL);
  let r;
  return t !== null ? r = Promise.resolve(decode$1(e.slice(t[0].length))) : r = fetchBinary(e, i), r.then((n) => {
    const a = new Uint8Array(n);
    return loadBinary(
      a,
      t ? e : void 0,
      i && i.ignorePalette
    );
  });
}
function loadPNG(e) {
  const i = decodePng(e);
  let t = i.channels, r, n = 0;
  return t === 2 || t === 4 ? (r = t - 1, n = 1) : r = t, i.palette ? loadPNGFromPalette(i) : new Image(i.width, i.height, i.data, {
    components: r,
    alpha: n,
    bitDepth: i.depth,
    meta: { text: i.text }
  });
}
function loadPNGFromPalette(e) {
  const i = e.width * e.height, t = e.palette[0].length, r = new Uint8Array(i * t), n = 8 / e.depth, a = e.depth < 8 ? n : 1, s = parseInt("1".repeat(e.depth), 2), o = t === 4;
  let h = 0;
  for (let l = 0; l < i; l++) {
    const f = Math.floor(l / a);
    let b = e.data[f];
    e.depth < 8 && (b = b >>> e.depth * (n - 1 - l % n) & s);
    const w = e.palette[b];
    r[h++] = w[0], r[h++] = w[1], r[h++] = w[2], o && (r[h++] = w[3]);
  }
  return new Image(e.width, e.height, r, {
    components: 3,
    alpha: o,
    bitDepth: 8
  });
}
function loadJPEG(e) {
  const i = srcExports$2.decode(e);
  let t;
  i.exif && (t = getMetadata(i.exif));
  const r = jpegJsExports.decode(e, { useTArray: !0, maxMemoryUsageInMB: 1024 });
  let n = new Image(r.width, r.height, r.data, { meta: t });
  if (t && t.tiff.tags.Orientation) {
    const a = t.tiff.tags.Orientation;
    a > 2 && (n = n.rotate(
      {
        3: 180,
        4: 180,
        5: 90,
        6: 90,
        7: 270,
        8: 270
      }[a]
    )), [2, 4, 5, 7].includes(a) && (n = n.flipX());
  }
  return n;
}
function loadTIFF(e, i) {
  let t = decodeTIFF(e);
  return t.length === 1 ? getImageFromIFD(t[0], i) : new Stack(
    t.map(function(r) {
      return getImageFromIFD(r, i);
    })
  );
}
function getMetadata(e) {
  const i = {
    tiff: {
      fields: e.fields,
      tags: e.map
    }
  };
  return e.exif && (i.exif = e.exif), e.gps && (i.gps = e.gps), i;
}
function getImageFromIFD(e, i) {
  if (!i && e.type === 3) {
    const t = new Uint16Array(3 * e.width * e.height), r = e.palette;
    let n = 0;
    for (let a = 0; a < e.data.length; a++) {
      const s = e.data[a], o = r[s];
      t[n++] = o[0], t[n++] = o[1], t[n++] = o[2];
    }
    return new Image(e.width, e.height, t, {
      components: 3,
      alpha: e.alpha,
      colorModel: RGB$1,
      bitDepth: 16,
      meta: getMetadata(e)
    });
  } else
    return new Image(e.width, e.height, e.data, {
      components: e.type === 2 ? 3 : 1,
      alpha: e.alpha,
      colorModel: e.type === 2 ? RGB$1 : GREY$1,
      bitDepth: e.bitsPerSample.length ? e.bitsPerSample[0] : e.bitsPerSample,
      meta: getMetadata(e)
    });
}
function loadGeneric(e, i) {
  return i = i || {}, new Promise(function(t, r) {
    let n = new DOMImage();
    n.onload = function() {
      let a = n.width, s = n.height, h = createCanvas(a, s).getContext("2d");
      h.drawImage(n, 0, 0, a, s);
      let l = h.getImageData(0, 0, a, s).data;
      t(new Image(a, s, l, i));
    }, n.onerror = function() {
      r(new Error(`Could not load ${e}`));
    }, n.src = e;
  });
}
const valueMethods = {
  /**
   * Get the value of specific pixel channel
   * @memberof Image
   * @instance
   * @param {number} x - x coordinate (0 = left)
   * @param {number} y - y coordinate (0 = top)
   * @param {number} channel
   * @return {number} - the value of this pixel channel
   */
  getValueXY(e, i, t) {
    return this.data[(i * this.width + e) * this.channels + t];
  },
  /**
   * Set the value of specific pixel channel
   * @memberof Image
   * @instance
   * @param {number} x - x coordinate (0 = left)
   * @param {number} y - y coordinate (0 = top)
   * @param {number} channel
   * @param {number} value - the new value of this pixel channel
   * @return {this}
   */
  setValueXY(e, i, t, r) {
    return this.data[(i * this.width + e) * this.channels + t] = r, this.computed = null, this;
  },
  /**
   * Get the value of specific pixel channel
   * @memberof Image
   * @instance
   * @param {number} index - 1D index of the pixel
   * @param {number} channel
   * @return {number} - the value of this pixel channel
   */
  getValue(e, i) {
    return this.data[e * this.channels + i];
  },
  /**
   * Set the value of specific pixel channel
   * @memberof Image
   * @instance
   * @param {number} index - 1D index of the pixel
   * @param {number} channel
   * @param {number} value - the new value of this pixel channel
   * @return {this}
   */
  setValue(e, i, t) {
    return this.data[e * this.channels + i] = t, this.computed = null, this;
  },
  /**
   * Get the value of an entire pixel
   * @memberof Image
   * @instance
   * @param {number} x - x coordinate (0 = left)
   * @param {number} y - y coordinate (0 = top)
   * @return {number[]} the value of this pixel
   */
  getPixelXY(e, i) {
    return this.getPixel(i * this.width + e);
  },
  /**
   * Set the value of an entire pixel
   * @memberof Image
   * @instance
   * @param {number} x - x coordinate (0 = left)
   * @param {number} y - y coordinate (0 = top)
   * @param {number[]} value - the new value of this pixel
   * @return {this}
   */
  setPixelXY(e, i, t) {
    return this.setPixel(i * this.width + e, t);
  },
  /**
   * Get the value of an entire pixel
   * @memberof Image
   * @instance
   * @param {number} index - 1D index of the pixel
   * @return {number[]} the value of this pixel
   */
  getPixel(e) {
    const i = new Array(this.channels), t = e * this.channels;
    for (let r = 0; r < this.channels; r++)
      i[r] = this.data[t + r];
    return i;
  },
  /**
   * Set the value of an entire pixel
   * @memberof Image
   * @instance
   * @param {number} index - 1D index of the pixel
   * @param {number[]} value - the new value of this pixel
   * @return {this}
   */
  setPixel(e, i) {
    const t = e * this.channels;
    for (let r = 0; r < i.length; r++)
      this.data[t + r] = i[r];
    return this.computed = null, this;
  }
};
function setValueMethods(e) {
  for (const i in valueMethods)
    e.prototype[i] = valueMethods[i];
}
function getImageParameters(e) {
  return {
    width: e.width,
    height: e.height,
    components: e.components,
    alpha: e.alpha,
    colorModel: e.colorModel,
    bitDepth: e.bitDepth
  };
}
function getOutputImage(e, i, t, r = {}) {
  const { out: n } = i;
  if (n === void 0)
    return r.copy ? e.clone() : Image.createFrom(e, t);
  {
    if (!Image.isImage(n))
      throw new TypeError("out must be an Image object");
    const a = Object.assign(
      getImageParameters(e),
      t
    );
    for (const s in a)
      if (n[s] !== a[s])
        throw new RangeError(
          `cannot use out. Its ${s} must be "${a[s]}" (found "${n[s]}")`
        );
    return n;
  }
}
function getOutputImageOrInPlace(e, i, t) {
  if (i.inPlace !== void 0 && typeof i.inPlace != "boolean")
    throw new TypeError("inPlace option must be a boolean");
  if (i.inPlace) {
    if (i.out !== void 0)
      throw new TypeError(
        "out option must not be set if inPlace option is true"
      );
    return e;
  }
  return getOutputImage(e, i, null, t);
}
function abs(e = {}) {
  this.checkProcessable("abs", {
    bitDepth: [32]
  });
  const i = getOutputImageOrInPlace(this, e);
  return absolute(this, i), i;
}
function absolute(e, i) {
  for (let t = 0; t < e.data.length; t++)
    i.data[t] = Math.abs(e.data[t]);
}
function copyAlphaChannel(e, i) {
  if (e.alpha === 1 && i.alpha === 1)
    for (let t = 0; t < e.size; t++)
      i.data[t * i.channels + i.components] = e.data[t * e.channels + e.components];
}
function invert(e = {}) {
  this.checkProcessable("invert", {
    bitDepth: [1, 8, 16]
  });
  const i = getOutputImageOrInPlace(this, e);
  return this.bitDepth === 1 ? invertBinary(this, i) : (invertColor(this, i), this !== i && copyAlphaChannel(this, i)), i;
}
function invertBinary(e, i) {
  for (let t = 0; t < e.data.length; t++)
    i.data[t] = ~e.data[t];
}
function invertColor(e, i) {
  for (let t = 0; t < e.data.length; t += e.channels)
    for (let r = 0; r < e.components; r++)
      i.data[t + r] = e.maxValue - e.data[t + r];
}
function flipX() {
  this.checkProcessable("flipX", {
    bitDepth: [8, 16]
  });
  for (let e = 0; e < this.height; e++) {
    let i = e * this.width * this.channels;
    for (let t = 0; t < Math.floor(this.width / 2); t++) {
      let r = t * this.channels + i, n = (this.width - t - 1) * this.channels + i;
      for (let a = 0; a < this.channels; a++) {
        let s = this.data[r + a];
        this.data[r + a] = this.data[n + a], this.data[n + a] = s;
      }
    }
  }
  return this;
}
function flipY() {
  this.checkProcessable("flipY", {
    bitDepth: [8, 16]
  });
  for (let e = 0; e < Math.floor(this.height / 2); e++)
    for (let i = 0; i < this.width; i++) {
      let t = i * this.channels + e * this.width * this.channels, r = i * this.channels + (this.height - 1 - e) * this.channels * this.width;
      for (let n = 0; n < this.channels; n++) {
        let a = this.data[t + n];
        this.data[t + n] = this.data[r + n], this.data[r + n] = a;
      }
    }
  return this;
}
function blurFilter(e = {}) {
  const { radius: i = 1 } = e;
  if (i < 1)
    throw new Error("radius must be greater than 1");
  const t = 2 * i + 1, r = new Array(t);
  for (let n = 0; n < t; n++) {
    r[n] = new Array(t);
    for (let a = 0; a < t; a++)
      r[n][a] = 1 / (t * t);
  }
  return this.convolution(r);
}
var medianQuickselect_min = { exports: {} }, hasRequiredMedianQuickselect_min;
function requireMedianQuickselect_min() {
  return hasRequiredMedianQuickselect_min || (hasRequiredMedianQuickselect_min = 1, function(e) {
    (function() {
      function i(n) {
        for (var a = 0, s = n.length - 1, o = void 0, h = void 0, l = void 0, f = r(a, s); ; ) {
          if (s <= a) return n[f];
          if (s == a + 1) return n[a] > n[s] && t(n, a, s), n[f];
          for (o = r(a, s), n[o] > n[s] && t(n, o, s), n[a] > n[s] && t(n, a, s), n[o] > n[a] && t(n, o, a), t(n, o, a + 1), h = a + 1, l = s; ; ) {
            do
              h++;
            while (n[a] > n[h]);
            do
              l--;
            while (n[l] > n[a]);
            if (l < h) break;
            t(n, h, l);
          }
          t(n, a, l), l <= f && (a = h), l >= f && (s = l - 1);
        }
      }
      var t = function(a, s, o) {
        var h;
        return h = [a[o], a[s]], a[s] = h[0], a[o] = h[1], h;
      }, r = function(a, s) {
        return ~~((a + s) / 2);
      };
      e.exports ? e.exports = i : window.median = i;
    })();
  }(medianQuickselect_min)), medianQuickselect_min.exports;
}
var medianQuickselect_minExports = requireMedianQuickselect_min();
const quickSelectMedian = /* @__PURE__ */ getDefaultExportFromCjs(medianQuickselect_minExports);
function validateArrayOfChannels(e, i = {}) {
  let {
    channels: t,
    allowAlpha: r,
    // are we allowing the selection of an alpha channel ?
    defaultAlpha: n
    // if no channels are selected should we take the alpha channel ?
  } = i;
  return typeof r != "boolean" && (r = !0), typeof t > "u" ? allChannels(e, n) : validateChannels(e, t, r);
}
function allChannels(e, i) {
  let t = i ? e.channels : e.components, r = new Array(t);
  for (let n = 0; n < t; n++)
    r[n] = n;
  return r;
}
function validateChannels(e, i, t) {
  Array.isArray(i) || (i = [i]);
  for (let r = 0; r < i.length; r++)
    i[r] = validateChannel(e, i[r], t);
  return i;
}
function validateChannel(e, i, t = !0) {
  if (i === void 0)
    throw new RangeError(
      `validateChannel : the channel has to be >=0 and <${e.channels}`
    );
  if (typeof i == "string") {
    switch (e.colorModel) {
      case GREY$1:
        break;
      case RGB$1:
        if ("rgb".includes(i))
          switch (i) {
            case "r":
              i = 0;
              break;
            case "g":
              i = 1;
              break;
            case "b":
              i = 2;
              break;
          }
        break;
      case HSL:
        if ("hsl".includes(i))
          switch (i) {
            case "h":
              i = 0;
              break;
            case "s":
              i = 1;
              break;
            case "l":
              i = 2;
              break;
          }
        break;
      case HSV:
        if ("hsv".includes(i))
          switch (i) {
            case "h":
              i = 0;
              break;
            case "s":
              i = 1;
              break;
            case "v":
              i = 2;
              break;
          }
        break;
      case CMYK$1:
        if ("cmyk".includes(i))
          switch (i) {
            case "c":
              i = 0;
              break;
            case "m":
              i = 1;
              break;
            case "y":
              i = 2;
              break;
            case "k":
              i = 3;
              break;
          }
        break;
      default:
        throw new Error(`Unexpected color model: ${e.colorModel}`);
    }
    if (i === "a") {
      if (!e.alpha)
        throw new Error(
          "validateChannel : the image does not contain alpha channel"
        );
      i = e.components;
    }
    if (typeof i == "string")
      throw new Error(`validateChannel : undefined channel: ${i}`);
  }
  if (i >= e.channels)
    throw new RangeError(
      `validateChannel : the channel has to be >=0 and <${e.channels}`
    );
  if (!t && i >= e.components)
    throw new RangeError("validateChannel : alpha channel may not be selected");
  return i;
}
function medianFilter(e = {}) {
  let { radius: i = 1, border: t = "copy", channels: r } = e;
  if (this.checkProcessable("medianFilter", {
    bitDepth: [8, 16]
  }), i < 1)
    throw new Error("radius must be greater than 0");
  r = validateArrayOfChannels(this, r);
  let n = i, a = i, s = Image.createFrom(this), o = (n * 2 + 1) * (a * 2 + 1), h = new Array(o);
  for (let l = 0; l < r.length; l++) {
    let f = r[l];
    for (let b = a; b < this.height - a; b++)
      for (let w = n; w < this.width - n; w++) {
        let g = 0;
        for (let k = -a; k <= a; k++)
          for (let A = -n; A <= n; A++) {
            let T = ((b + k) * this.width + w + A) * this.channels + f;
            h[g++] = this.data[T];
          }
        let E = (b * this.width + w) * this.channels + f;
        s.data[E] = quickSelectMedian(h);
      }
  }
  if (this.alpha && !r.includes(this.channels))
    for (let l = this.components; l < this.data.length; l = l + this.channels)
      s.data[l] = this.data[l];
  return s.setBorder({ size: [n, a], algorithm: t }), s;
}
function gaussianFilter(e = {}) {
  let { radius: i = 1, sigma: t, channels: r, border: n = "copy" } = e;
  this.checkProcessable("gaussian", {
    bitDepth: [8, 16]
  });
  const a = getKernel(i, t);
  return this.convolution([a, a], {
    border: n,
    channels: r,
    algorithm: "separable"
  });
}
function getKernel(e, i) {
  const t = e * 2 + 1, r = new Array(t), n = i || ((t - 1) * 0.5 - 1) * 0.3 + 0.8, a = -0.5 / (n * n);
  let s = 0;
  for (let o = 0; o < t; o++) {
    const h = o - e, l = Math.exp(a * h * h);
    r[o] = l, s += l;
  }
  for (let o = 0; o < t; o++)
    r[o] /= s;
  return r;
}
const SOBEL_X = [
  [-1, 0, 1],
  [-2, 0, 2],
  [-1, 0, 1]
], SOBEL_Y = [
  [-1, -2, -1],
  [0, 0, 0],
  [1, 2, 1]
], SCHARR_X = [
  [3, 0, -3],
  [10, 0, -10],
  [3, 0, -3]
], SCHARR_Y = [
  [3, 10, 3],
  [0, 0, 0],
  [-3, -10, -3]
];
var src$2 = {}, fftlib = {}, hasRequiredFftlib;
function requireFftlib() {
  return hasRequiredFftlib || (hasRequiredFftlib = 1, function(e) {
    (function() {
      var i;
      i = e;
      var t = {
        release: "0.3.0",
        date: "2013-03"
      };
      i.toString = function() {
        return "version " + t.release + ", released " + t.date;
      };
      for (var r = 0, n = null, a = null, s = {
        init: function(l) {
          if (l !== 0 && (l & l - 1) === 0)
            r = l, s._initArray(), s._makeBitReversalTable(), s._makeCosSinTable();
          else
            throw new Error("init: radix-2 required");
        },
        // 1D-FFT
        fft1d: function(l, f) {
          s.fft(l, f, 1);
        },
        // 1D-IFFT
        ifft1d: function(l, f) {
          var b = 1 / r;
          s.fft(l, f, -1);
          for (var w = 0; w < r; w++)
            l[w] *= b, f[w] *= b;
        },
        // 1D-IFFT
        bt1d: function(l, f) {
          s.fft(l, f, -1);
        },
        // 2D-FFT Not very useful if the number of rows have to be equal to cols
        fft2d: function(l, f) {
          for (var b = [], w = [], g = 0, E = 0; E < r; E++) {
            g = E * r;
            for (var k = 0; k < r; k++)
              b[k] = l[k + g], w[k] = f[k + g];
            s.fft1d(b, w);
            for (var A = 0; A < r; A++)
              l[A + g] = b[A], f[A + g] = w[A];
          }
          for (var T = 0; T < r; T++) {
            for (var C = 0; C < r; C++)
              g = T + C * r, b[C] = l[g], w[C] = f[g];
            s.fft1d(b, w);
            for (var D = 0; D < r; D++)
              g = T + D * r, l[g] = b[D], f[g] = w[D];
          }
        },
        // 2D-IFFT
        ifft2d: function(l, f) {
          for (var b = [], w = [], g = 0, E = 0; E < r; E++) {
            g = E * r;
            for (var k = 0; k < r; k++)
              b[k] = l[k + g], w[k] = f[k + g];
            s.ifft1d(b, w);
            for (var A = 0; A < r; A++)
              l[A + g] = b[A], f[A + g] = w[A];
          }
          for (var T = 0; T < r; T++) {
            for (var C = 0; C < r; C++)
              g = T + C * r, b[C] = l[g], w[C] = f[g];
            s.ifft1d(b, w);
            for (var D = 0; D < r; D++)
              g = T + D * r, l[g] = b[D], f[g] = w[D];
          }
        },
        // core operation of FFT
        fft: function(l, f, b) {
          for (var w, g, E, k, A, T, C, D, $, P = r >> 2, z = 0; z < r; z++)
            k = n[z], z < k && (A = l[z], l[z] = l[k], l[k] = A, A = f[z], f[z] = f[k], f[k] = A);
          for (var B = 1; B < r; B <<= 1) {
            g = 0, w = r / (B << 1);
            for (var F = 0; F < B; F++) {
              T = a[g + P], C = b * a[g];
              for (var O = F; O < r; O += B << 1)
                E = O + B, D = T * l[E] + C * f[E], $ = T * f[E] - C * l[E], l[E] = l[O] - D, l[O] += D, f[E] = f[O] - $, f[O] += $;
              g += w;
            }
          }
        },
        // initialize the array (supports TypedArray)
        _initArray: function() {
          typeof Uint32Array < "u" ? n = new Uint32Array(r) : n = [], typeof Float64Array < "u" ? a = new Float64Array(r * 1.25) : a = [];
        },
        // zero padding
        _paddingZero: function() {
        },
        // makes bit reversal table
        _makeBitReversalTable: function() {
          var l = 0, f = 0, b = 0;
          for (n[0] = 0; ++l < r; ) {
            for (b = r >> 1; b <= f; )
              f -= b, b >>= 1;
            f += b, n[l] = f;
          }
        },
        // makes trigonometiric function table
        _makeCosSinTable: function() {
          var l = r >> 1, f = r >> 2, b = r >> 3, w = l + f, g = Math.sin(Math.PI / r), E = 2 * g * g, k = Math.sqrt(E * (2 - E)), A = a[f] = 1, T = a[0] = 0;
          g = 2 * E;
          for (var C = 1; C < b; C++)
            A -= E, E += g * A, T += k, k -= g * T, a[C] = T, a[f - C] = A;
          b !== 0 && (a[b] = Math.sqrt(0.5));
          for (var D = 0; D < f; D++)
            a[l - D] = a[D];
          for (var $ = 0; $ < w; $++)
            a[$ + l] = -a[$];
        }
      }, o = ["init", "fft1d", "ifft1d", "fft2d", "ifft2d"], h = 0; h < o.length; h++)
        i[o[h]] = s[o[h]];
      return i.bt = s.bt1d, i.fft = s.fft1d, i.ifft = s.ifft1d, i;
    }).call(fftlib);
  }(fftlib)), fftlib;
}
var FFTUtils_1, hasRequiredFFTUtils;
function requireFFTUtils() {
  if (hasRequiredFFTUtils) return FFTUtils_1;
  hasRequiredFFTUtils = 1;
  var e = requireFftlib(), i = {
    DEBUG: !1,
    /**
     * Calculates the inverse of a 2D Fourier transform
     *
     * @param ft
     * @param ftRows
     * @param ftCols
     * @return
     */
    ifft2DArray: function(t, r, n) {
      var a = new Array(r * n), s = r / 2, o = (n - 1) * 2;
      e.init(s);
      for (var h = { re: new Array(s), im: new Array(s) }, l = 0; l < n; l++) {
        for (var f = s - 1; f >= 0; f--)
          h.re[f] = t[f * 2 * n + l], h.im[f] = t[(f * 2 + 1) * n + l];
        e.bt(h.re, h.im);
        for (var f = s - 1; f >= 0; f--)
          a[f * 2 * n + l] = h.re[f], a[(f * 2 + 1) * n + l] = h.im[f];
      }
      var b = new Array(s * o);
      e.init(o);
      for (var w = { re: new Array(o), im: new Array(o) }, g = o * s, f = 0; f < r; f += 2) {
        w.re[0] = a[f * n], w.im[0] = a[(f + 1) * n];
        for (var l = 1; l < n; l++)
          w.re[l] = a[f * n + l], w.im[l] = a[(f + 1) * n + l], w.re[o - l] = a[f * n + l], w.im[o - l] = -a[(f + 1) * n + l];
        e.bt(w.re, w.im);
        for (var E = f / 2 * o, l = o - 1; l >= 0; l--)
          b[E + l] = w.re[l] / g;
      }
      return b;
    },
    /**
     * Calculates the fourier transform of a matrix of size (nRows,nCols) It is
     * assumed that both nRows and nCols are a power of two
     *
     * On exit the matrix has dimensions (nRows * 2, nCols / 2 + 1) where the
     * even rows contain the real part and the odd rows the imaginary part of the
     * transform
     * @param data
     * @param nRows
     * @param nCols
     * @return
     */
    fft2DArray: function(t, r, n, a) {
      Object.assign({}, { inplace: !0 });
      var s = n / 2 + 1, o = r * 2, h = new Array(o * s);
      e.init(n);
      for (var l = { re: new Array(n), im: new Array(n) }, f = { re: new Array(n), im: new Array(n) }, b = { re: new Array(n), im: new Array(n) }, w, g, E, k, A, T = 0; T < r / 2; T++) {
        w = T * 2 * n, l.re = t.slice(w, w + n), w = (T * 2 + 1) * n, l.im = t.slice(w, w + n), e.fft1d(l.re, l.im), this.reconstructTwoRealFFT(l, f, b), g = T * 4 * s, E = (T * 4 + 1) * s, k = (T * 4 + 2) * s, A = (T * 4 + 3) * s;
        for (var C = s - 1; C >= 0; C--)
          h[g + C] = f.re[C], h[E + C] = f.im[C], h[k + C] = b.re[C], h[A + C] = b.im[C];
      }
      f = null, b = null;
      var D = new Array(o * s);
      e.init(r);
      for (var $ = { re: new Array(r), im: new Array(r) }, P = s - 1; P >= 0; P--) {
        for (var T = r - 1; T >= 0; T--)
          $.re[T] = h[T * 2 * s + P], $.im[T] = h[(T * 2 + 1) * s + P], isNaN($.re[T]) && ($.re[T] = 0), isNaN($.im[T]) && ($.im[T] = 0);
        e.fft1d($.re, $.im);
        for (var T = r - 1; T >= 0; T--)
          D[T * 2 * s + P] = $.re[T], D[(T * 2 + 1) * s + P] = $.im[T];
      }
      return D;
    },
    /**
     *
     * @param fourierTransform
     * @param realTransform1
     * @param realTransform2
     *
     * Reconstructs the individual Fourier transforms of two simultaneously
     * transformed series. Based on the Symmetry relationships (the asterisk
     * denotes the complex conjugate)
     *
     * F_{N-n} = F_n^{*} for a purely real f transformed to F
     *
     * G_{N-n} = G_n^{*} for a purely imaginary g transformed to G
     *
     */
    reconstructTwoRealFFT: function(t, r, n) {
      var a = t.re.length;
      r.re[0] = t.re[0], r.im[0] = 0, n.re[0] = t.im[0], n.im[0] = 0;
      for (var s, o, h, l, f, b = a / 2; b > 0; b--)
        f = a - b, s = 0.5 * (t.re[b] - t.re[f]), o = 0.5 * (t.re[b] + t.re[f]), h = 0.5 * (t.im[b] - t.im[f]), l = 0.5 * (t.im[b] + t.im[f]), r.re[b] = o, r.im[b] = h, r.re[f] = o, r.im[f] = -h, n.re[b] = l, n.im[b] = -s, n.re[f] = l, n.im[f] = s;
    },
    /**
     * In place version of convolute 2D
     *
     * @param ftSignal
     * @param ftFilter
     * @param ftRows
     * @param ftCols
     * @return
     */
    convolute2DI: function(t, r, n, a) {
      for (var s, o, h = 0; h < n / 2; h++)
        for (var l = 0; l < a; l++)
          s = t[h * 2 * a + l] * r[h * 2 * a + l] - t[(h * 2 + 1) * a + l] * r[(h * 2 + 1) * a + l], o = t[h * 2 * a + l] * r[(h * 2 + 1) * a + l] + t[(h * 2 + 1) * a + l] * r[h * 2 * a + l], t[h * 2 * a + l] = s, t[(h * 2 + 1) * a + l] = o;
    },
    /**
     *
     * @param data
     * @param kernel
     * @param nRows
     * @param nCols
     * @returns {*}
     */
    convolute: function(t, r, n, a, s) {
      for (var o = new Array(a * n), h = 0; h < n * a; h++)
        o[h] = t[h];
      o = this.fft2DArray(o, n, a);
      for (var l = r.length, f = r[0].length, b = new Array(a * n), h = 0; h < a * n; h++)
        b[h] = 0;
      for (var w, g, E = Math.floor((l - 1) / 2), k = Math.floor((f - 1) / 2), A = 0; A < l; A++) {
        w = (A - E + n) % n;
        for (var T = 0; T < f; T++)
          g = (T - k + a) % a, b[w * a + g] = r[A][T];
      }
      b = this.fft2DArray(b, n, a);
      var C = n * 2, D = a / 2 + 1;
      return this.convolute2DI(o, b, C, D), this.ifft2DArray(o, C, D);
    },
    toRadix2: function(t, r, n) {
      var a, s, o, h, l = n, f = r;
      if (!(n !== 0 && (n & n - 1) === 0)) {
        for (l = 0; n >> ++l != 0; ) ;
        l = 1 << l;
      }
      if (!(r !== 0 && (r & r - 1) === 0)) {
        for (f = 0; r >> ++f != 0; ) ;
        f = 1 << f;
      }
      if (f == r && l == n)
        return { data: t, rows: r, cols: n };
      var b = new Array(f * l), w = Math.floor((f - r) / 2) - r, g = Math.floor((l - n) / 2) - n;
      for (a = 0; a < f; a++)
        for (o = a * l, h = (a - w) % r * n, s = 0; s < l; s++)
          b[o + s] = t[h + (s - g) % n];
      return { data: b, rows: f, cols: l };
    },
    /**
     * Crop the given matrix to fit the corresponding number of rows and columns
     */
    crop: function(t, r, n, a, s, o) {
      if (r == a && n == s)
        return t;
      Object.assign({}, o);
      var h = new Array(s * a), l = Math.floor((r - a) / 2), f = Math.floor((n - s) / 2), b, w, g, E;
      for (g = 0; g < a; g++)
        for (b = g * s, w = (g + l) * n, E = 0; E < s; E++)
          h[b + E] = t[w + (E + f)];
      return h;
    }
  };
  return FFTUtils_1 = i, FFTUtils_1;
}
var hasRequiredSrc$2;
function requireSrc$2() {
  return hasRequiredSrc$2 || (hasRequiredSrc$2 = 1, src$2.FFTUtils = requireFFTUtils(), src$2.FFT = requireFftlib()), src$2;
}
var src$1, hasRequiredSrc$1;
function requireSrc$1() {
  if (hasRequiredSrc$1) return src$1;
  hasRequiredSrc$1 = 1;
  var e = requireSrc$2().FFTUtils;
  function i(a, s, o) {
    var h = n(a), l = h.data, f = Object.assign({ normalize: !1, divisor: 1, rows: h.rows, cols: h.cols }, o), b, w;
    if (f.rows && f.cols)
      b = f.rows, w = f.cols;
    else
      throw new Error("Invalid number of rows or columns " + b + " " + w);
    var g = f.divisor, E, k, A = s.length, T = s[0].length;
    if (f.normalize)
      for (g = 0, E = 0; E < A; E++)
        for (k = 0; k < T; k++)
          g += s[E][k];
    if (g === 0)
      throw new RangeError("convolution: The divisor is equal to zero");
    var C = e.toRadix2(l, b, w), D = e.convolute(C.data, s, C.rows, C.cols);
    if (D = e.crop(D, C.rows, C.cols, b, w), g != 0 && g != 1)
      for (E = 0; E < D.length; E++)
        D[E] /= g;
    return D;
  }
  function t(a, s, o) {
    var h = n(a), l = h.data, f = Object.assign({ normalize: !1, divisor: 1, rows: h.rows, cols: h.cols }, o), b, w;
    if (f.rows && f.cols)
      b = f.rows, w = f.cols;
    else
      throw new Error("Invalid number of rows or columns " + b + " " + w);
    var g = f.divisor, E = s.length, k = s[0].length, A, T, C, D, $, P, z, B, F;
    if (f.normalize)
      for (g = 0, A = 0; A < E; A++)
        for (T = 0; T < k; T++)
          g += s[A][T];
    if (g === 0)
      throw new RangeError("convolution: The divisor is equal to zero");
    var O = new Array(b * w), N = Math.floor(E / 2), G = Math.floor(k / 2);
    for (D = 0; D < b; D++)
      for (C = 0; C < w; C++) {
        for (P = 0, T = 0; T < E; T++)
          for (A = 0; A < k; A++)
            z = s[E - T - 1][k - A - 1], B = (D + T - N + b) % b, F = (C + A - G + w) % w, $ = B * w + F, P += l[$] * z;
        $ = D * w + C, O[$] = P / g;
      }
    return O;
  }
  function r(a, s, o) {
    var h = 1e3;
    o && o.factor && (h = o.factor);
    var l = new Array(s), f, b, w, g;
    h *= -1;
    var E = (s - 1) / 2, k = 2 * a * a;
    for (f = 0; f < s; f++)
      for (l[f] = new Array(s), g = (f - E) * (f - E), b = 0; b < s; b++)
        w = -((b - E) * (b - E) + g) / k, l[f][b] = Math.round(h * (1 + w) * Math.exp(w));
    return l;
  }
  function n(a) {
    var s = a, o, h;
    if (typeof a[0] != "number") {
      o = a.length, h = a[0].length, s = new Array(o * h);
      for (var l = 0; l < o; l++)
        for (var f = 0; f < h; f++)
          s[l * h + f] = a[l][f];
    } else {
      var b = Math.sqrt(a.length);
      Number.isInteger(b) && (o = b, h = b);
    }
    return { data: s, rows: o, cols: h };
  }
  return src$1 = {
    fft: i,
    direct: t,
    kernelFactory: { LoG: r },
    matrix2Array: n
  }, src$1;
}
var srcExports$1 = requireSrc$1(), _isFinite, hasRequired_isFinite;
function require_isFinite() {
  return hasRequired_isFinite || (hasRequired_isFinite = 1, _isFinite = Number.isFinite || function(e) {
    return !(typeof e != "number" || e !== e || e === 1 / 0 || e === -1 / 0);
  }), _isFinite;
}
var isInteger$1, hasRequiredIsInteger;
function requireIsInteger() {
  if (hasRequiredIsInteger) return isInteger$1;
  hasRequiredIsInteger = 1;
  var e = require_isFinite();
  return isInteger$1 = Number.isInteger || function(i) {
    return typeof i == "number" && e(i) && Math.floor(i) === i;
  }, isInteger$1;
}
var isIntegerExports = requireIsInteger();
const isInteger = /* @__PURE__ */ getDefaultExportFromCjs(isIntegerExports);
function validateKernel(e) {
  let i, t;
  if (Array.isArray(e))
    if (Array.isArray(e[0])) {
      if ((e.length & 1) === 0 || (e[0].length & 1) === 0)
        throw new RangeError(
          "validateKernel: Kernel rows and columns should be odd numbers"
        );
      i = Math.floor(e.length / 2), t = Math.floor(e[0].length / 2);
    } else {
      let r = Math.sqrt(e.length);
      if (isInteger(r))
        t = i = Math.floor(Math.sqrt(e.length) / 2);
      else
        throw new RangeError("validateKernel: Kernel array should be a square");
      let n = new Array(r);
      for (let a = 0; a < r; a++) {
        n[a] = new Array(r);
        for (let s = 0; s < r; s++)
          n[a][s] = e[a * r + s];
      }
      e = n;
    }
  else
    throw new Error(`validateKernel: Invalid Kernel: ${e}`);
  return { kernel: e, kWidth: t, kHeight: i };
}
function clamp(e, i) {
  return Math.round(Math.min(Math.max(e, 0), i.maxValue));
}
function directConvolution(e, i, t) {
  if (t === void 0) {
    const a = e.length + i.length - 1;
    t = new Array(a);
  }
  fill(t);
  for (var r = 0; r < e.length; r++)
    for (var n = 0; n < i.length; n++)
      t[r + n] += e[r] * i[n];
  return t;
}
function fill(e) {
  for (var i = 0; i < e.length; i++)
    e[i] = 0;
}
var fft, hasRequiredFft;
function requireFft() {
  if (hasRequiredFft) return fft;
  hasRequiredFft = 1;
  function e(i) {
    if (this.size = i | 0, this.size <= 1 || (this.size & this.size - 1) !== 0)
      throw new Error("FFT size must be a power of two and bigger than 1");
    this._csize = i << 1;
    for (var t = new Array(this.size * 2), r = 0; r < t.length; r += 2) {
      const l = Math.PI * r / this.size;
      t[r] = Math.cos(l), t[r + 1] = -Math.sin(l);
    }
    this.table = t;
    for (var n = 0, a = 1; this.size > a; a <<= 1)
      n++;
    this._width = n % 2 === 0 ? n - 1 : n, this._bitrev = new Array(1 << this._width);
    for (var s = 0; s < this._bitrev.length; s++) {
      this._bitrev[s] = 0;
      for (var o = 0; o < this._width; o += 2) {
        var h = this._width - o - 2;
        this._bitrev[s] |= (s >>> o & 3) << h;
      }
    }
    this._out = null, this._data = null, this._inv = 0;
  }
  return fft = e, e.prototype.fromComplexArray = function(t, r) {
    for (var n = r || new Array(t.length >>> 1), a = 0; a < t.length; a += 2)
      n[a >>> 1] = t[a];
    return n;
  }, e.prototype.createComplexArray = function() {
    const t = new Array(this._csize);
    for (var r = 0; r < t.length; r++)
      t[r] = 0;
    return t;
  }, e.prototype.toComplexArray = function(t, r) {
    for (var n = r || this.createComplexArray(), a = 0; a < n.length; a += 2)
      n[a] = t[a >>> 1], n[a + 1] = 0;
    return n;
  }, e.prototype.completeSpectrum = function(t) {
    for (var r = this._csize, n = r >>> 1, a = 2; a < n; a += 2)
      t[r - a] = t[a], t[r - a + 1] = -t[a + 1];
  }, e.prototype.transform = function(t, r) {
    if (t === r)
      throw new Error("Input and output buffers must be different");
    this._out = t, this._data = r, this._inv = 0, this._transform4(), this._out = null, this._data = null;
  }, e.prototype.realTransform = function(t, r) {
    if (t === r)
      throw new Error("Input and output buffers must be different");
    this._out = t, this._data = r, this._inv = 0, this._realTransform4(), this._out = null, this._data = null;
  }, e.prototype.inverseTransform = function(t, r) {
    if (t === r)
      throw new Error("Input and output buffers must be different");
    this._out = t, this._data = r, this._inv = 1, this._transform4();
    for (var n = 0; n < t.length; n++)
      t[n] /= this.size;
    this._out = null, this._data = null;
  }, e.prototype._transform4 = function() {
    var t = this._out, r = this._csize, n = this._width, a = 1 << n, s = r / a << 1, o, h, l = this._bitrev;
    if (s === 4)
      for (o = 0, h = 0; o < r; o += s, h++) {
        const A = l[h];
        this._singleTransform2(o, A, a);
      }
    else
      for (o = 0, h = 0; o < r; o += s, h++) {
        const A = l[h];
        this._singleTransform4(o, A, a);
      }
    var f = this._inv ? -1 : 1, b = this.table;
    for (a >>= 2; a >= 2; a >>= 2) {
      s = r / a << 1;
      var w = s >>> 2;
      for (o = 0; o < r; o += s)
        for (var g = o + w, E = o, k = 0; E < g; E += 2, k += a) {
          const A = E, T = A + w, C = T + w, D = C + w, $ = t[A], P = t[A + 1], z = t[T], B = t[T + 1], F = t[C], O = t[C + 1], N = t[D], G = t[D + 1], V = $, J = P, Q = b[k], W = f * b[k + 1], ne = z * Q - B * W, pe = z * W + B * Q, be = b[2 * k], ve = f * b[2 * k + 1], Ee = F * be - O * ve, Ae = F * ve + O * be, _e = b[3 * k], Be = f * b[3 * k + 1], Me = N * _e - G * Be, re = N * Be + G * _e, Te = V + Ee, Fe = J + Ae, Se = V - Ee, Ye = J - Ae, Je = ne + Me, et = pe + re, Ve = f * (ne - Me), tt = f * (pe - re), qe = Te + Je, Re = Fe + et, nt = Te - Je, Ge = Fe - et, Ne = Se + tt, he = Ye - Ve, Qe = Se - tt, Ze = Ye + Ve;
          t[A] = qe, t[A + 1] = Re, t[T] = Ne, t[T + 1] = he, t[C] = nt, t[C + 1] = Ge, t[D] = Qe, t[D + 1] = Ze;
        }
    }
  }, e.prototype._singleTransform2 = function(t, r, n) {
    const a = this._out, s = this._data, o = s[r], h = s[r + 1], l = s[r + n], f = s[r + n + 1], b = o + l, w = h + f, g = o - l, E = h - f;
    a[t] = b, a[t + 1] = w, a[t + 2] = g, a[t + 3] = E;
  }, e.prototype._singleTransform4 = function(t, r, n) {
    const a = this._out, s = this._data, o = this._inv ? -1 : 1, h = n * 2, l = n * 3, f = s[r], b = s[r + 1], w = s[r + n], g = s[r + n + 1], E = s[r + h], k = s[r + h + 1], A = s[r + l], T = s[r + l + 1], C = f + E, D = b + k, $ = f - E, P = b - k, z = w + A, B = g + T, F = o * (w - A), O = o * (g - T), N = C + z, G = D + B, V = $ + O, J = P - F, Q = C - z, W = D - B, ne = $ - O, pe = P + F;
    a[t] = N, a[t + 1] = G, a[t + 2] = V, a[t + 3] = J, a[t + 4] = Q, a[t + 5] = W, a[t + 6] = ne, a[t + 7] = pe;
  }, e.prototype._realTransform4 = function() {
    var t = this._out, r = this._csize, n = this._width, a = 1 << n, s = r / a << 1, o, h, l = this._bitrev;
    if (s === 4)
      for (o = 0, h = 0; o < r; o += s, h++) {
        const te = l[h];
        this._singleRealTransform2(o, te >>> 1, a >>> 1);
      }
    else
      for (o = 0, h = 0; o < r; o += s, h++) {
        const te = l[h];
        this._singleRealTransform4(o, te >>> 1, a >>> 1);
      }
    var f = this._inv ? -1 : 1, b = this.table;
    for (a >>= 2; a >= 2; a >>= 2) {
      s = r / a << 1;
      var w = s >>> 1, g = w >>> 1, E = g >>> 1;
      for (o = 0; o < r; o += s)
        for (var k = 0, A = 0; k <= E; k += 2, A += a) {
          var T = o + k, C = T + g, D = C + g, $ = D + g, P = t[T], z = t[T + 1], B = t[C], F = t[C + 1], O = t[D], N = t[D + 1], G = t[$], V = t[$ + 1], J = P, Q = z, W = b[A], ne = f * b[A + 1], pe = B * W - F * ne, be = B * ne + F * W, ve = b[2 * A], Ee = f * b[2 * A + 1], Ae = O * ve - N * Ee, _e = O * Ee + N * ve, Be = b[3 * A], Me = f * b[3 * A + 1], re = G * Be - V * Me, Te = G * Me + V * Be, Fe = J + Ae, Se = Q + _e, Ye = J - Ae, Je = Q - _e, et = pe + re, Ve = be + Te, tt = f * (pe - re), qe = f * (be - Te), Re = Fe + et, nt = Se + Ve, Ge = Ye + qe, Ne = Je - tt;
          if (t[T] = Re, t[T + 1] = nt, t[C] = Ge, t[C + 1] = Ne, k === 0) {
            var he = Fe - et, Qe = Se - Ve;
            t[D] = he, t[D + 1] = Qe;
            continue;
          }
          if (k !== E) {
            var Ze = Ye, He = -Je, De = Fe, lt = -Se, ot = -f * qe, Le = -f * tt, ze = -f * Ve, je = -f * et, Oe = Ze + ot, st = He + Le, Z = De + je, ue = lt - ze, xe = o + g - k, ke = o + w - k;
            t[xe] = Oe, t[xe + 1] = st, t[ke] = Z, t[ke + 1] = ue;
          }
        }
    }
  }, e.prototype._singleRealTransform2 = function(t, r, n) {
    const a = this._out, s = this._data, o = s[r], h = s[r + n], l = o + h, f = o - h;
    a[t] = l, a[t + 1] = 0, a[t + 2] = f, a[t + 3] = 0;
  }, e.prototype._singleRealTransform4 = function(t, r, n) {
    const a = this._out, s = this._data, o = this._inv ? -1 : 1, h = n * 2, l = n * 3, f = s[r], b = s[r + n], w = s[r + h], g = s[r + l], E = f + w, k = f - w, A = b + g, T = o * (b - g), C = E + A, D = k, $ = -T, P = E - A, z = k, B = T;
    a[t] = C, a[t + 1] = 0, a[t + 2] = D, a[t + 3] = $, a[t + 4] = P, a[t + 5] = 0, a[t + 6] = z, a[t + 7] = B;
  }, fft;
}
requireFft();
function convolutionSeparable(e, i, t, r) {
  const n = new Array(e.length);
  let a, s, o, h;
  h = i[1], o = (h.length - 1) / 2, s = new Array(t + h.length - 1), a = new Array(t);
  for (let l = 0; l < r; l++) {
    for (let f = 0; f < t; f++)
      a[f] = e[l * t + f];
    directConvolution(a, h, s);
    for (let f = 0; f < t; f++)
      n[l * t + f] = s[o + f];
  }
  h = i[0], o = (h.length - 1) / 2, s = new Array(r + h.length - 1), a = new Array(r);
  for (let l = 0; l < t; l++) {
    for (let f = 0; f < r; f++)
      a[f] = n[f * t + l];
    directConvolution(a, h, s);
    for (let f = 0; f < r; f++)
      n[f * t + l] = s[o + f];
  }
  return n;
}
var matrix$1 = {};
const toString = Object.prototype.toString;
function isAnyArray(e) {
  const i = toString.call(e);
  return i.endsWith("Array]") && !i.includes("Big");
}
const libEsm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isAnyArray
}, Symbol.toStringTag, { value: "Module" })), require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(libEsm);
function max$1(e) {
  var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray(e))
    throw new TypeError("input must be an array");
  if (e.length === 0)
    throw new TypeError("input must not be empty");
  var t = i.fromIndex, r = t === void 0 ? 0 : t, n = i.toIndex, a = n === void 0 ? e.length : n;
  if (r < 0 || r >= e.length || !Number.isInteger(r))
    throw new Error("fromIndex must be a positive integer smaller than length");
  if (a <= r || a > e.length || !Number.isInteger(a))
    throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");
  for (var s = e[r], o = r + 1; o < a; o++)
    e[o] > s && (s = e[o]);
  return s;
}
function min$1(e) {
  var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray(e))
    throw new TypeError("input must be an array");
  if (e.length === 0)
    throw new TypeError("input must not be empty");
  var t = i.fromIndex, r = t === void 0 ? 0 : t, n = i.toIndex, a = n === void 0 ? e.length : n;
  if (r < 0 || r >= e.length || !Number.isInteger(r))
    throw new Error("fromIndex must be a positive integer smaller than length");
  if (a <= r || a > e.length || !Number.isInteger(a))
    throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");
  for (var s = e[r], o = r + 1; o < a; o++)
    e[o] < s && (s = e[o]);
  return s;
}
function rescale(e) {
  var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (isAnyArray(e)) {
    if (e.length === 0)
      throw new TypeError("input must not be empty");
  } else throw new TypeError("input must be an array");
  var t;
  if (i.output !== void 0) {
    if (!isAnyArray(i.output))
      throw new TypeError("output option must be an array if specified");
    t = i.output;
  } else
    t = new Array(e.length);
  var r = min$1(e), n = max$1(e);
  if (r === n)
    throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");
  var a = i.min, s = a === void 0 ? i.autoMinMax ? r : 0 : a, o = i.max, h = o === void 0 ? i.autoMinMax ? n : 1 : o;
  if (s >= h)
    throw new RangeError("min option must be smaller than max option");
  for (var l = (h - s) / (n - r), f = 0; f < e.length; f++)
    t[f] = (e[f] - r) * l + s;
  return t;
}
const libEs6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: rescale
}, Symbol.toStringTag, { value: "Module" })), require$$1 = /* @__PURE__ */ getAugmentedNamespace(libEs6);
var hasRequiredMatrix;
function requireMatrix() {
  var de, Ct, oe;
  if (hasRequiredMatrix) return matrix$1;
  hasRequiredMatrix = 1, Object.defineProperty(matrix$1, "__esModule", { value: !0 });
  var e = require$$0$1, i = require$$1;
  const t = " ".repeat(2), r = " ".repeat(4);
  function n() {
    return a(this);
  }
  function a(M, _ = {}) {
    const {
      maxRows: d = 15,
      maxColumns: u = 10,
      maxNumSize: v = 8,
      padMinus: S = "auto"
    } = _;
    return `${M.constructor.name} {
${t}[
${r}${s(M, d, u, v, S)}
${t}]
${t}rows: ${M.rows}
${t}columns: ${M.columns}
}`;
  }
  function s(M, _, d, u, v) {
    const { rows: S, columns: L } = M, q = Math.min(S, _), X = Math.min(L, d), j = [];
    if (v === "auto") {
      v = !1;
      e: for (let ae = 0; ae < q; ae++)
        for (let K = 0; K < X; K++)
          if (M.get(ae, K) < 0) {
            v = !0;
            break e;
          }
    }
    for (let ae = 0; ae < q; ae++) {
      let K = [];
      for (let ce = 0; ce < X; ce++)
        K.push(o(M.get(ae, ce), u, v));
      j.push(`${K.join(" ")}`);
    }
    return X !== L && (j[j.length - 1] += ` ... ${L - d} more columns`), q !== S && j.push(`... ${S - _} more rows`), j.join(`
${r}`);
  }
  function o(M, _, d) {
    return (M >= 0 && d ? ` ${h(M, _ - 1)}` : h(M, _)).padEnd(_);
  }
  function h(M, _) {
    let d = M.toString();
    if (d.length <= _) return d;
    let u = M.toFixed(_);
    if (u.length > _ && (u = M.toFixed(Math.max(0, _ - (u.length - _)))), u.length <= _ && !u.startsWith("0.000") && !u.startsWith("-0.000"))
      return u;
    let v = M.toExponential(_);
    return v.length > _ && (v = M.toExponential(Math.max(0, _ - (v.length - _)))), v.slice(0);
  }
  function l(M, _) {
    M.prototype.add = function(u) {
      return typeof u == "number" ? this.addS(u) : this.addM(u);
    }, M.prototype.addS = function(u) {
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) + u);
      return this;
    }, M.prototype.addM = function(u) {
      if (u = _.checkMatrix(u), this.rows !== u.rows || this.columns !== u.columns)
        throw new RangeError("Matrices dimensions must be equal");
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) + u.get(v, S));
      return this;
    }, M.add = function(u, v) {
      return new _(u).add(v);
    }, M.prototype.sub = function(u) {
      return typeof u == "number" ? this.subS(u) : this.subM(u);
    }, M.prototype.subS = function(u) {
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) - u);
      return this;
    }, M.prototype.subM = function(u) {
      if (u = _.checkMatrix(u), this.rows !== u.rows || this.columns !== u.columns)
        throw new RangeError("Matrices dimensions must be equal");
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) - u.get(v, S));
      return this;
    }, M.sub = function(u, v) {
      return new _(u).sub(v);
    }, M.prototype.subtract = M.prototype.sub, M.prototype.subtractS = M.prototype.subS, M.prototype.subtractM = M.prototype.subM, M.subtract = M.sub, M.prototype.mul = function(u) {
      return typeof u == "number" ? this.mulS(u) : this.mulM(u);
    }, M.prototype.mulS = function(u) {
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) * u);
      return this;
    }, M.prototype.mulM = function(u) {
      if (u = _.checkMatrix(u), this.rows !== u.rows || this.columns !== u.columns)
        throw new RangeError("Matrices dimensions must be equal");
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) * u.get(v, S));
      return this;
    }, M.mul = function(u, v) {
      return new _(u).mul(v);
    }, M.prototype.multiply = M.prototype.mul, M.prototype.multiplyS = M.prototype.mulS, M.prototype.multiplyM = M.prototype.mulM, M.multiply = M.mul, M.prototype.div = function(u) {
      return typeof u == "number" ? this.divS(u) : this.divM(u);
    }, M.prototype.divS = function(u) {
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) / u);
      return this;
    }, M.prototype.divM = function(u) {
      if (u = _.checkMatrix(u), this.rows !== u.rows || this.columns !== u.columns)
        throw new RangeError("Matrices dimensions must be equal");
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) / u.get(v, S));
      return this;
    }, M.div = function(u, v) {
      return new _(u).div(v);
    }, M.prototype.divide = M.prototype.div, M.prototype.divideS = M.prototype.divS, M.prototype.divideM = M.prototype.divM, M.divide = M.div, M.prototype.mod = function(u) {
      return typeof u == "number" ? this.modS(u) : this.modM(u);
    }, M.prototype.modS = function(u) {
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) % u);
      return this;
    }, M.prototype.modM = function(u) {
      if (u = _.checkMatrix(u), this.rows !== u.rows || this.columns !== u.columns)
        throw new RangeError("Matrices dimensions must be equal");
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) % u.get(v, S));
      return this;
    }, M.mod = function(u, v) {
      return new _(u).mod(v);
    }, M.prototype.modulus = M.prototype.mod, M.prototype.modulusS = M.prototype.modS, M.prototype.modulusM = M.prototype.modM, M.modulus = M.mod, M.prototype.and = function(u) {
      return typeof u == "number" ? this.andS(u) : this.andM(u);
    }, M.prototype.andS = function(u) {
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) & u);
      return this;
    }, M.prototype.andM = function(u) {
      if (u = _.checkMatrix(u), this.rows !== u.rows || this.columns !== u.columns)
        throw new RangeError("Matrices dimensions must be equal");
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) & u.get(v, S));
      return this;
    }, M.and = function(u, v) {
      return new _(u).and(v);
    }, M.prototype.or = function(u) {
      return typeof u == "number" ? this.orS(u) : this.orM(u);
    }, M.prototype.orS = function(u) {
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) | u);
      return this;
    }, M.prototype.orM = function(u) {
      if (u = _.checkMatrix(u), this.rows !== u.rows || this.columns !== u.columns)
        throw new RangeError("Matrices dimensions must be equal");
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) | u.get(v, S));
      return this;
    }, M.or = function(u, v) {
      return new _(u).or(v);
    }, M.prototype.xor = function(u) {
      return typeof u == "number" ? this.xorS(u) : this.xorM(u);
    }, M.prototype.xorS = function(u) {
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) ^ u);
      return this;
    }, M.prototype.xorM = function(u) {
      if (u = _.checkMatrix(u), this.rows !== u.rows || this.columns !== u.columns)
        throw new RangeError("Matrices dimensions must be equal");
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) ^ u.get(v, S));
      return this;
    }, M.xor = function(u, v) {
      return new _(u).xor(v);
    }, M.prototype.leftShift = function(u) {
      return typeof u == "number" ? this.leftShiftS(u) : this.leftShiftM(u);
    }, M.prototype.leftShiftS = function(u) {
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) << u);
      return this;
    }, M.prototype.leftShiftM = function(u) {
      if (u = _.checkMatrix(u), this.rows !== u.rows || this.columns !== u.columns)
        throw new RangeError("Matrices dimensions must be equal");
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) << u.get(v, S));
      return this;
    }, M.leftShift = function(u, v) {
      return new _(u).leftShift(v);
    }, M.prototype.signPropagatingRightShift = function(u) {
      return typeof u == "number" ? this.signPropagatingRightShiftS(u) : this.signPropagatingRightShiftM(u);
    }, M.prototype.signPropagatingRightShiftS = function(u) {
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) >> u);
      return this;
    }, M.prototype.signPropagatingRightShiftM = function(u) {
      if (u = _.checkMatrix(u), this.rows !== u.rows || this.columns !== u.columns)
        throw new RangeError("Matrices dimensions must be equal");
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) >> u.get(v, S));
      return this;
    }, M.signPropagatingRightShift = function(u, v) {
      return new _(u).signPropagatingRightShift(v);
    }, M.prototype.rightShift = function(u) {
      return typeof u == "number" ? this.rightShiftS(u) : this.rightShiftM(u);
    }, M.prototype.rightShiftS = function(u) {
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) >>> u);
      return this;
    }, M.prototype.rightShiftM = function(u) {
      if (u = _.checkMatrix(u), this.rows !== u.rows || this.columns !== u.columns)
        throw new RangeError("Matrices dimensions must be equal");
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) >>> u.get(v, S));
      return this;
    }, M.rightShift = function(u, v) {
      return new _(u).rightShift(v);
    }, M.prototype.zeroFillRightShift = M.prototype.rightShift, M.prototype.zeroFillRightShiftS = M.prototype.rightShiftS, M.prototype.zeroFillRightShiftM = M.prototype.rightShiftM, M.zeroFillRightShift = M.rightShift, M.prototype.not = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, ~this.get(u, v));
      return this;
    }, M.not = function(u) {
      return new _(u).not();
    }, M.prototype.abs = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.abs(this.get(u, v)));
      return this;
    }, M.abs = function(u) {
      return new _(u).abs();
    }, M.prototype.acos = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.acos(this.get(u, v)));
      return this;
    }, M.acos = function(u) {
      return new _(u).acos();
    }, M.prototype.acosh = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.acosh(this.get(u, v)));
      return this;
    }, M.acosh = function(u) {
      return new _(u).acosh();
    }, M.prototype.asin = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.asin(this.get(u, v)));
      return this;
    }, M.asin = function(u) {
      return new _(u).asin();
    }, M.prototype.asinh = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.asinh(this.get(u, v)));
      return this;
    }, M.asinh = function(u) {
      return new _(u).asinh();
    }, M.prototype.atan = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.atan(this.get(u, v)));
      return this;
    }, M.atan = function(u) {
      return new _(u).atan();
    }, M.prototype.atanh = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.atanh(this.get(u, v)));
      return this;
    }, M.atanh = function(u) {
      return new _(u).atanh();
    }, M.prototype.cbrt = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.cbrt(this.get(u, v)));
      return this;
    }, M.cbrt = function(u) {
      return new _(u).cbrt();
    }, M.prototype.ceil = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.ceil(this.get(u, v)));
      return this;
    }, M.ceil = function(u) {
      return new _(u).ceil();
    }, M.prototype.clz32 = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.clz32(this.get(u, v)));
      return this;
    }, M.clz32 = function(u) {
      return new _(u).clz32();
    }, M.prototype.cos = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.cos(this.get(u, v)));
      return this;
    }, M.cos = function(u) {
      return new _(u).cos();
    }, M.prototype.cosh = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.cosh(this.get(u, v)));
      return this;
    }, M.cosh = function(u) {
      return new _(u).cosh();
    }, M.prototype.exp = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.exp(this.get(u, v)));
      return this;
    }, M.exp = function(u) {
      return new _(u).exp();
    }, M.prototype.expm1 = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.expm1(this.get(u, v)));
      return this;
    }, M.expm1 = function(u) {
      return new _(u).expm1();
    }, M.prototype.floor = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.floor(this.get(u, v)));
      return this;
    }, M.floor = function(u) {
      return new _(u).floor();
    }, M.prototype.fround = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.fround(this.get(u, v)));
      return this;
    }, M.fround = function(u) {
      return new _(u).fround();
    }, M.prototype.log = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.log(this.get(u, v)));
      return this;
    }, M.log = function(u) {
      return new _(u).log();
    }, M.prototype.log1p = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.log1p(this.get(u, v)));
      return this;
    }, M.log1p = function(u) {
      return new _(u).log1p();
    }, M.prototype.log10 = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.log10(this.get(u, v)));
      return this;
    }, M.log10 = function(u) {
      return new _(u).log10();
    }, M.prototype.log2 = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.log2(this.get(u, v)));
      return this;
    }, M.log2 = function(u) {
      return new _(u).log2();
    }, M.prototype.round = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.round(this.get(u, v)));
      return this;
    }, M.round = function(u) {
      return new _(u).round();
    }, M.prototype.sign = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.sign(this.get(u, v)));
      return this;
    }, M.sign = function(u) {
      return new _(u).sign();
    }, M.prototype.sin = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.sin(this.get(u, v)));
      return this;
    }, M.sin = function(u) {
      return new _(u).sin();
    }, M.prototype.sinh = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.sinh(this.get(u, v)));
      return this;
    }, M.sinh = function(u) {
      return new _(u).sinh();
    }, M.prototype.sqrt = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.sqrt(this.get(u, v)));
      return this;
    }, M.sqrt = function(u) {
      return new _(u).sqrt();
    }, M.prototype.tan = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.tan(this.get(u, v)));
      return this;
    }, M.tan = function(u) {
      return new _(u).tan();
    }, M.prototype.tanh = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.tanh(this.get(u, v)));
      return this;
    }, M.tanh = function(u) {
      return new _(u).tanh();
    }, M.prototype.trunc = function() {
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.set(u, v, Math.trunc(this.get(u, v)));
      return this;
    }, M.trunc = function(u) {
      return new _(u).trunc();
    }, M.pow = function(u, v) {
      return new _(u).pow(v);
    }, M.prototype.pow = function(u) {
      return typeof u == "number" ? this.powS(u) : this.powM(u);
    }, M.prototype.powS = function(u) {
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) ** u);
      return this;
    }, M.prototype.powM = function(u) {
      if (u = _.checkMatrix(u), this.rows !== u.rows || this.columns !== u.columns)
        throw new RangeError("Matrices dimensions must be equal");
      for (let v = 0; v < this.rows; v++)
        for (let S = 0; S < this.columns; S++)
          this.set(v, S, this.get(v, S) ** u.get(v, S));
      return this;
    };
  }
  function f(M, _, d) {
    let u = d ? M.rows : M.rows - 1;
    if (_ < 0 || _ > u)
      throw new RangeError("Row index out of range");
  }
  function b(M, _, d) {
    let u = d ? M.columns : M.columns - 1;
    if (_ < 0 || _ > u)
      throw new RangeError("Column index out of range");
  }
  function w(M, _) {
    if (_.to1DArray && (_ = _.to1DArray()), _.length !== M.columns)
      throw new RangeError(
        "vector size must be the same as the number of columns"
      );
    return _;
  }
  function g(M, _) {
    if (_.to1DArray && (_ = _.to1DArray()), _.length !== M.rows)
      throw new RangeError("vector size must be the same as the number of rows");
    return _;
  }
  function E(M, _) {
    if (!e.isAnyArray(_))
      throw new TypeError("row indices must be an array");
    for (let d = 0; d < _.length; d++)
      if (_[d] < 0 || _[d] >= M.rows)
        throw new RangeError("row indices are out of range");
  }
  function k(M, _) {
    if (!e.isAnyArray(_))
      throw new TypeError("column indices must be an array");
    for (let d = 0; d < _.length; d++)
      if (_[d] < 0 || _[d] >= M.columns)
        throw new RangeError("column indices are out of range");
  }
  function A(M, _, d, u, v) {
    if (arguments.length !== 5)
      throw new RangeError("expected 4 arguments");
    if (C("startRow", _), C("endRow", d), C("startColumn", u), C("endColumn", v), _ > d || u > v || _ < 0 || _ >= M.rows || d < 0 || d >= M.rows || u < 0 || u >= M.columns || v < 0 || v >= M.columns)
      throw new RangeError("Submatrix indices are out of range");
  }
  function T(M, _ = 0) {
    let d = [];
    for (let u = 0; u < M; u++)
      d.push(_);
    return d;
  }
  function C(M, _) {
    if (typeof _ != "number")
      throw new TypeError(`${M} must be a number`);
  }
  function D(M) {
    if (M.isEmpty())
      throw new Error("Empty matrix has no elements to index");
  }
  function $(M) {
    let _ = T(M.rows);
    for (let d = 0; d < M.rows; ++d)
      for (let u = 0; u < M.columns; ++u)
        _[d] += M.get(d, u);
    return _;
  }
  function P(M) {
    let _ = T(M.columns);
    for (let d = 0; d < M.rows; ++d)
      for (let u = 0; u < M.columns; ++u)
        _[u] += M.get(d, u);
    return _;
  }
  function z(M) {
    let _ = 0;
    for (let d = 0; d < M.rows; d++)
      for (let u = 0; u < M.columns; u++)
        _ += M.get(d, u);
    return _;
  }
  function B(M) {
    let _ = T(M.rows, 1);
    for (let d = 0; d < M.rows; ++d)
      for (let u = 0; u < M.columns; ++u)
        _[d] *= M.get(d, u);
    return _;
  }
  function F(M) {
    let _ = T(M.columns, 1);
    for (let d = 0; d < M.rows; ++d)
      for (let u = 0; u < M.columns; ++u)
        _[u] *= M.get(d, u);
    return _;
  }
  function O(M) {
    let _ = 1;
    for (let d = 0; d < M.rows; d++)
      for (let u = 0; u < M.columns; u++)
        _ *= M.get(d, u);
    return _;
  }
  function N(M, _, d) {
    const u = M.rows, v = M.columns, S = [];
    for (let L = 0; L < u; L++) {
      let q = 0, X = 0, j = 0;
      for (let ae = 0; ae < v; ae++)
        j = M.get(L, ae) - d[L], q += j, X += j * j;
      _ ? S.push((X - q * q / v) / (v - 1)) : S.push((X - q * q / v) / v);
    }
    return S;
  }
  function G(M, _, d) {
    const u = M.rows, v = M.columns, S = [];
    for (let L = 0; L < v; L++) {
      let q = 0, X = 0, j = 0;
      for (let ae = 0; ae < u; ae++)
        j = M.get(ae, L) - d[L], q += j, X += j * j;
      _ ? S.push((X - q * q / u) / (u - 1)) : S.push((X - q * q / u) / u);
    }
    return S;
  }
  function V(M, _, d) {
    const u = M.rows, v = M.columns, S = u * v;
    let L = 0, q = 0, X = 0;
    for (let j = 0; j < u; j++)
      for (let ae = 0; ae < v; ae++)
        X = M.get(j, ae) - d, L += X, q += X * X;
    return _ ? (q - L * L / S) / (S - 1) : (q - L * L / S) / S;
  }
  function J(M, _) {
    for (let d = 0; d < M.rows; d++)
      for (let u = 0; u < M.columns; u++)
        M.set(d, u, M.get(d, u) - _[d]);
  }
  function Q(M, _) {
    for (let d = 0; d < M.rows; d++)
      for (let u = 0; u < M.columns; u++)
        M.set(d, u, M.get(d, u) - _[u]);
  }
  function W(M, _) {
    for (let d = 0; d < M.rows; d++)
      for (let u = 0; u < M.columns; u++)
        M.set(d, u, M.get(d, u) - _);
  }
  function ne(M) {
    const _ = [];
    for (let d = 0; d < M.rows; d++) {
      let u = 0;
      for (let v = 0; v < M.columns; v++)
        u += M.get(d, v) ** 2 / (M.columns - 1);
      _.push(Math.sqrt(u));
    }
    return _;
  }
  function pe(M, _) {
    for (let d = 0; d < M.rows; d++)
      for (let u = 0; u < M.columns; u++)
        M.set(d, u, M.get(d, u) / _[d]);
  }
  function be(M) {
    const _ = [];
    for (let d = 0; d < M.columns; d++) {
      let u = 0;
      for (let v = 0; v < M.rows; v++)
        u += M.get(v, d) ** 2 / (M.rows - 1);
      _.push(Math.sqrt(u));
    }
    return _;
  }
  function ve(M, _) {
    for (let d = 0; d < M.rows; d++)
      for (let u = 0; u < M.columns; u++)
        M.set(d, u, M.get(d, u) / _[u]);
  }
  function Ee(M) {
    const _ = M.size - 1;
    let d = 0;
    for (let u = 0; u < M.columns; u++)
      for (let v = 0; v < M.rows; v++)
        d += M.get(v, u) ** 2 / _;
    return Math.sqrt(d);
  }
  function Ae(M, _) {
    for (let d = 0; d < M.rows; d++)
      for (let u = 0; u < M.columns; u++)
        M.set(d, u, M.get(d, u) / _);
  }
  class _e {
    static from1DArray(_, d, u) {
      if (_ * d !== u.length)
        throw new RangeError("data length does not match given dimensions");
      let S = new re(_, d);
      for (let L = 0; L < _; L++)
        for (let q = 0; q < d; q++)
          S.set(L, q, u[L * d + q]);
      return S;
    }
    static rowVector(_) {
      let d = new re(1, _.length);
      for (let u = 0; u < _.length; u++)
        d.set(0, u, _[u]);
      return d;
    }
    static columnVector(_) {
      let d = new re(_.length, 1);
      for (let u = 0; u < _.length; u++)
        d.set(u, 0, _[u]);
      return d;
    }
    static zeros(_, d) {
      return new re(_, d);
    }
    static ones(_, d) {
      return new re(_, d).fill(1);
    }
    static rand(_, d, u = {}) {
      if (typeof u != "object")
        throw new TypeError("options must be an object");
      const { random: v = Math.random } = u;
      let S = new re(_, d);
      for (let L = 0; L < _; L++)
        for (let q = 0; q < d; q++)
          S.set(L, q, v());
      return S;
    }
    static randInt(_, d, u = {}) {
      if (typeof u != "object")
        throw new TypeError("options must be an object");
      const { min: v = 0, max: S = 1e3, random: L = Math.random } = u;
      if (!Number.isInteger(v)) throw new TypeError("min must be an integer");
      if (!Number.isInteger(S)) throw new TypeError("max must be an integer");
      if (v >= S) throw new RangeError("min must be smaller than max");
      let q = S - v, X = new re(_, d);
      for (let j = 0; j < _; j++)
        for (let ae = 0; ae < d; ae++) {
          let K = v + Math.round(L() * q);
          X.set(j, ae, K);
        }
      return X;
    }
    static eye(_, d, u) {
      d === void 0 && (d = _), u === void 0 && (u = 1);
      let v = Math.min(_, d), S = this.zeros(_, d);
      for (let L = 0; L < v; L++)
        S.set(L, L, u);
      return S;
    }
    static diag(_, d, u) {
      let v = _.length;
      d === void 0 && (d = v), u === void 0 && (u = d);
      let S = Math.min(v, d, u), L = this.zeros(d, u);
      for (let q = 0; q < S; q++)
        L.set(q, q, _[q]);
      return L;
    }
    static min(_, d) {
      _ = this.checkMatrix(_), d = this.checkMatrix(d);
      let u = _.rows, v = _.columns, S = new re(u, v);
      for (let L = 0; L < u; L++)
        for (let q = 0; q < v; q++)
          S.set(L, q, Math.min(_.get(L, q), d.get(L, q)));
      return S;
    }
    static max(_, d) {
      _ = this.checkMatrix(_), d = this.checkMatrix(d);
      let u = _.rows, v = _.columns, S = new this(u, v);
      for (let L = 0; L < u; L++)
        for (let q = 0; q < v; q++)
          S.set(L, q, Math.max(_.get(L, q), d.get(L, q)));
      return S;
    }
    static checkMatrix(_) {
      return _e.isMatrix(_) ? _ : new re(_);
    }
    static isMatrix(_) {
      return _ != null && _.klass === "Matrix";
    }
    get size() {
      return this.rows * this.columns;
    }
    apply(_) {
      if (typeof _ != "function")
        throw new TypeError("callback must be a function");
      for (let d = 0; d < this.rows; d++)
        for (let u = 0; u < this.columns; u++)
          _.call(this, d, u);
      return this;
    }
    to1DArray() {
      let _ = [];
      for (let d = 0; d < this.rows; d++)
        for (let u = 0; u < this.columns; u++)
          _.push(this.get(d, u));
      return _;
    }
    to2DArray() {
      let _ = [];
      for (let d = 0; d < this.rows; d++) {
        _.push([]);
        for (let u = 0; u < this.columns; u++)
          _[d].push(this.get(d, u));
      }
      return _;
    }
    toJSON() {
      return this.to2DArray();
    }
    isRowVector() {
      return this.rows === 1;
    }
    isColumnVector() {
      return this.columns === 1;
    }
    isVector() {
      return this.rows === 1 || this.columns === 1;
    }
    isSquare() {
      return this.rows === this.columns;
    }
    isEmpty() {
      return this.rows === 0 || this.columns === 0;
    }
    isSymmetric() {
      if (this.isSquare()) {
        for (let _ = 0; _ < this.rows; _++)
          for (let d = 0; d <= _; d++)
            if (this.get(_, d) !== this.get(d, _))
              return !1;
        return !0;
      }
      return !1;
    }
    isDistance() {
      if (!this.isSymmetric()) return !1;
      for (let _ = 0; _ < this.rows; _++)
        if (this.get(_, _) !== 0) return !1;
      return !0;
    }
    isEchelonForm() {
      let _ = 0, d = 0, u = -1, v = !0, S = !1;
      for (; _ < this.rows && v; ) {
        for (d = 0, S = !1; d < this.columns && S === !1; )
          this.get(_, d) === 0 ? d++ : this.get(_, d) === 1 && d > u ? (S = !0, u = d) : (v = !1, S = !0);
        _++;
      }
      return v;
    }
    isReducedEchelonForm() {
      let _ = 0, d = 0, u = -1, v = !0, S = !1;
      for (; _ < this.rows && v; ) {
        for (d = 0, S = !1; d < this.columns && S === !1; )
          this.get(_, d) === 0 ? d++ : this.get(_, d) === 1 && d > u ? (S = !0, u = d) : (v = !1, S = !0);
        for (let L = d + 1; L < this.rows; L++)
          this.get(_, L) !== 0 && (v = !1);
        _++;
      }
      return v;
    }
    echelonForm() {
      let _ = this.clone(), d = 0, u = 0;
      for (; d < _.rows && u < _.columns; ) {
        let v = d;
        for (let S = d; S < _.rows; S++)
          _.get(S, u) > _.get(v, u) && (v = S);
        if (_.get(v, u) === 0)
          u++;
        else {
          _.swapRows(d, v);
          let S = _.get(d, u);
          for (let L = u; L < _.columns; L++)
            _.set(d, L, _.get(d, L) / S);
          for (let L = d + 1; L < _.rows; L++) {
            let q = _.get(L, u) / _.get(d, u);
            _.set(L, u, 0);
            for (let X = u + 1; X < _.columns; X++)
              _.set(L, X, _.get(L, X) - _.get(d, X) * q);
          }
          d++, u++;
        }
      }
      return _;
    }
    reducedEchelonForm() {
      let _ = this.echelonForm(), d = _.columns, u = _.rows, v = u - 1;
      for (; v >= 0; )
        if (_.maxRow(v) === 0)
          v--;
        else {
          let S = 0, L = !1;
          for (; S < u && L === !1; )
            _.get(v, S) === 1 ? L = !0 : S++;
          for (let q = 0; q < v; q++) {
            let X = _.get(q, S);
            for (let j = S; j < d; j++) {
              let ae = _.get(q, j) - X * _.get(v, j);
              _.set(q, j, ae);
            }
          }
          v--;
        }
      return _;
    }
    set() {
      throw new Error("set method is unimplemented");
    }
    get() {
      throw new Error("get method is unimplemented");
    }
    repeat(_ = {}) {
      if (typeof _ != "object")
        throw new TypeError("options must be an object");
      const { rows: d = 1, columns: u = 1 } = _;
      if (!Number.isInteger(d) || d <= 0)
        throw new TypeError("rows must be a positive integer");
      if (!Number.isInteger(u) || u <= 0)
        throw new TypeError("columns must be a positive integer");
      let v = new re(this.rows * d, this.columns * u);
      for (let S = 0; S < d; S++)
        for (let L = 0; L < u; L++)
          v.setSubMatrix(this, this.rows * S, this.columns * L);
      return v;
    }
    fill(_) {
      for (let d = 0; d < this.rows; d++)
        for (let u = 0; u < this.columns; u++)
          this.set(d, u, _);
      return this;
    }
    neg() {
      return this.mulS(-1);
    }
    getRow(_) {
      f(this, _);
      let d = [];
      for (let u = 0; u < this.columns; u++)
        d.push(this.get(_, u));
      return d;
    }
    getRowVector(_) {
      return re.rowVector(this.getRow(_));
    }
    setRow(_, d) {
      f(this, _), d = w(this, d);
      for (let u = 0; u < this.columns; u++)
        this.set(_, u, d[u]);
      return this;
    }
    swapRows(_, d) {
      f(this, _), f(this, d);
      for (let u = 0; u < this.columns; u++) {
        let v = this.get(_, u);
        this.set(_, u, this.get(d, u)), this.set(d, u, v);
      }
      return this;
    }
    getColumn(_) {
      b(this, _);
      let d = [];
      for (let u = 0; u < this.rows; u++)
        d.push(this.get(u, _));
      return d;
    }
    getColumnVector(_) {
      return re.columnVector(this.getColumn(_));
    }
    setColumn(_, d) {
      b(this, _), d = g(this, d);
      for (let u = 0; u < this.rows; u++)
        this.set(u, _, d[u]);
      return this;
    }
    swapColumns(_, d) {
      b(this, _), b(this, d);
      for (let u = 0; u < this.rows; u++) {
        let v = this.get(u, _);
        this.set(u, _, this.get(u, d)), this.set(u, d, v);
      }
      return this;
    }
    addRowVector(_) {
      _ = w(this, _);
      for (let d = 0; d < this.rows; d++)
        for (let u = 0; u < this.columns; u++)
          this.set(d, u, this.get(d, u) + _[u]);
      return this;
    }
    subRowVector(_) {
      _ = w(this, _);
      for (let d = 0; d < this.rows; d++)
        for (let u = 0; u < this.columns; u++)
          this.set(d, u, this.get(d, u) - _[u]);
      return this;
    }
    mulRowVector(_) {
      _ = w(this, _);
      for (let d = 0; d < this.rows; d++)
        for (let u = 0; u < this.columns; u++)
          this.set(d, u, this.get(d, u) * _[u]);
      return this;
    }
    divRowVector(_) {
      _ = w(this, _);
      for (let d = 0; d < this.rows; d++)
        for (let u = 0; u < this.columns; u++)
          this.set(d, u, this.get(d, u) / _[u]);
      return this;
    }
    addColumnVector(_) {
      _ = g(this, _);
      for (let d = 0; d < this.rows; d++)
        for (let u = 0; u < this.columns; u++)
          this.set(d, u, this.get(d, u) + _[d]);
      return this;
    }
    subColumnVector(_) {
      _ = g(this, _);
      for (let d = 0; d < this.rows; d++)
        for (let u = 0; u < this.columns; u++)
          this.set(d, u, this.get(d, u) - _[d]);
      return this;
    }
    mulColumnVector(_) {
      _ = g(this, _);
      for (let d = 0; d < this.rows; d++)
        for (let u = 0; u < this.columns; u++)
          this.set(d, u, this.get(d, u) * _[d]);
      return this;
    }
    divColumnVector(_) {
      _ = g(this, _);
      for (let d = 0; d < this.rows; d++)
        for (let u = 0; u < this.columns; u++)
          this.set(d, u, this.get(d, u) / _[d]);
      return this;
    }
    mulRow(_, d) {
      f(this, _);
      for (let u = 0; u < this.columns; u++)
        this.set(_, u, this.get(_, u) * d);
      return this;
    }
    mulColumn(_, d) {
      b(this, _);
      for (let u = 0; u < this.rows; u++)
        this.set(u, _, this.get(u, _) * d);
      return this;
    }
    max(_) {
      if (this.isEmpty())
        return NaN;
      switch (_) {
        case "row": {
          const d = new Array(this.rows).fill(Number.NEGATIVE_INFINITY);
          for (let u = 0; u < this.rows; u++)
            for (let v = 0; v < this.columns; v++)
              this.get(u, v) > d[u] && (d[u] = this.get(u, v));
          return d;
        }
        case "column": {
          const d = new Array(this.columns).fill(Number.NEGATIVE_INFINITY);
          for (let u = 0; u < this.rows; u++)
            for (let v = 0; v < this.columns; v++)
              this.get(u, v) > d[v] && (d[v] = this.get(u, v));
          return d;
        }
        case void 0: {
          let d = this.get(0, 0);
          for (let u = 0; u < this.rows; u++)
            for (let v = 0; v < this.columns; v++)
              this.get(u, v) > d && (d = this.get(u, v));
          return d;
        }
        default:
          throw new Error(`invalid option: ${_}`);
      }
    }
    maxIndex() {
      D(this);
      let _ = this.get(0, 0), d = [0, 0];
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.get(u, v) > _ && (_ = this.get(u, v), d[0] = u, d[1] = v);
      return d;
    }
    min(_) {
      if (this.isEmpty())
        return NaN;
      switch (_) {
        case "row": {
          const d = new Array(this.rows).fill(Number.POSITIVE_INFINITY);
          for (let u = 0; u < this.rows; u++)
            for (let v = 0; v < this.columns; v++)
              this.get(u, v) < d[u] && (d[u] = this.get(u, v));
          return d;
        }
        case "column": {
          const d = new Array(this.columns).fill(Number.POSITIVE_INFINITY);
          for (let u = 0; u < this.rows; u++)
            for (let v = 0; v < this.columns; v++)
              this.get(u, v) < d[v] && (d[v] = this.get(u, v));
          return d;
        }
        case void 0: {
          let d = this.get(0, 0);
          for (let u = 0; u < this.rows; u++)
            for (let v = 0; v < this.columns; v++)
              this.get(u, v) < d && (d = this.get(u, v));
          return d;
        }
        default:
          throw new Error(`invalid option: ${_}`);
      }
    }
    minIndex() {
      D(this);
      let _ = this.get(0, 0), d = [0, 0];
      for (let u = 0; u < this.rows; u++)
        for (let v = 0; v < this.columns; v++)
          this.get(u, v) < _ && (_ = this.get(u, v), d[0] = u, d[1] = v);
      return d;
    }
    maxRow(_) {
      if (f(this, _), this.isEmpty())
        return NaN;
      let d = this.get(_, 0);
      for (let u = 1; u < this.columns; u++)
        this.get(_, u) > d && (d = this.get(_, u));
      return d;
    }
    maxRowIndex(_) {
      f(this, _), D(this);
      let d = this.get(_, 0), u = [_, 0];
      for (let v = 1; v < this.columns; v++)
        this.get(_, v) > d && (d = this.get(_, v), u[1] = v);
      return u;
    }
    minRow(_) {
      if (f(this, _), this.isEmpty())
        return NaN;
      let d = this.get(_, 0);
      for (let u = 1; u < this.columns; u++)
        this.get(_, u) < d && (d = this.get(_, u));
      return d;
    }
    minRowIndex(_) {
      f(this, _), D(this);
      let d = this.get(_, 0), u = [_, 0];
      for (let v = 1; v < this.columns; v++)
        this.get(_, v) < d && (d = this.get(_, v), u[1] = v);
      return u;
    }
    maxColumn(_) {
      if (b(this, _), this.isEmpty())
        return NaN;
      let d = this.get(0, _);
      for (let u = 1; u < this.rows; u++)
        this.get(u, _) > d && (d = this.get(u, _));
      return d;
    }
    maxColumnIndex(_) {
      b(this, _), D(this);
      let d = this.get(0, _), u = [0, _];
      for (let v = 1; v < this.rows; v++)
        this.get(v, _) > d && (d = this.get(v, _), u[0] = v);
      return u;
    }
    minColumn(_) {
      if (b(this, _), this.isEmpty())
        return NaN;
      let d = this.get(0, _);
      for (let u = 1; u < this.rows; u++)
        this.get(u, _) < d && (d = this.get(u, _));
      return d;
    }
    minColumnIndex(_) {
      b(this, _), D(this);
      let d = this.get(0, _), u = [0, _];
      for (let v = 1; v < this.rows; v++)
        this.get(v, _) < d && (d = this.get(v, _), u[0] = v);
      return u;
    }
    diag() {
      let _ = Math.min(this.rows, this.columns), d = [];
      for (let u = 0; u < _; u++)
        d.push(this.get(u, u));
      return d;
    }
    norm(_ = "frobenius") {
      switch (_) {
        case "max":
          return this.max();
        case "frobenius":
          return Math.sqrt(this.dot(this));
        default:
          throw new RangeError(`unknown norm type: ${_}`);
      }
    }
    cumulativeSum() {
      let _ = 0;
      for (let d = 0; d < this.rows; d++)
        for (let u = 0; u < this.columns; u++)
          _ += this.get(d, u), this.set(d, u, _);
      return this;
    }
    dot(_) {
      _e.isMatrix(_) && (_ = _.to1DArray());
      let d = this.to1DArray();
      if (d.length !== _.length)
        throw new RangeError("vectors do not have the same size");
      let u = 0;
      for (let v = 0; v < d.length; v++)
        u += d[v] * _[v];
      return u;
    }
    mmul(_) {
      _ = re.checkMatrix(_);
      let d = this.rows, u = this.columns, v = _.columns, S = new re(d, v), L = new Float64Array(u);
      for (let q = 0; q < v; q++) {
        for (let X = 0; X < u; X++)
          L[X] = _.get(X, q);
        for (let X = 0; X < d; X++) {
          let j = 0;
          for (let ae = 0; ae < u; ae++)
            j += this.get(X, ae) * L[ae];
          S.set(X, q, j);
        }
      }
      return S;
    }
    mpow(_) {
      if (!this.isSquare())
        throw new RangeError("Matrix must be square");
      if (!Number.isInteger(_) || _ < 0)
        throw new RangeError("Exponent must be a non-negative integer");
      let d = re.eye(this.rows), u = this;
      for (let v = _; v >= 1; v /= 2)
        (v & 1) !== 0 && (d = d.mmul(u)), u = u.mmul(u);
      return d;
    }
    strassen2x2(_) {
      _ = re.checkMatrix(_);
      let d = new re(2, 2);
      const u = this.get(0, 0), v = _.get(0, 0), S = this.get(0, 1), L = _.get(0, 1), q = this.get(1, 0), X = _.get(1, 0), j = this.get(1, 1), ae = _.get(1, 1), K = (u + j) * (v + ae), ce = (q + j) * v, we = u * (L - ae), le = j * (X - v), ge = (u + S) * ae, Ue = (q - u) * (v + L), ie = (S - j) * (X + ae), Ce = K + le - ge + ie, Xe = we + ge, ht = ce + le, ft = K - ce + we + Ue;
      return d.set(0, 0, Ce), d.set(0, 1, Xe), d.set(1, 0, ht), d.set(1, 1, ft), d;
    }
    strassen3x3(_) {
      _ = re.checkMatrix(_);
      let d = new re(3, 3);
      const u = this.get(0, 0), v = this.get(0, 1), S = this.get(0, 2), L = this.get(1, 0), q = this.get(1, 1), X = this.get(1, 2), j = this.get(2, 0), ae = this.get(2, 1), K = this.get(2, 2), ce = _.get(0, 0), we = _.get(0, 1), le = _.get(0, 2), ge = _.get(1, 0), Ue = _.get(1, 1), ie = _.get(1, 2), Ce = _.get(2, 0), Xe = _.get(2, 1), ht = _.get(2, 2), ft = (u + v + S - L - q - ae - K) * Ue, dt = (u - L) * (-we + Ue), rt = q * (-ce + we + ge - Ue - ie - Ce + ht), at = (-u + L + q) * (ce - we + Ue), gt = (L + q) * (-ce + we), se = u * ce, Ie = (-u + j + ae) * (ce - le + ie), Ke = (-u + j) * (le - ie), Pe = (j + ae) * (-ce + le), mt = (u + v + S - q - X - j - ae) * ie, ct = ae * (-ce + le + ge - Ue - ie - Ce + Xe), pt = (-S + ae + K) * (Ue + Ce - Xe), _t = (S - K) * (Ue - Xe), bt = S * Ce, Mt = (ae + K) * (-Ce + Xe), xt = (-S + q + X) * (ie + Ce - ht), kt = (S - X) * (ie - ht), At = (q + X) * (-Ce + ht), ut = v * ge, vt = X * Xe, yt = L * le, Et = j * we, wt = K * ht, Ft = se + bt + ut, Nt = ft + at + gt + se + pt + bt + Mt, Ut = se + Ie + Pe + mt + bt + xt + At, Ot = dt + rt + at + se + bt + xt + kt, Lt = dt + at + gt + se + vt, zt = bt + xt + kt + At + yt, qt = se + Ie + Ke + ct + pt + _t + bt, Gt = pt + _t + bt + Mt + Et, Ht = se + Ie + Ke + Pe + wt;
      return d.set(0, 0, Ft), d.set(0, 1, Nt), d.set(0, 2, Ut), d.set(1, 0, Ot), d.set(1, 1, Lt), d.set(1, 2, zt), d.set(2, 0, qt), d.set(2, 1, Gt), d.set(2, 2, Ht), d;
    }
    mmulStrassen(_) {
      _ = re.checkMatrix(_);
      let d = this.clone(), u = d.rows, v = d.columns, S = _.rows, L = _.columns;
      v !== S && console.warn(
        `Multiplying ${u} x ${v} and ${S} x ${L} matrix: dimensions do not match.`
      );
      function q(K, ce, we) {
        let le = K.rows, ge = K.columns;
        if (le === ce && ge === we)
          return K;
        {
          let Ue = _e.zeros(ce, we);
          return Ue = Ue.setSubMatrix(K, 0, 0), Ue;
        }
      }
      let X = Math.max(u, S), j = Math.max(v, L);
      d = q(d, X, j), _ = q(_, X, j);
      function ae(K, ce, we, le) {
        if (we <= 512 || le <= 512)
          return K.mmul(ce);
        we % 2 === 1 && le % 2 === 1 ? (K = q(K, we + 1, le + 1), ce = q(ce, we + 1, le + 1)) : we % 2 === 1 ? (K = q(K, we + 1, le), ce = q(ce, we + 1, le)) : le % 2 === 1 && (K = q(K, we, le + 1), ce = q(ce, we, le + 1));
        let ge = parseInt(K.rows / 2, 10), Ue = parseInt(K.columns / 2, 10), ie = K.subMatrix(0, ge - 1, 0, Ue - 1), Ce = ce.subMatrix(0, ge - 1, 0, Ue - 1), Xe = K.subMatrix(0, ge - 1, Ue, K.columns - 1), ht = ce.subMatrix(0, ge - 1, Ue, ce.columns - 1), ft = K.subMatrix(ge, K.rows - 1, 0, Ue - 1), dt = ce.subMatrix(ge, ce.rows - 1, 0, Ue - 1), rt = K.subMatrix(ge, K.rows - 1, Ue, K.columns - 1), at = ce.subMatrix(ge, ce.rows - 1, Ue, ce.columns - 1), gt = ae(
          _e.add(ie, rt),
          _e.add(Ce, at),
          ge,
          Ue
        ), se = ae(_e.add(ft, rt), Ce, ge, Ue), Ie = ae(ie, _e.sub(ht, at), ge, Ue), Ke = ae(rt, _e.sub(dt, Ce), ge, Ue), Pe = ae(_e.add(ie, Xe), at, ge, Ue), mt = ae(
          _e.sub(ft, ie),
          _e.add(Ce, ht),
          ge,
          Ue
        ), ct = ae(
          _e.sub(Xe, rt),
          _e.add(dt, at),
          ge,
          Ue
        ), pt = _e.add(gt, Ke);
        pt.sub(Pe), pt.add(ct);
        let _t = _e.add(Ie, Pe), bt = _e.add(se, Ke), Mt = _e.sub(gt, se);
        Mt.add(Ie), Mt.add(mt);
        let xt = _e.zeros(2 * pt.rows, 2 * pt.columns);
        return xt = xt.setSubMatrix(pt, 0, 0), xt = xt.setSubMatrix(_t, pt.rows, 0), xt = xt.setSubMatrix(bt, 0, pt.columns), xt = xt.setSubMatrix(Mt, pt.rows, pt.columns), xt.subMatrix(0, we - 1, 0, le - 1);
      }
      return ae(d, _, X, j);
    }
    scaleRows(_ = {}) {
      if (typeof _ != "object")
        throw new TypeError("options must be an object");
      const { min: d = 0, max: u = 1 } = _;
      if (!Number.isFinite(d)) throw new TypeError("min must be a number");
      if (!Number.isFinite(u)) throw new TypeError("max must be a number");
      if (d >= u) throw new RangeError("min must be smaller than max");
      let v = new re(this.rows, this.columns);
      for (let S = 0; S < this.rows; S++) {
        const L = this.getRow(S);
        L.length > 0 && i(L, { min: d, max: u, output: L }), v.setRow(S, L);
      }
      return v;
    }
    scaleColumns(_ = {}) {
      if (typeof _ != "object")
        throw new TypeError("options must be an object");
      const { min: d = 0, max: u = 1 } = _;
      if (!Number.isFinite(d)) throw new TypeError("min must be a number");
      if (!Number.isFinite(u)) throw new TypeError("max must be a number");
      if (d >= u) throw new RangeError("min must be smaller than max");
      let v = new re(this.rows, this.columns);
      for (let S = 0; S < this.columns; S++) {
        const L = this.getColumn(S);
        L.length && i(L, {
          min: d,
          max: u,
          output: L
        }), v.setColumn(S, L);
      }
      return v;
    }
    flipRows() {
      const _ = Math.ceil(this.columns / 2);
      for (let d = 0; d < this.rows; d++)
        for (let u = 0; u < _; u++) {
          let v = this.get(d, u), S = this.get(d, this.columns - 1 - u);
          this.set(d, u, S), this.set(d, this.columns - 1 - u, v);
        }
      return this;
    }
    flipColumns() {
      const _ = Math.ceil(this.rows / 2);
      for (let d = 0; d < this.columns; d++)
        for (let u = 0; u < _; u++) {
          let v = this.get(u, d), S = this.get(this.rows - 1 - u, d);
          this.set(u, d, S), this.set(this.rows - 1 - u, d, v);
        }
      return this;
    }
    kroneckerProduct(_) {
      _ = re.checkMatrix(_);
      let d = this.rows, u = this.columns, v = _.rows, S = _.columns, L = new re(d * v, u * S);
      for (let q = 0; q < d; q++)
        for (let X = 0; X < u; X++)
          for (let j = 0; j < v; j++)
            for (let ae = 0; ae < S; ae++)
              L.set(v * q + j, S * X + ae, this.get(q, X) * _.get(j, ae));
      return L;
    }
    kroneckerSum(_) {
      if (_ = re.checkMatrix(_), !this.isSquare() || !_.isSquare())
        throw new Error("Kronecker Sum needs two Square Matrices");
      let d = this.rows, u = _.rows, v = this.kroneckerProduct(re.eye(u, u)), S = re.eye(d, d).kroneckerProduct(_);
      return v.add(S);
    }
    transpose() {
      let _ = new re(this.columns, this.rows);
      for (let d = 0; d < this.rows; d++)
        for (let u = 0; u < this.columns; u++)
          _.set(u, d, this.get(d, u));
      return _;
    }
    sortRows(_ = Be) {
      for (let d = 0; d < this.rows; d++)
        this.setRow(d, this.getRow(d).sort(_));
      return this;
    }
    sortColumns(_ = Be) {
      for (let d = 0; d < this.columns; d++)
        this.setColumn(d, this.getColumn(d).sort(_));
      return this;
    }
    subMatrix(_, d, u, v) {
      A(this, _, d, u, v);
      let S = new re(
        d - _ + 1,
        v - u + 1
      );
      for (let L = _; L <= d; L++)
        for (let q = u; q <= v; q++)
          S.set(L - _, q - u, this.get(L, q));
      return S;
    }
    subMatrixRow(_, d, u) {
      if (d === void 0 && (d = 0), u === void 0 && (u = this.columns - 1), d > u || d < 0 || d >= this.columns || u < 0 || u >= this.columns)
        throw new RangeError("Argument out of range");
      let v = new re(_.length, u - d + 1);
      for (let S = 0; S < _.length; S++)
        for (let L = d; L <= u; L++) {
          if (_[S] < 0 || _[S] >= this.rows)
            throw new RangeError(`Row index out of range: ${_[S]}`);
          v.set(S, L - d, this.get(_[S], L));
        }
      return v;
    }
    subMatrixColumn(_, d, u) {
      if (d === void 0 && (d = 0), u === void 0 && (u = this.rows - 1), d > u || d < 0 || d >= this.rows || u < 0 || u >= this.rows)
        throw new RangeError("Argument out of range");
      let v = new re(u - d + 1, _.length);
      for (let S = 0; S < _.length; S++)
        for (let L = d; L <= u; L++) {
          if (_[S] < 0 || _[S] >= this.columns)
            throw new RangeError(`Column index out of range: ${_[S]}`);
          v.set(L - d, S, this.get(L, _[S]));
        }
      return v;
    }
    setSubMatrix(_, d, u) {
      if (_ = re.checkMatrix(_), _.isEmpty())
        return this;
      let v = d + _.rows - 1, S = u + _.columns - 1;
      A(this, d, v, u, S);
      for (let L = 0; L < _.rows; L++)
        for (let q = 0; q < _.columns; q++)
          this.set(d + L, u + q, _.get(L, q));
      return this;
    }
    selection(_, d) {
      E(this, _), k(this, d);
      let u = new re(_.length, d.length);
      for (let v = 0; v < _.length; v++) {
        let S = _[v];
        for (let L = 0; L < d.length; L++) {
          let q = d[L];
          u.set(v, L, this.get(S, q));
        }
      }
      return u;
    }
    trace() {
      let _ = Math.min(this.rows, this.columns), d = 0;
      for (let u = 0; u < _; u++)
        d += this.get(u, u);
      return d;
    }
    clone() {
      return this.constructor.copy(this, new re(this.rows, this.columns));
    }
    /**
     * @template {AbstractMatrix} M
     * @param {AbstractMatrix} from
     * @param {M} to
     * @return {M}
     */
    static copy(_, d) {
      for (const [u, v, S] of _.entries())
        d.set(u, v, S);
      return d;
    }
    sum(_) {
      switch (_) {
        case "row":
          return $(this);
        case "column":
          return P(this);
        case void 0:
          return z(this);
        default:
          throw new Error(`invalid option: ${_}`);
      }
    }
    product(_) {
      switch (_) {
        case "row":
          return B(this);
        case "column":
          return F(this);
        case void 0:
          return O(this);
        default:
          throw new Error(`invalid option: ${_}`);
      }
    }
    mean(_) {
      const d = this.sum(_);
      switch (_) {
        case "row": {
          for (let u = 0; u < this.rows; u++)
            d[u] /= this.columns;
          return d;
        }
        case "column": {
          for (let u = 0; u < this.columns; u++)
            d[u] /= this.rows;
          return d;
        }
        case void 0:
          return d / this.size;
        default:
          throw new Error(`invalid option: ${_}`);
      }
    }
    variance(_, d = {}) {
      if (typeof _ == "object" && (d = _, _ = void 0), typeof d != "object")
        throw new TypeError("options must be an object");
      const { unbiased: u = !0, mean: v = this.mean(_) } = d;
      if (typeof u != "boolean")
        throw new TypeError("unbiased must be a boolean");
      switch (_) {
        case "row": {
          if (!e.isAnyArray(v))
            throw new TypeError("mean must be an array");
          return N(this, u, v);
        }
        case "column": {
          if (!e.isAnyArray(v))
            throw new TypeError("mean must be an array");
          return G(this, u, v);
        }
        case void 0: {
          if (typeof v != "number")
            throw new TypeError("mean must be a number");
          return V(this, u, v);
        }
        default:
          throw new Error(`invalid option: ${_}`);
      }
    }
    standardDeviation(_, d) {
      typeof _ == "object" && (d = _, _ = void 0);
      const u = this.variance(_, d);
      if (_ === void 0)
        return Math.sqrt(u);
      for (let v = 0; v < u.length; v++)
        u[v] = Math.sqrt(u[v]);
      return u;
    }
    center(_, d = {}) {
      if (typeof _ == "object" && (d = _, _ = void 0), typeof d != "object")
        throw new TypeError("options must be an object");
      const { center: u = this.mean(_) } = d;
      switch (_) {
        case "row": {
          if (!e.isAnyArray(u))
            throw new TypeError("center must be an array");
          return J(this, u), this;
        }
        case "column": {
          if (!e.isAnyArray(u))
            throw new TypeError("center must be an array");
          return Q(this, u), this;
        }
        case void 0: {
          if (typeof u != "number")
            throw new TypeError("center must be a number");
          return W(this, u), this;
        }
        default:
          throw new Error(`invalid option: ${_}`);
      }
    }
    scale(_, d = {}) {
      if (typeof _ == "object" && (d = _, _ = void 0), typeof d != "object")
        throw new TypeError("options must be an object");
      let u = d.scale;
      switch (_) {
        case "row": {
          if (u === void 0)
            u = ne(this);
          else if (!e.isAnyArray(u))
            throw new TypeError("scale must be an array");
          return pe(this, u), this;
        }
        case "column": {
          if (u === void 0)
            u = be(this);
          else if (!e.isAnyArray(u))
            throw new TypeError("scale must be an array");
          return ve(this, u), this;
        }
        case void 0: {
          if (u === void 0)
            u = Ee(this);
          else if (typeof u != "number")
            throw new TypeError("scale must be a number");
          return Ae(this, u), this;
        }
        default:
          throw new Error(`invalid option: ${_}`);
      }
    }
    toString(_) {
      return a(this, _);
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    /**
     * iterator from left to right, from top to bottom
     * yield [row, column, value]
     * @returns {Generator<[number, number, number], void, void>}
     */
    *entries() {
      for (let _ = 0; _ < this.rows; _++)
        for (let d = 0; d < this.columns; d++)
          yield [_, d, this.get(_, d)];
    }
    /**
     * iterator from left to right, from top to bottom
     * yield value
     * @returns {Generator<number, void, void>}
     */
    *values() {
      for (let _ = 0; _ < this.rows; _++)
        for (let d = 0; d < this.columns; d++)
          yield this.get(_, d);
    }
  }
  _e.prototype.klass = "Matrix", typeof Symbol < "u" && (_e.prototype[Symbol.for("nodejs.util.inspect.custom")] = n);
  function Be(M, _) {
    return M - _;
  }
  function Me(M) {
    return M.every((_) => typeof _ == "number");
  }
  _e.random = _e.rand, _e.randomInt = _e.randInt, _e.diagonal = _e.diag, _e.prototype.diagonal = _e.prototype.diag, _e.identity = _e.eye, _e.prototype.negate = _e.prototype.neg, _e.prototype.tensorProduct = _e.prototype.kroneckerProduct;
  const ee = class ee extends _e {
    constructor(d, u) {
      super();
      It(this, de);
      /**
       * @type {Float64Array[]}
       */
      $e(this, "data");
      if (ee.isMatrix(d))
        $t(this, de, Ct).call(this, d.rows, d.columns), ee.copy(d, this);
      else if (Number.isInteger(d) && d >= 0)
        $t(this, de, Ct).call(this, d, u);
      else if (e.isAnyArray(d)) {
        const v = d;
        if (d = v.length, u = d ? v[0].length : 0, typeof u != "number")
          throw new TypeError(
            "Data must be a 2D array with at least one element"
          );
        this.data = [];
        for (let S = 0; S < d; S++) {
          if (v[S].length !== u)
            throw new RangeError("Inconsistent array dimensions");
          if (!Me(v[S]))
            throw new TypeError("Input data contains non-numeric values");
          this.data.push(Float64Array.from(v[S]));
        }
        this.rows = d, this.columns = u;
      } else
        throw new TypeError(
          "First argument must be a positive number or an array"
        );
    }
    set(d, u, v) {
      return this.data[d][u] = v, this;
    }
    get(d, u) {
      return this.data[d][u];
    }
    removeRow(d) {
      return f(this, d), this.data.splice(d, 1), this.rows -= 1, this;
    }
    addRow(d, u) {
      return u === void 0 && (u = d, d = this.rows), f(this, d, !0), u = Float64Array.from(w(this, u)), this.data.splice(d, 0, u), this.rows += 1, this;
    }
    removeColumn(d) {
      b(this, d);
      for (let u = 0; u < this.rows; u++) {
        const v = new Float64Array(this.columns - 1);
        for (let S = 0; S < d; S++)
          v[S] = this.data[u][S];
        for (let S = d + 1; S < this.columns; S++)
          v[S - 1] = this.data[u][S];
        this.data[u] = v;
      }
      return this.columns -= 1, this;
    }
    addColumn(d, u) {
      typeof u > "u" && (u = d, d = this.columns), b(this, d, !0), u = g(this, u);
      for (let v = 0; v < this.rows; v++) {
        const S = new Float64Array(this.columns + 1);
        let L = 0;
        for (; L < d; L++)
          S[L] = this.data[v][L];
        for (S[L++] = u[v]; L < this.columns + 1; L++)
          S[L] = this.data[v][L - 1];
        this.data[v] = S;
      }
      return this.columns += 1, this;
    }
  };
  de = new WeakSet(), /**
   * Init an empty matrix
   * @param {number} nRows
   * @param {number} nColumns
   */
  Ct = function(d, u) {
    if (this.data = [], Number.isInteger(u) && u >= 0)
      for (let v = 0; v < d; v++)
        this.data.push(new Float64Array(u));
    else
      throw new TypeError("nColumns must be a positive integer");
    this.rows = d, this.columns = u;
  };
  let re = ee;
  l(_e, re);
  const We = class We extends _e {
    /**
     * @param {number | AbstractMatrix | ArrayLike<ArrayLike<number>>} diagonalSize
     * @return {this}
     */
    constructor(d) {
      super();
      /** @type {Matrix} */
      It(this, oe);
      if (re.isMatrix(d)) {
        if (!d.isSymmetric())
          throw new TypeError("not symmetric data");
        Dt(this, oe, re.copy(
          d,
          new re(d.rows, d.rows)
        ));
      } else if (Number.isInteger(d) && d >= 0)
        Dt(this, oe, new re(d, d));
      else if (Dt(this, oe, new re(d)), !this.isSymmetric())
        throw new TypeError("not symmetric data");
    }
    get size() {
      return St(this, oe).size;
    }
    get rows() {
      return St(this, oe).rows;
    }
    get columns() {
      return St(this, oe).columns;
    }
    get diagonalSize() {
      return this.rows;
    }
    /**
     * not the same as matrix.isSymmetric()
     * Here is to check if it's instanceof SymmetricMatrix without bundling issues
     *
     * @param value
     * @returns {boolean}
     */
    static isSymmetricMatrix(d) {
      return re.isMatrix(d) && d.klassType === "SymmetricMatrix";
    }
    /**
     * @param diagonalSize
     * @return {SymmetricMatrix}
     */
    static zeros(d) {
      return new this(d);
    }
    /**
     * @param diagonalSize
     * @return {SymmetricMatrix}
     */
    static ones(d) {
      return new this(d).fill(1);
    }
    clone() {
      const d = new We(this.diagonalSize);
      for (const [u, v, S] of this.upperRightEntries())
        d.set(u, v, S);
      return d;
    }
    toMatrix() {
      return new re(this);
    }
    get(d, u) {
      return St(this, oe).get(d, u);
    }
    set(d, u, v) {
      return St(this, oe).set(d, u, v), St(this, oe).set(u, d, v), this;
    }
    removeCross(d) {
      return St(this, oe).removeRow(d), St(this, oe).removeColumn(d), this;
    }
    addCross(d, u) {
      u === void 0 && (u = d, d = this.diagonalSize);
      const v = u.slice();
      return v.splice(d, 1), St(this, oe).addRow(d, v), St(this, oe).addColumn(d, u), this;
    }
    /**
     * @param {Mask[]} mask
     */
    applyMask(d) {
      if (d.length !== this.diagonalSize)
        throw new RangeError("Mask size do not match with matrix size");
      const u = [];
      for (const [v, S] of d.entries())
        S || u.push(v);
      u.reverse();
      for (const v of u)
        this.removeCross(v);
      return this;
    }
    /**
     * Compact format upper-right corner of matrix
     * iterate from left to right, from top to bottom.
     *
     * ```
     *   A B C D
     * A 1 2 3 4
     * B 2 5 6 7
     * C 3 6 8 9
     * D 4 7 9 10
     * ```
     *
     * will return compact 1D array `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`
     *
     * length is S(i=0, n=sideSize) => 10 for a 4 sideSized matrix
     *
     * @returns {number[]}
     */
    toCompact() {
      const { diagonalSize: d } = this, u = new Array(d * (d + 1) / 2);
      for (let v = 0, S = 0, L = 0; L < u.length; L++)
        u[L] = this.get(S, v), ++v >= d && (v = ++S);
      return u;
    }
    /**
     * @param {number[]} compact
     * @return {SymmetricMatrix}
     */
    static fromCompact(d) {
      const u = d.length, v = (Math.sqrt(8 * u + 1) - 1) / 2;
      if (!Number.isInteger(v))
        throw new TypeError(
          `This array is not a compact representation of a Symmetric Matrix, ${JSON.stringify(
            d
          )}`
        );
      const S = new We(v);
      for (let L = 0, q = 0, X = 0; X < u; X++)
        S.set(L, q, d[X]), ++L >= v && (L = ++q);
      return S;
    }
    /**
     * half iterator upper-right-corner from left to right, from top to bottom
     * yield [row, column, value]
     *
     * @returns {Generator<[number, number, number], void, void>}
     */
    *upperRightEntries() {
      for (let d = 0, u = 0; d < this.diagonalSize; void 0) {
        const v = this.get(d, u);
        yield [d, u, v], ++u >= this.diagonalSize && (u = ++d);
      }
    }
    /**
     * half iterator upper-right-corner from left to right, from top to bottom
     * yield value
     *
     * @returns {Generator<[number, number, number], void, void>}
     */
    *upperRightValues() {
      for (let d = 0, u = 0; d < this.diagonalSize; void 0)
        yield this.get(d, u), ++u >= this.diagonalSize && (u = ++d);
    }
  };
  oe = new WeakMap();
  let Te = We;
  Te.prototype.klassType = "SymmetricMatrix";
  class Fe extends Te {
    /**
     * not the same as matrix.isSymmetric()
     * Here is to check if it's instanceof SymmetricMatrix without bundling issues
     *
     * @param value
     * @returns {boolean}
     */
    static isDistanceMatrix(_) {
      return Te.isSymmetricMatrix(_) && _.klassSubType === "DistanceMatrix";
    }
    constructor(_) {
      if (super(_), !this.isDistance())
        throw new TypeError("Provided arguments do no produce a distance matrix");
    }
    set(_, d, u) {
      return _ === d && (u = 0), super.set(_, d, u);
    }
    addCross(_, d) {
      return d === void 0 && (d = _, _ = this.diagonalSize), d = d.slice(), d[_] = 0, super.addCross(_, d);
    }
    toSymmetricMatrix() {
      return new Te(this);
    }
    clone() {
      const _ = new Fe(this.diagonalSize);
      for (const [d, u, v] of this.upperRightEntries())
        d !== u && _.set(d, u, v);
      return _;
    }
    /**
     * Compact format upper-right corner of matrix
     * no diagonal (only zeros)
     * iterable from left to right, from top to bottom.
     *
     * ```
     *   A B C D
     * A 0 1 2 3
     * B 1 0 4 5
     * C 2 4 0 6
     * D 3 5 6 0
     * ```
     *
     * will return compact 1D array `[1, 2, 3, 4, 5, 6]`
     *
     * length is S(i=0, n=sideSize-1) => 6 for a 4 side sized matrix
     *
     * @returns {number[]}
     */
    toCompact() {
      const { diagonalSize: _ } = this, d = (_ - 1) * _ / 2, u = new Array(d);
      for (let v = 1, S = 0, L = 0; L < u.length; L++)
        u[L] = this.get(S, v), ++v >= _ && (v = ++S + 1);
      return u;
    }
    /**
     * @param {number[]} compact
     */
    static fromCompact(_) {
      const d = _.length;
      if (d === 0)
        return new this(0);
      const u = (Math.sqrt(8 * d + 1) + 1) / 2;
      if (!Number.isInteger(u))
        throw new TypeError(
          `This array is not a compact representation of a DistanceMatrix, ${JSON.stringify(
            _
          )}`
        );
      const v = new this(u);
      for (let S = 1, L = 0, q = 0; q < d; q++)
        v.set(S, L, _[q]), ++S >= u && (S = ++L + 1);
      return v;
    }
  }
  Fe.prototype.klassSubType = "DistanceMatrix";
  class Se extends _e {
    constructor(_, d, u) {
      super(), this.matrix = _, this.rows = d, this.columns = u;
    }
  }
  class Ye extends Se {
    constructor(_, d) {
      b(_, d), super(_, _.rows, 1), this.column = d;
    }
    set(_, d, u) {
      return this.matrix.set(_, this.column, u), this;
    }
    get(_) {
      return this.matrix.get(_, this.column);
    }
  }
  class Je extends Se {
    constructor(_, d) {
      k(_, d), super(_, _.rows, d.length), this.columnIndices = d;
    }
    set(_, d, u) {
      return this.matrix.set(_, this.columnIndices[d], u), this;
    }
    get(_, d) {
      return this.matrix.get(_, this.columnIndices[d]);
    }
  }
  class et extends Se {
    constructor(_) {
      super(_, _.rows, _.columns);
    }
    set(_, d, u) {
      return this.matrix.set(_, this.columns - d - 1, u), this;
    }
    get(_, d) {
      return this.matrix.get(_, this.columns - d - 1);
    }
  }
  class Ve extends Se {
    constructor(_) {
      super(_, _.rows, _.columns);
    }
    set(_, d, u) {
      return this.matrix.set(this.rows - _ - 1, d, u), this;
    }
    get(_, d) {
      return this.matrix.get(this.rows - _ - 1, d);
    }
  }
  class tt extends Se {
    constructor(_, d) {
      f(_, d), super(_, 1, _.columns), this.row = d;
    }
    set(_, d, u) {
      return this.matrix.set(this.row, d, u), this;
    }
    get(_, d) {
      return this.matrix.get(this.row, d);
    }
  }
  class qe extends Se {
    constructor(_, d) {
      E(_, d), super(_, d.length, _.columns), this.rowIndices = d;
    }
    set(_, d, u) {
      return this.matrix.set(this.rowIndices[_], d, u), this;
    }
    get(_, d) {
      return this.matrix.get(this.rowIndices[_], d);
    }
  }
  class Re extends Se {
    constructor(_, d, u) {
      E(_, d), k(_, u), super(_, d.length, u.length), this.rowIndices = d, this.columnIndices = u;
    }
    set(_, d, u) {
      return this.matrix.set(
        this.rowIndices[_],
        this.columnIndices[d],
        u
      ), this;
    }
    get(_, d) {
      return this.matrix.get(
        this.rowIndices[_],
        this.columnIndices[d]
      );
    }
  }
  class nt extends Se {
    constructor(_, d, u, v, S) {
      A(_, d, u, v, S), super(_, u - d + 1, S - v + 1), this.startRow = d, this.startColumn = v;
    }
    set(_, d, u) {
      return this.matrix.set(
        this.startRow + _,
        this.startColumn + d,
        u
      ), this;
    }
    get(_, d) {
      return this.matrix.get(
        this.startRow + _,
        this.startColumn + d
      );
    }
  }
  class Ge extends Se {
    constructor(_) {
      super(_, _.columns, _.rows);
    }
    set(_, d, u) {
      return this.matrix.set(d, _, u), this;
    }
    get(_, d) {
      return this.matrix.get(d, _);
    }
  }
  class Ne extends _e {
    constructor(_, d = {}) {
      const { rows: u = 1 } = d;
      if (_.length % u !== 0)
        throw new Error("the data length is not divisible by the number of rows");
      super(), this.rows = u, this.columns = _.length / u, this.data = _;
    }
    set(_, d, u) {
      let v = this._calculateIndex(_, d);
      return this.data[v] = u, this;
    }
    get(_, d) {
      let u = this._calculateIndex(_, d);
      return this.data[u];
    }
    _calculateIndex(_, d) {
      return _ * this.columns + d;
    }
  }
  class he extends _e {
    constructor(_) {
      super(), this.data = _, this.rows = _.length, this.columns = _[0].length;
    }
    set(_, d, u) {
      return this.data[_][d] = u, this;
    }
    get(_, d) {
      return this.data[_][d];
    }
  }
  function Qe(M, _) {
    if (e.isAnyArray(M))
      return M[0] && e.isAnyArray(M[0]) ? new he(M) : new Ne(M, _);
    throw new Error("the argument is not an array");
  }
  class Ze {
    constructor(_) {
      _ = he.checkMatrix(_);
      let d = _.clone(), u = d.rows, v = d.columns, S = new Float64Array(u), L = 1, q, X, j, ae, K, ce, we, le, ge;
      for (q = 0; q < u; q++)
        S[q] = q;
      for (le = new Float64Array(u), X = 0; X < v; X++) {
        for (q = 0; q < u; q++)
          le[q] = d.get(q, X);
        for (q = 0; q < u; q++) {
          for (ge = Math.min(q, X), K = 0, j = 0; j < ge; j++)
            K += d.get(q, j) * le[j];
          le[q] -= K, d.set(q, X, le[q]);
        }
        for (ae = X, q = X + 1; q < u; q++)
          Math.abs(le[q]) > Math.abs(le[ae]) && (ae = q);
        if (ae !== X) {
          for (j = 0; j < v; j++)
            ce = d.get(ae, j), d.set(ae, j, d.get(X, j)), d.set(X, j, ce);
          we = S[ae], S[ae] = S[X], S[X] = we, L = -L;
        }
        if (X < u && d.get(X, X) !== 0)
          for (q = X + 1; q < u; q++)
            d.set(q, X, d.get(q, X) / d.get(X, X));
      }
      this.LU = d, this.pivotVector = S, this.pivotSign = L;
    }
    isSingular() {
      let _ = this.LU, d = _.columns;
      for (let u = 0; u < d; u++)
        if (_.get(u, u) === 0)
          return !0;
      return !1;
    }
    solve(_) {
      _ = re.checkMatrix(_);
      let d = this.LU;
      if (d.rows !== _.rows)
        throw new Error("Invalid matrix dimensions");
      if (this.isSingular())
        throw new Error("LU matrix is singular");
      let v = _.columns, S = _.subMatrixRow(this.pivotVector, 0, v - 1), L = d.columns, q, X, j;
      for (j = 0; j < L; j++)
        for (q = j + 1; q < L; q++)
          for (X = 0; X < v; X++)
            S.set(q, X, S.get(q, X) - S.get(j, X) * d.get(q, j));
      for (j = L - 1; j >= 0; j--) {
        for (X = 0; X < v; X++)
          S.set(j, X, S.get(j, X) / d.get(j, j));
        for (q = 0; q < j; q++)
          for (X = 0; X < v; X++)
            S.set(q, X, S.get(q, X) - S.get(j, X) * d.get(q, j));
      }
      return S;
    }
    get determinant() {
      let _ = this.LU;
      if (!_.isSquare())
        throw new Error("Matrix must be square");
      let d = this.pivotSign, u = _.columns;
      for (let v = 0; v < u; v++)
        d *= _.get(v, v);
      return d;
    }
    get lowerTriangularMatrix() {
      let _ = this.LU, d = _.rows, u = _.columns, v = new re(d, u);
      for (let S = 0; S < d; S++)
        for (let L = 0; L < u; L++)
          S > L ? v.set(S, L, _.get(S, L)) : S === L ? v.set(S, L, 1) : v.set(S, L, 0);
      return v;
    }
    get upperTriangularMatrix() {
      let _ = this.LU, d = _.rows, u = _.columns, v = new re(d, u);
      for (let S = 0; S < d; S++)
        for (let L = 0; L < u; L++)
          S <= L ? v.set(S, L, _.get(S, L)) : v.set(S, L, 0);
      return v;
    }
    get pivotPermutationVector() {
      return Array.from(this.pivotVector);
    }
  }
  function He(M, _) {
    let d = 0;
    return Math.abs(M) > Math.abs(_) ? (d = _ / M, Math.abs(M) * Math.sqrt(1 + d * d)) : _ !== 0 ? (d = M / _, Math.abs(_) * Math.sqrt(1 + d * d)) : 0;
  }
  class De {
    constructor(_) {
      _ = he.checkMatrix(_);
      let d = _.clone(), u = _.rows, v = _.columns, S = new Float64Array(v), L, q, X, j;
      for (X = 0; X < v; X++) {
        let ae = 0;
        for (L = X; L < u; L++)
          ae = He(ae, d.get(L, X));
        if (ae !== 0) {
          for (d.get(X, X) < 0 && (ae = -ae), L = X; L < u; L++)
            d.set(L, X, d.get(L, X) / ae);
          for (d.set(X, X, d.get(X, X) + 1), q = X + 1; q < v; q++) {
            for (j = 0, L = X; L < u; L++)
              j += d.get(L, X) * d.get(L, q);
            for (j = -j / d.get(X, X), L = X; L < u; L++)
              d.set(L, q, d.get(L, q) + j * d.get(L, X));
          }
        }
        S[X] = -ae;
      }
      this.QR = d, this.Rdiag = S;
    }
    solve(_) {
      _ = re.checkMatrix(_);
      let d = this.QR, u = d.rows;
      if (_.rows !== u)
        throw new Error("Matrix row dimensions must agree");
      if (!this.isFullRank())
        throw new Error("Matrix is rank deficient");
      let v = _.columns, S = _.clone(), L = d.columns, q, X, j, ae;
      for (j = 0; j < L; j++)
        for (X = 0; X < v; X++) {
          for (ae = 0, q = j; q < u; q++)
            ae += d.get(q, j) * S.get(q, X);
          for (ae = -ae / d.get(j, j), q = j; q < u; q++)
            S.set(q, X, S.get(q, X) + ae * d.get(q, j));
        }
      for (j = L - 1; j >= 0; j--) {
        for (X = 0; X < v; X++)
          S.set(j, X, S.get(j, X) / this.Rdiag[j]);
        for (q = 0; q < j; q++)
          for (X = 0; X < v; X++)
            S.set(q, X, S.get(q, X) - S.get(j, X) * d.get(q, j));
      }
      return S.subMatrix(0, L - 1, 0, v - 1);
    }
    isFullRank() {
      let _ = this.QR.columns;
      for (let d = 0; d < _; d++)
        if (this.Rdiag[d] === 0)
          return !1;
      return !0;
    }
    get upperTriangularMatrix() {
      let _ = this.QR, d = _.columns, u = new re(d, d), v, S;
      for (v = 0; v < d; v++)
        for (S = 0; S < d; S++)
          v < S ? u.set(v, S, _.get(v, S)) : v === S ? u.set(v, S, this.Rdiag[v]) : u.set(v, S, 0);
      return u;
    }
    get orthogonalMatrix() {
      let _ = this.QR, d = _.rows, u = _.columns, v = new re(d, u), S, L, q, X;
      for (q = u - 1; q >= 0; q--) {
        for (S = 0; S < d; S++)
          v.set(S, q, 0);
        for (v.set(q, q, 1), L = q; L < u; L++)
          if (_.get(q, q) !== 0) {
            for (X = 0, S = q; S < d; S++)
              X += _.get(S, q) * v.get(S, L);
            for (X = -X / _.get(q, q), S = q; S < d; S++)
              v.set(S, L, v.get(S, L) + X * _.get(S, q));
          }
      }
      return v;
    }
  }
  class lt {
    constructor(_, d = {}) {
      if (_ = he.checkMatrix(_), _.isEmpty())
        throw new Error("Matrix must be non-empty");
      let u = _.rows, v = _.columns;
      const {
        computeLeftSingularVectors: S = !0,
        computeRightSingularVectors: L = !0,
        autoTranspose: q = !1
      } = d;
      let X = !!S, j = !!L, ae = !1, K;
      if (u < v)
        if (!q)
          K = _.clone(), console.warn(
            "Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose"
          );
        else {
          K = _.transpose(), u = K.rows, v = K.columns, ae = !0;
          let se = X;
          X = j, j = se;
        }
      else
        K = _.clone();
      let ce = Math.min(u, v), we = Math.min(u + 1, v), le = new Float64Array(we), ge = new re(u, ce), Ue = new re(v, v), ie = new Float64Array(v), Ce = new Float64Array(u), Xe = new Float64Array(we);
      for (let se = 0; se < we; se++) Xe[se] = se;
      let ht = Math.min(u - 1, v), ft = Math.max(0, Math.min(v - 2, u)), dt = Math.max(ht, ft);
      for (let se = 0; se < dt; se++) {
        if (se < ht) {
          le[se] = 0;
          for (let Ie = se; Ie < u; Ie++)
            le[se] = He(le[se], K.get(Ie, se));
          if (le[se] !== 0) {
            K.get(se, se) < 0 && (le[se] = -le[se]);
            for (let Ie = se; Ie < u; Ie++)
              K.set(Ie, se, K.get(Ie, se) / le[se]);
            K.set(se, se, K.get(se, se) + 1);
          }
          le[se] = -le[se];
        }
        for (let Ie = se + 1; Ie < v; Ie++) {
          if (se < ht && le[se] !== 0) {
            let Ke = 0;
            for (let Pe = se; Pe < u; Pe++)
              Ke += K.get(Pe, se) * K.get(Pe, Ie);
            Ke = -Ke / K.get(se, se);
            for (let Pe = se; Pe < u; Pe++)
              K.set(Pe, Ie, K.get(Pe, Ie) + Ke * K.get(Pe, se));
          }
          ie[Ie] = K.get(se, Ie);
        }
        if (X && se < ht)
          for (let Ie = se; Ie < u; Ie++)
            ge.set(Ie, se, K.get(Ie, se));
        if (se < ft) {
          ie[se] = 0;
          for (let Ie = se + 1; Ie < v; Ie++)
            ie[se] = He(ie[se], ie[Ie]);
          if (ie[se] !== 0) {
            ie[se + 1] < 0 && (ie[se] = 0 - ie[se]);
            for (let Ie = se + 1; Ie < v; Ie++)
              ie[Ie] /= ie[se];
            ie[se + 1] += 1;
          }
          if (ie[se] = -ie[se], se + 1 < u && ie[se] !== 0) {
            for (let Ie = se + 1; Ie < u; Ie++)
              Ce[Ie] = 0;
            for (let Ie = se + 1; Ie < u; Ie++)
              for (let Ke = se + 1; Ke < v; Ke++)
                Ce[Ie] += ie[Ke] * K.get(Ie, Ke);
            for (let Ie = se + 1; Ie < v; Ie++) {
              let Ke = -ie[Ie] / ie[se + 1];
              for (let Pe = se + 1; Pe < u; Pe++)
                K.set(Pe, Ie, K.get(Pe, Ie) + Ke * Ce[Pe]);
            }
          }
          if (j)
            for (let Ie = se + 1; Ie < v; Ie++)
              Ue.set(Ie, se, ie[Ie]);
        }
      }
      let rt = Math.min(v, u + 1);
      if (ht < v && (le[ht] = K.get(ht, ht)), u < rt && (le[rt - 1] = 0), ft + 1 < rt && (ie[ft] = K.get(ft, rt - 1)), ie[rt - 1] = 0, X) {
        for (let se = ht; se < ce; se++) {
          for (let Ie = 0; Ie < u; Ie++)
            ge.set(Ie, se, 0);
          ge.set(se, se, 1);
        }
        for (let se = ht - 1; se >= 0; se--)
          if (le[se] !== 0) {
            for (let Ie = se + 1; Ie < ce; Ie++) {
              let Ke = 0;
              for (let Pe = se; Pe < u; Pe++)
                Ke += ge.get(Pe, se) * ge.get(Pe, Ie);
              Ke = -Ke / ge.get(se, se);
              for (let Pe = se; Pe < u; Pe++)
                ge.set(Pe, Ie, ge.get(Pe, Ie) + Ke * ge.get(Pe, se));
            }
            for (let Ie = se; Ie < u; Ie++)
              ge.set(Ie, se, -ge.get(Ie, se));
            ge.set(se, se, 1 + ge.get(se, se));
            for (let Ie = 0; Ie < se - 1; Ie++)
              ge.set(Ie, se, 0);
          } else {
            for (let Ie = 0; Ie < u; Ie++)
              ge.set(Ie, se, 0);
            ge.set(se, se, 1);
          }
      }
      if (j)
        for (let se = v - 1; se >= 0; se--) {
          if (se < ft && ie[se] !== 0)
            for (let Ie = se + 1; Ie < v; Ie++) {
              let Ke = 0;
              for (let Pe = se + 1; Pe < v; Pe++)
                Ke += Ue.get(Pe, se) * Ue.get(Pe, Ie);
              Ke = -Ke / Ue.get(se + 1, se);
              for (let Pe = se + 1; Pe < v; Pe++)
                Ue.set(Pe, Ie, Ue.get(Pe, Ie) + Ke * Ue.get(Pe, se));
            }
          for (let Ie = 0; Ie < v; Ie++)
            Ue.set(Ie, se, 0);
          Ue.set(se, se, 1);
        }
      let at = rt - 1, gt = Number.EPSILON;
      for (; rt > 0; ) {
        let se, Ie;
        for (se = rt - 2; se >= -1 && se !== -1; se--) {
          const Ke = Number.MIN_VALUE + gt * Math.abs(le[se] + Math.abs(le[se + 1]));
          if (Math.abs(ie[se]) <= Ke || Number.isNaN(ie[se])) {
            ie[se] = 0;
            break;
          }
        }
        if (se === rt - 2)
          Ie = 4;
        else {
          let Ke;
          for (Ke = rt - 1; Ke >= se && Ke !== se; Ke--) {
            let Pe = (Ke !== rt ? Math.abs(ie[Ke]) : 0) + (Ke !== se + 1 ? Math.abs(ie[Ke - 1]) : 0);
            if (Math.abs(le[Ke]) <= gt * Pe) {
              le[Ke] = 0;
              break;
            }
          }
          Ke === se ? Ie = 3 : Ke === rt - 1 ? Ie = 1 : (Ie = 2, se = Ke);
        }
        switch (se++, Ie) {
          case 1: {
            let Ke = ie[rt - 2];
            ie[rt - 2] = 0;
            for (let Pe = rt - 2; Pe >= se; Pe--) {
              let mt = He(le[Pe], Ke), ct = le[Pe] / mt, pt = Ke / mt;
              if (le[Pe] = mt, Pe !== se && (Ke = -pt * ie[Pe - 1], ie[Pe - 1] = ct * ie[Pe - 1]), j)
                for (let _t = 0; _t < v; _t++)
                  mt = ct * Ue.get(_t, Pe) + pt * Ue.get(_t, rt - 1), Ue.set(_t, rt - 1, -pt * Ue.get(_t, Pe) + ct * Ue.get(_t, rt - 1)), Ue.set(_t, Pe, mt);
            }
            break;
          }
          case 2: {
            let Ke = ie[se - 1];
            ie[se - 1] = 0;
            for (let Pe = se; Pe < rt; Pe++) {
              let mt = He(le[Pe], Ke), ct = le[Pe] / mt, pt = Ke / mt;
              if (le[Pe] = mt, Ke = -pt * ie[Pe], ie[Pe] = ct * ie[Pe], X)
                for (let _t = 0; _t < u; _t++)
                  mt = ct * ge.get(_t, Pe) + pt * ge.get(_t, se - 1), ge.set(_t, se - 1, -pt * ge.get(_t, Pe) + ct * ge.get(_t, se - 1)), ge.set(_t, Pe, mt);
            }
            break;
          }
          case 3: {
            const Ke = Math.max(
              Math.abs(le[rt - 1]),
              Math.abs(le[rt - 2]),
              Math.abs(ie[rt - 2]),
              Math.abs(le[se]),
              Math.abs(ie[se])
            ), Pe = le[rt - 1] / Ke, mt = le[rt - 2] / Ke, ct = ie[rt - 2] / Ke, pt = le[se] / Ke, _t = ie[se] / Ke, bt = ((mt + Pe) * (mt - Pe) + ct * ct) / 2, Mt = Pe * ct * (Pe * ct);
            let xt = 0;
            (bt !== 0 || Mt !== 0) && (bt < 0 ? xt = 0 - Math.sqrt(bt * bt + Mt) : xt = Math.sqrt(bt * bt + Mt), xt = Mt / (bt + xt));
            let kt = (pt + Pe) * (pt - Pe) + xt, At = pt * _t;
            for (let ut = se; ut < rt - 1; ut++) {
              let vt = He(kt, At);
              vt === 0 && (vt = Number.MIN_VALUE);
              let yt = kt / vt, Et = At / vt;
              if (ut !== se && (ie[ut - 1] = vt), kt = yt * le[ut] + Et * ie[ut], ie[ut] = yt * ie[ut] - Et * le[ut], At = Et * le[ut + 1], le[ut + 1] = yt * le[ut + 1], j)
                for (let wt = 0; wt < v; wt++)
                  vt = yt * Ue.get(wt, ut) + Et * Ue.get(wt, ut + 1), Ue.set(wt, ut + 1, -Et * Ue.get(wt, ut) + yt * Ue.get(wt, ut + 1)), Ue.set(wt, ut, vt);
              if (vt = He(kt, At), vt === 0 && (vt = Number.MIN_VALUE), yt = kt / vt, Et = At / vt, le[ut] = vt, kt = yt * ie[ut] + Et * le[ut + 1], le[ut + 1] = -Et * ie[ut] + yt * le[ut + 1], At = Et * ie[ut + 1], ie[ut + 1] = yt * ie[ut + 1], X && ut < u - 1)
                for (let wt = 0; wt < u; wt++)
                  vt = yt * ge.get(wt, ut) + Et * ge.get(wt, ut + 1), ge.set(wt, ut + 1, -Et * ge.get(wt, ut) + yt * ge.get(wt, ut + 1)), ge.set(wt, ut, vt);
            }
            ie[rt - 2] = kt;
            break;
          }
          case 4: {
            if (le[se] <= 0 && (le[se] = le[se] < 0 ? -le[se] : 0, j))
              for (let Ke = 0; Ke <= at; Ke++)
                Ue.set(Ke, se, -Ue.get(Ke, se));
            for (; se < at && !(le[se] >= le[se + 1]); ) {
              let Ke = le[se];
              if (le[se] = le[se + 1], le[se + 1] = Ke, j && se < v - 1)
                for (let Pe = 0; Pe < v; Pe++)
                  Ke = Ue.get(Pe, se + 1), Ue.set(Pe, se + 1, Ue.get(Pe, se)), Ue.set(Pe, se, Ke);
              if (X && se < u - 1)
                for (let Pe = 0; Pe < u; Pe++)
                  Ke = ge.get(Pe, se + 1), ge.set(Pe, se + 1, ge.get(Pe, se)), ge.set(Pe, se, Ke);
              se++;
            }
            rt--;
            break;
          }
        }
      }
      if (ae) {
        let se = Ue;
        Ue = ge, ge = se;
      }
      this.m = u, this.n = v, this.s = le, this.U = ge, this.V = Ue;
    }
    solve(_) {
      let d = _, u = this.threshold, v = this.s.length, S = re.zeros(v, v);
      for (let ce = 0; ce < v; ce++)
        Math.abs(this.s[ce]) <= u ? S.set(ce, ce, 0) : S.set(ce, ce, 1 / this.s[ce]);
      let L = this.U, q = this.rightSingularVectors, X = q.mmul(S), j = q.rows, ae = L.rows, K = re.zeros(j, ae);
      for (let ce = 0; ce < j; ce++)
        for (let we = 0; we < ae; we++) {
          let le = 0;
          for (let ge = 0; ge < v; ge++)
            le += X.get(ce, ge) * L.get(we, ge);
          K.set(ce, we, le);
        }
      return K.mmul(d);
    }
    solveForDiagonal(_) {
      return this.solve(re.diag(_));
    }
    inverse() {
      let _ = this.V, d = this.threshold, u = _.rows, v = _.columns, S = new re(u, this.s.length);
      for (let ae = 0; ae < u; ae++)
        for (let K = 0; K < v; K++)
          Math.abs(this.s[K]) > d && S.set(ae, K, _.get(ae, K) / this.s[K]);
      let L = this.U, q = L.rows, X = L.columns, j = new re(u, q);
      for (let ae = 0; ae < u; ae++)
        for (let K = 0; K < q; K++) {
          let ce = 0;
          for (let we = 0; we < X; we++)
            ce += S.get(ae, we) * L.get(K, we);
          j.set(ae, K, ce);
        }
      return j;
    }
    get condition() {
      return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
    }
    get norm2() {
      return this.s[0];
    }
    get rank() {
      let _ = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON, d = 0, u = this.s;
      for (let v = 0, S = u.length; v < S; v++)
        u[v] > _ && d++;
      return d;
    }
    get diagonal() {
      return Array.from(this.s);
    }
    get threshold() {
      return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
    }
    get leftSingularVectors() {
      return this.U;
    }
    get rightSingularVectors() {
      return this.V;
    }
    get diagonalMatrix() {
      return re.diag(this.s);
    }
  }
  function ot(M, _ = !1) {
    return M = he.checkMatrix(M), _ ? new lt(M).inverse() : Le(M, re.eye(M.rows));
  }
  function Le(M, _, d = !1) {
    return M = he.checkMatrix(M), _ = he.checkMatrix(_), d ? new lt(M).solve(_) : M.isSquare() ? new Ze(M).solve(_) : new De(M).solve(_);
  }
  function ze(M) {
    if (M = re.checkMatrix(M), M.isSquare()) {
      if (M.columns === 0)
        return 1;
      let _, d, u, v;
      if (M.columns === 2)
        return _ = M.get(0, 0), d = M.get(0, 1), u = M.get(1, 0), v = M.get(1, 1), _ * v - d * u;
      if (M.columns === 3) {
        let S, L, q;
        return S = new Re(M, [1, 2], [1, 2]), L = new Re(M, [1, 2], [0, 2]), q = new Re(M, [1, 2], [0, 1]), _ = M.get(0, 0), d = M.get(0, 1), u = M.get(0, 2), _ * ze(S) - d * ze(L) + u * ze(q);
      } else
        return new Ze(M).determinant;
    } else
      throw Error("determinant can only be calculated for a square matrix");
  }
  function je(M, _) {
    let d = [];
    for (let u = 0; u < M; u++)
      u !== _ && d.push(u);
    return d;
  }
  function Oe(M, _, d, u = 1e-9, v = 1e-9) {
    if (M > v)
      return new Array(_.rows + 1).fill(0);
    {
      let S = _.addRow(d, [0]);
      for (let L = 0; L < S.rows; L++)
        Math.abs(S.get(L, 0)) < u && S.set(L, 0, 0);
      return S.to1DArray();
    }
  }
  function st(M, _ = {}) {
    const { thresholdValue: d = 1e-9, thresholdError: u = 1e-9 } = _;
    M = re.checkMatrix(M);
    let v = M.rows, S = new re(v, v);
    for (let L = 0; L < v; L++) {
      let q = re.columnVector(M.getRow(L)), X = M.subMatrixRow(je(v, L)).transpose(), ae = new lt(X).solve(q), K = re.sub(q, X.mmul(ae)).abs().max();
      S.setRow(
        L,
        Oe(K, ae, L, d, u)
      );
    }
    return S;
  }
  function Z(M, _ = Number.EPSILON) {
    if (M = re.checkMatrix(M), M.isEmpty())
      return M.transpose();
    let d = new lt(M, { autoTranspose: !0 }), u = d.leftSingularVectors, v = d.rightSingularVectors, S = d.diagonal;
    for (let L = 0; L < S.length; L++)
      Math.abs(S[L]) > _ ? S[L] = 1 / S[L] : S[L] = 0;
    return v.mmul(re.diag(S).mmul(u.transpose()));
  }
  function ue(M, _ = M, d = {}) {
    M = new re(M);
    let u = !1;
    if (typeof _ == "object" && !re.isMatrix(_) && !e.isAnyArray(_) ? (d = _, _ = M, u = !0) : _ = new re(_), M.rows !== _.rows)
      throw new TypeError("Both matrices must have the same number of rows");
    const { center: v = !0 } = d;
    v && (M = M.center("column"), u || (_ = _.center("column")));
    const S = M.transpose().mmul(_);
    for (let L = 0; L < S.rows; L++)
      for (let q = 0; q < S.columns; q++)
        S.set(L, q, S.get(L, q) * (1 / (M.rows - 1)));
    return S;
  }
  function xe(M, _ = M, d = {}) {
    M = new re(M);
    let u = !1;
    if (typeof _ == "object" && !re.isMatrix(_) && !e.isAnyArray(_) ? (d = _, _ = M, u = !0) : _ = new re(_), M.rows !== _.rows)
      throw new TypeError("Both matrices must have the same number of rows");
    const { center: v = !0, scale: S = !0 } = d;
    v && (M.center("column"), u || _.center("column")), S && (M.scale("column"), u || _.scale("column"));
    const L = M.standardDeviation("column", { unbiased: !0 }), q = u ? L : _.standardDeviation("column", { unbiased: !0 }), X = M.transpose().mmul(_);
    for (let j = 0; j < X.rows; j++)
      for (let ae = 0; ae < X.columns; ae++)
        X.set(
          j,
          ae,
          X.get(j, ae) * (1 / (L[j] * q[ae])) * (1 / (M.rows - 1))
        );
    return X;
  }
  class ke {
    constructor(_, d = {}) {
      const { assumeSymmetric: u = !1 } = d;
      if (_ = he.checkMatrix(_), !_.isSquare())
        throw new Error("Matrix is not a square matrix");
      if (_.isEmpty())
        throw new Error("Matrix must be non-empty");
      let v = _.columns, S = new re(v, v), L = new Float64Array(v), q = new Float64Array(v), X = _, j, ae, K = !1;
      if (u ? K = !0 : K = _.isSymmetric(), K) {
        for (j = 0; j < v; j++)
          for (ae = 0; ae < v; ae++)
            S.set(j, ae, X.get(j, ae));
        te(v, q, L, S), me(v, q, L, S);
      } else {
        let ce = new re(v, v), we = new Float64Array(v);
        for (ae = 0; ae < v; ae++)
          for (j = 0; j < v; j++)
            ce.set(j, ae, X.get(j, ae));
        U(v, ce, we, S), ye(v, q, L, S, ce);
      }
      this.n = v, this.e = q, this.d = L, this.V = S;
    }
    get realEigenvalues() {
      return Array.from(this.d);
    }
    get imaginaryEigenvalues() {
      return Array.from(this.e);
    }
    get eigenvectorMatrix() {
      return this.V;
    }
    get diagonalMatrix() {
      let _ = this.n, d = this.e, u = this.d, v = new re(_, _), S, L;
      for (S = 0; S < _; S++) {
        for (L = 0; L < _; L++)
          v.set(S, L, 0);
        v.set(S, S, u[S]), d[S] > 0 ? v.set(S, S + 1, d[S]) : d[S] < 0 && v.set(S, S - 1, d[S]);
      }
      return v;
    }
  }
  function te(M, _, d, u) {
    let v, S, L, q, X, j, ae, K;
    for (X = 0; X < M; X++)
      d[X] = u.get(M - 1, X);
    for (q = M - 1; q > 0; q--) {
      for (K = 0, L = 0, j = 0; j < q; j++)
        K = K + Math.abs(d[j]);
      if (K === 0)
        for (_[q] = d[q - 1], X = 0; X < q; X++)
          d[X] = u.get(q - 1, X), u.set(q, X, 0), u.set(X, q, 0);
      else {
        for (j = 0; j < q; j++)
          d[j] /= K, L += d[j] * d[j];
        for (v = d[q - 1], S = Math.sqrt(L), v > 0 && (S = -S), _[q] = K * S, L = L - v * S, d[q - 1] = v - S, X = 0; X < q; X++)
          _[X] = 0;
        for (X = 0; X < q; X++) {
          for (v = d[X], u.set(X, q, v), S = _[X] + u.get(X, X) * v, j = X + 1; j <= q - 1; j++)
            S += u.get(j, X) * d[j], _[j] += u.get(j, X) * v;
          _[X] = S;
        }
        for (v = 0, X = 0; X < q; X++)
          _[X] /= L, v += _[X] * d[X];
        for (ae = v / (L + L), X = 0; X < q; X++)
          _[X] -= ae * d[X];
        for (X = 0; X < q; X++) {
          for (v = d[X], S = _[X], j = X; j <= q - 1; j++)
            u.set(j, X, u.get(j, X) - (v * _[j] + S * d[j]));
          d[X] = u.get(q - 1, X), u.set(q, X, 0);
        }
      }
      d[q] = L;
    }
    for (q = 0; q < M - 1; q++) {
      if (u.set(M - 1, q, u.get(q, q)), u.set(q, q, 1), L = d[q + 1], L !== 0) {
        for (j = 0; j <= q; j++)
          d[j] = u.get(j, q + 1) / L;
        for (X = 0; X <= q; X++) {
          for (S = 0, j = 0; j <= q; j++)
            S += u.get(j, q + 1) * u.get(j, X);
          for (j = 0; j <= q; j++)
            u.set(j, X, u.get(j, X) - S * d[j]);
        }
      }
      for (j = 0; j <= q; j++)
        u.set(j, q + 1, 0);
    }
    for (X = 0; X < M; X++)
      d[X] = u.get(M - 1, X), u.set(M - 1, X, 0);
    u.set(M - 1, M - 1, 1), _[0] = 0;
  }
  function me(M, _, d, u) {
    let v, S, L, q, X, j, ae, K, ce, we, le, ge, Ue, ie, Ce, Xe;
    for (L = 1; L < M; L++)
      _[L - 1] = _[L];
    _[M - 1] = 0;
    let ht = 0, ft = 0, dt = Number.EPSILON;
    for (j = 0; j < M; j++) {
      for (ft = Math.max(ft, Math.abs(d[j]) + Math.abs(_[j])), ae = j; ae < M && !(Math.abs(_[ae]) <= dt * ft); )
        ae++;
      if (ae > j)
        do {
          for (v = d[j], K = (d[j + 1] - v) / (2 * _[j]), ce = He(K, 1), K < 0 && (ce = -ce), d[j] = _[j] / (K + ce), d[j + 1] = _[j] * (K + ce), we = d[j + 1], S = v - d[j], L = j + 2; L < M; L++)
            d[L] -= S;
          for (ht = ht + S, K = d[ae], le = 1, ge = le, Ue = le, ie = _[j + 1], Ce = 0, Xe = 0, L = ae - 1; L >= j; L--)
            for (Ue = ge, ge = le, Xe = Ce, v = le * _[L], S = le * K, ce = He(K, _[L]), _[L + 1] = Ce * ce, Ce = _[L] / ce, le = K / ce, K = le * d[L] - Ce * v, d[L + 1] = S + Ce * (le * v + Ce * d[L]), X = 0; X < M; X++)
              S = u.get(X, L + 1), u.set(X, L + 1, Ce * u.get(X, L) + le * S), u.set(X, L, le * u.get(X, L) - Ce * S);
          K = -Ce * Xe * Ue * ie * _[j] / we, _[j] = Ce * K, d[j] = le * K;
        } while (Math.abs(_[j]) > dt * ft);
      d[j] = d[j] + ht, _[j] = 0;
    }
    for (L = 0; L < M - 1; L++) {
      for (X = L, K = d[L], q = L + 1; q < M; q++)
        d[q] < K && (X = q, K = d[q]);
      if (X !== L)
        for (d[X] = d[L], d[L] = K, q = 0; q < M; q++)
          K = u.get(q, L), u.set(q, L, u.get(q, X)), u.set(q, X, K);
    }
  }
  function U(M, _, d, u) {
    let v = 0, S = M - 1, L, q, X, j, ae, K, ce;
    for (K = v + 1; K <= S - 1; K++) {
      for (ce = 0, j = K; j <= S; j++)
        ce = ce + Math.abs(_.get(j, K - 1));
      if (ce !== 0) {
        for (X = 0, j = S; j >= K; j--)
          d[j] = _.get(j, K - 1) / ce, X += d[j] * d[j];
        for (q = Math.sqrt(X), d[K] > 0 && (q = -q), X = X - d[K] * q, d[K] = d[K] - q, ae = K; ae < M; ae++) {
          for (L = 0, j = S; j >= K; j--)
            L += d[j] * _.get(j, ae);
          for (L = L / X, j = K; j <= S; j++)
            _.set(j, ae, _.get(j, ae) - L * d[j]);
        }
        for (j = 0; j <= S; j++) {
          for (L = 0, ae = S; ae >= K; ae--)
            L += d[ae] * _.get(j, ae);
          for (L = L / X, ae = K; ae <= S; ae++)
            _.set(j, ae, _.get(j, ae) - L * d[ae]);
        }
        d[K] = ce * d[K], _.set(K, K - 1, ce * q);
      }
    }
    for (j = 0; j < M; j++)
      for (ae = 0; ae < M; ae++)
        u.set(j, ae, j === ae ? 1 : 0);
    for (K = S - 1; K >= v + 1; K--)
      if (_.get(K, K - 1) !== 0) {
        for (j = K + 1; j <= S; j++)
          d[j] = _.get(j, K - 1);
        for (ae = K; ae <= S; ae++) {
          for (q = 0, j = K; j <= S; j++)
            q += d[j] * u.get(j, ae);
          for (q = q / d[K] / _.get(K, K - 1), j = K; j <= S; j++)
            u.set(j, ae, u.get(j, ae) + q * d[j]);
        }
      }
  }
  function ye(M, _, d, u, v) {
    let S = M - 1, L = 0, q = M - 1, X = Number.EPSILON, j = 0, ae = 0, K = 0, ce = 0, we = 0, le = 0, ge = 0, Ue = 0, ie, Ce, Xe, ht, ft, dt, rt, at, gt, se, Ie, Ke, Pe, mt, ct;
    for (ie = 0; ie < M; ie++)
      for ((ie < L || ie > q) && (d[ie] = v.get(ie, ie), _[ie] = 0), Ce = Math.max(ie - 1, 0); Ce < M; Ce++)
        ae = ae + Math.abs(v.get(ie, Ce));
    for (; S >= L; ) {
      for (ht = S; ht > L && (le = Math.abs(v.get(ht - 1, ht - 1)) + Math.abs(v.get(ht, ht)), le === 0 && (le = ae), !(Math.abs(v.get(ht, ht - 1)) < X * le)); )
        ht--;
      if (ht === S)
        v.set(S, S, v.get(S, S) + j), d[S] = v.get(S, S), _[S] = 0, S--, Ue = 0;
      else if (ht === S - 1) {
        if (rt = v.get(S, S - 1) * v.get(S - 1, S), K = (v.get(S - 1, S - 1) - v.get(S, S)) / 2, ce = K * K + rt, ge = Math.sqrt(Math.abs(ce)), v.set(S, S, v.get(S, S) + j), v.set(S - 1, S - 1, v.get(S - 1, S - 1) + j), at = v.get(S, S), ce >= 0) {
          for (ge = K >= 0 ? K + ge : K - ge, d[S - 1] = at + ge, d[S] = d[S - 1], ge !== 0 && (d[S] = at - rt / ge), _[S - 1] = 0, _[S] = 0, at = v.get(S, S - 1), le = Math.abs(at) + Math.abs(ge), K = at / le, ce = ge / le, we = Math.sqrt(K * K + ce * ce), K = K / we, ce = ce / we, Ce = S - 1; Ce < M; Ce++)
            ge = v.get(S - 1, Ce), v.set(S - 1, Ce, ce * ge + K * v.get(S, Ce)), v.set(S, Ce, ce * v.get(S, Ce) - K * ge);
          for (ie = 0; ie <= S; ie++)
            ge = v.get(ie, S - 1), v.set(ie, S - 1, ce * ge + K * v.get(ie, S)), v.set(ie, S, ce * v.get(ie, S) - K * ge);
          for (ie = L; ie <= q; ie++)
            ge = u.get(ie, S - 1), u.set(ie, S - 1, ce * ge + K * u.get(ie, S)), u.set(ie, S, ce * u.get(ie, S) - K * ge);
        } else
          d[S - 1] = at + K, d[S] = at + K, _[S - 1] = ge, _[S] = -ge;
        S = S - 2, Ue = 0;
      } else {
        if (at = v.get(S, S), gt = 0, rt = 0, ht < S && (gt = v.get(S - 1, S - 1), rt = v.get(S, S - 1) * v.get(S - 1, S)), Ue === 10) {
          for (j += at, ie = L; ie <= S; ie++)
            v.set(ie, ie, v.get(ie, ie) - at);
          le = Math.abs(v.get(S, S - 1)) + Math.abs(v.get(S - 1, S - 2)), at = gt = 0.75 * le, rt = -0.4375 * le * le;
        }
        if (Ue === 30 && (le = (gt - at) / 2, le = le * le + rt, le > 0)) {
          for (le = Math.sqrt(le), gt < at && (le = -le), le = at - rt / ((gt - at) / 2 + le), ie = L; ie <= S; ie++)
            v.set(ie, ie, v.get(ie, ie) - le);
          j += le, at = gt = rt = 0.964;
        }
        for (Ue = Ue + 1, ft = S - 2; ft >= ht && (ge = v.get(ft, ft), we = at - ge, le = gt - ge, K = (we * le - rt) / v.get(ft + 1, ft) + v.get(ft, ft + 1), ce = v.get(ft + 1, ft + 1) - ge - we - le, we = v.get(ft + 2, ft + 1), le = Math.abs(K) + Math.abs(ce) + Math.abs(we), K = K / le, ce = ce / le, we = we / le, !(ft === ht || Math.abs(v.get(ft, ft - 1)) * (Math.abs(ce) + Math.abs(we)) < X * (Math.abs(K) * (Math.abs(v.get(ft - 1, ft - 1)) + Math.abs(ge) + Math.abs(v.get(ft + 1, ft + 1)))))); )
          ft--;
        for (ie = ft + 2; ie <= S; ie++)
          v.set(ie, ie - 2, 0), ie > ft + 2 && v.set(ie, ie - 3, 0);
        for (Xe = ft; Xe <= S - 1 && (mt = Xe !== S - 1, Xe !== ft && (K = v.get(Xe, Xe - 1), ce = v.get(Xe + 1, Xe - 1), we = mt ? v.get(Xe + 2, Xe - 1) : 0, at = Math.abs(K) + Math.abs(ce) + Math.abs(we), at !== 0 && (K = K / at, ce = ce / at, we = we / at)), at !== 0); Xe++)
          if (le = Math.sqrt(K * K + ce * ce + we * we), K < 0 && (le = -le), le !== 0) {
            for (Xe !== ft ? v.set(Xe, Xe - 1, -le * at) : ht !== ft && v.set(Xe, Xe - 1, -v.get(Xe, Xe - 1)), K = K + le, at = K / le, gt = ce / le, ge = we / le, ce = ce / K, we = we / K, Ce = Xe; Ce < M; Ce++)
              K = v.get(Xe, Ce) + ce * v.get(Xe + 1, Ce), mt && (K = K + we * v.get(Xe + 2, Ce), v.set(Xe + 2, Ce, v.get(Xe + 2, Ce) - K * ge)), v.set(Xe, Ce, v.get(Xe, Ce) - K * at), v.set(Xe + 1, Ce, v.get(Xe + 1, Ce) - K * gt);
            for (ie = 0; ie <= Math.min(S, Xe + 3); ie++)
              K = at * v.get(ie, Xe) + gt * v.get(ie, Xe + 1), mt && (K = K + ge * v.get(ie, Xe + 2), v.set(ie, Xe + 2, v.get(ie, Xe + 2) - K * we)), v.set(ie, Xe, v.get(ie, Xe) - K), v.set(ie, Xe + 1, v.get(ie, Xe + 1) - K * ce);
            for (ie = L; ie <= q; ie++)
              K = at * u.get(ie, Xe) + gt * u.get(ie, Xe + 1), mt && (K = K + ge * u.get(ie, Xe + 2), u.set(ie, Xe + 2, u.get(ie, Xe + 2) - K * we)), u.set(ie, Xe, u.get(ie, Xe) - K), u.set(ie, Xe + 1, u.get(ie, Xe + 1) - K * ce);
          }
      }
    }
    if (ae !== 0) {
      for (S = M - 1; S >= 0; S--)
        if (K = d[S], ce = _[S], ce === 0)
          for (ht = S, v.set(S, S, 1), ie = S - 1; ie >= 0; ie--) {
            for (rt = v.get(ie, ie) - K, we = 0, Ce = ht; Ce <= S; Ce++)
              we = we + v.get(ie, Ce) * v.get(Ce, S);
            if (_[ie] < 0)
              ge = rt, le = we;
            else if (ht = ie, _[ie] === 0 ? v.set(ie, S, rt !== 0 ? -we / rt : -we / (X * ae)) : (at = v.get(ie, ie + 1), gt = v.get(ie + 1, ie), ce = (d[ie] - K) * (d[ie] - K) + _[ie] * _[ie], dt = (at * le - ge * we) / ce, v.set(ie, S, dt), v.set(
              ie + 1,
              S,
              Math.abs(at) > Math.abs(ge) ? (-we - rt * dt) / at : (-le - gt * dt) / ge
            )), dt = Math.abs(v.get(ie, S)), X * dt * dt > 1)
              for (Ce = ie; Ce <= S; Ce++)
                v.set(Ce, S, v.get(Ce, S) / dt);
          }
        else if (ce < 0)
          for (ht = S - 1, Math.abs(v.get(S, S - 1)) > Math.abs(v.get(S - 1, S)) ? (v.set(S - 1, S - 1, ce / v.get(S, S - 1)), v.set(S - 1, S, -(v.get(S, S) - K) / v.get(S, S - 1))) : (ct = it(0, -v.get(S - 1, S), v.get(S - 1, S - 1) - K, ce), v.set(S - 1, S - 1, ct[0]), v.set(S - 1, S, ct[1])), v.set(S, S - 1, 0), v.set(S, S, 1), ie = S - 2; ie >= 0; ie--) {
            for (se = 0, Ie = 0, Ce = ht; Ce <= S; Ce++)
              se = se + v.get(ie, Ce) * v.get(Ce, S - 1), Ie = Ie + v.get(ie, Ce) * v.get(Ce, S);
            if (rt = v.get(ie, ie) - K, _[ie] < 0)
              ge = rt, we = se, le = Ie;
            else if (ht = ie, _[ie] === 0 ? (ct = it(-se, -Ie, rt, ce), v.set(ie, S - 1, ct[0]), v.set(ie, S, ct[1])) : (at = v.get(ie, ie + 1), gt = v.get(ie + 1, ie), Ke = (d[ie] - K) * (d[ie] - K) + _[ie] * _[ie] - ce * ce, Pe = (d[ie] - K) * 2 * ce, Ke === 0 && Pe === 0 && (Ke = X * ae * (Math.abs(rt) + Math.abs(ce) + Math.abs(at) + Math.abs(gt) + Math.abs(ge))), ct = it(
              at * we - ge * se + ce * Ie,
              at * le - ge * Ie - ce * se,
              Ke,
              Pe
            ), v.set(ie, S - 1, ct[0]), v.set(ie, S, ct[1]), Math.abs(at) > Math.abs(ge) + Math.abs(ce) ? (v.set(
              ie + 1,
              S - 1,
              (-se - rt * v.get(ie, S - 1) + ce * v.get(ie, S)) / at
            ), v.set(
              ie + 1,
              S,
              (-Ie - rt * v.get(ie, S) - ce * v.get(ie, S - 1)) / at
            )) : (ct = it(
              -we - gt * v.get(ie, S - 1),
              -le - gt * v.get(ie, S),
              ge,
              ce
            ), v.set(ie + 1, S - 1, ct[0]), v.set(ie + 1, S, ct[1]))), dt = Math.max(Math.abs(v.get(ie, S - 1)), Math.abs(v.get(ie, S))), X * dt * dt > 1)
              for (Ce = ie; Ce <= S; Ce++)
                v.set(Ce, S - 1, v.get(Ce, S - 1) / dt), v.set(Ce, S, v.get(Ce, S) / dt);
          }
      for (ie = 0; ie < M; ie++)
        if (ie < L || ie > q)
          for (Ce = ie; Ce < M; Ce++)
            u.set(ie, Ce, v.get(ie, Ce));
      for (Ce = M - 1; Ce >= L; Ce--)
        for (ie = L; ie <= q; ie++) {
          for (ge = 0, Xe = L; Xe <= Math.min(Ce, q); Xe++)
            ge = ge + u.get(ie, Xe) * v.get(Xe, Ce);
          u.set(ie, Ce, ge);
        }
    }
  }
  function it(M, _, d, u) {
    let v, S;
    return Math.abs(d) > Math.abs(u) ? (v = u / d, S = d + v * u, [(M + v * _) / S, (_ - v * M) / S]) : (v = d / u, S = u + v * d, [(v * M + _) / S, (v * _ - M) / S]);
  }
  class I {
    constructor(_) {
      if (_ = he.checkMatrix(_), !_.isSymmetric())
        throw new Error("Matrix is not symmetric");
      let d = _, u = d.rows, v = new re(u, u), S = !0, L, q, X;
      for (q = 0; q < u; q++) {
        let j = 0;
        for (X = 0; X < q; X++) {
          let ae = 0;
          for (L = 0; L < X; L++)
            ae += v.get(X, L) * v.get(q, L);
          ae = (d.get(q, X) - ae) / v.get(X, X), v.set(q, X, ae), j = j + ae * ae;
        }
        for (j = d.get(q, q) - j, S && (S = j > 0), v.set(q, q, Math.sqrt(Math.max(j, 0))), X = q + 1; X < u; X++)
          v.set(q, X, 0);
      }
      this.L = v, this.positiveDefinite = S;
    }
    isPositiveDefinite() {
      return this.positiveDefinite;
    }
    solve(_) {
      _ = he.checkMatrix(_);
      let d = this.L, u = d.rows;
      if (_.rows !== u)
        throw new Error("Matrix dimensions do not match");
      if (this.isPositiveDefinite() === !1)
        throw new Error("Matrix is not positive definite");
      let v = _.columns, S = _.clone(), L, q, X;
      for (X = 0; X < u; X++)
        for (q = 0; q < v; q++) {
          for (L = 0; L < X; L++)
            S.set(X, q, S.get(X, q) - S.get(L, q) * d.get(X, L));
          S.set(X, q, S.get(X, q) / d.get(X, X));
        }
      for (X = u - 1; X >= 0; X--)
        for (q = 0; q < v; q++) {
          for (L = X + 1; L < u; L++)
            S.set(X, q, S.get(X, q) - S.get(L, q) * d.get(L, X));
          S.set(X, q, S.get(X, q) / d.get(X, X));
        }
      return S;
    }
    get lowerTriangularMatrix() {
      return this.L;
    }
  }
  class fe {
    constructor(_, d = {}) {
      _ = he.checkMatrix(_);
      let { Y: u } = d;
      const {
        scaleScores: v = !1,
        maxIterations: S = 1e3,
        terminationCriteria: L = 1e-10
      } = d;
      let q;
      if (u) {
        if (e.isAnyArray(u) && typeof u[0] == "number" ? u = re.columnVector(u) : u = he.checkMatrix(u), u.rows !== _.rows)
          throw new Error("Y should have the same number of rows as X");
        q = u.getColumnVector(0);
      } else
        q = _.getColumnVector(0);
      let X = 1, j, ae, K, ce;
      for (let we = 0; we < S && X > L; we++)
        K = _.transpose().mmul(q).div(q.transpose().mmul(q).get(0, 0)), K = K.div(K.norm()), j = _.mmul(K).div(K.transpose().mmul(K).get(0, 0)), we > 0 && (X = j.clone().sub(ce).pow(2).sum()), ce = j.clone(), u ? (ae = u.transpose().mmul(j).div(j.transpose().mmul(j).get(0, 0)), ae = ae.div(ae.norm()), q = u.mmul(ae).div(ae.transpose().mmul(ae).get(0, 0))) : q = j;
      if (u) {
        let we = _.transpose().mmul(j).div(j.transpose().mmul(j).get(0, 0));
        we = we.div(we.norm());
        let le = _.clone().sub(j.clone().mmul(we.transpose())), ge = q.transpose().mmul(j).div(j.transpose().mmul(j).get(0, 0)), Ue = u.clone().sub(
          j.clone().mulS(ge.get(0, 0)).mmul(ae.transpose())
        );
        this.t = j, this.p = we.transpose(), this.w = K.transpose(), this.q = ae, this.u = q, this.s = j.transpose().mmul(j), this.xResidual = le, this.yResidual = Ue, this.betas = ge;
      } else
        this.w = K.transpose(), this.s = j.transpose().mmul(j).sqrt(), v ? this.t = j.clone().div(this.s.get(0, 0)) : this.t = j, this.xResidual = _.sub(j.mmul(K.transpose()));
    }
  }
  return matrix$1.AbstractMatrix = _e, matrix$1.CHO = I, matrix$1.CholeskyDecomposition = I, matrix$1.DistanceMatrix = Fe, matrix$1.EVD = ke, matrix$1.EigenvalueDecomposition = ke, matrix$1.LU = Ze, matrix$1.LuDecomposition = Ze, matrix$1.Matrix = re, matrix$1.MatrixColumnSelectionView = Je, matrix$1.MatrixColumnView = Ye, matrix$1.MatrixFlipColumnView = et, matrix$1.MatrixFlipRowView = Ve, matrix$1.MatrixRowSelectionView = qe, matrix$1.MatrixRowView = tt, matrix$1.MatrixSelectionView = Re, matrix$1.MatrixSubView = nt, matrix$1.MatrixTransposeView = Ge, matrix$1.NIPALS = fe, matrix$1.Nipals = fe, matrix$1.QR = De, matrix$1.QrDecomposition = De, matrix$1.SVD = lt, matrix$1.SingularValueDecomposition = lt, matrix$1.SymmetricMatrix = Te, matrix$1.WrapperMatrix1D = Ne, matrix$1.WrapperMatrix2D = he, matrix$1.correlation = xe, matrix$1.covariance = ue, matrix$1.default = re, matrix$1.determinant = ze, matrix$1.inverse = ot, matrix$1.linearDependencies = st, matrix$1.pseudoInverse = Z, matrix$1.solve = Le, matrix$1.wrap = Qe, matrix$1;
}
var matrixExports = /* @__PURE__ */ requireMatrix();
const matrix = /* @__PURE__ */ getDefaultExportFromCjs(matrixExports), Matrix$1 = matrixExports.Matrix, SVD = matrixExports.SVD, SingularValueDecomposition = matrixExports.SingularValueDecomposition;
matrix.Matrix ? matrix.Matrix : matrixExports.Matrix;
const inverse = matrixExports.inverse, solve = matrixExports.solve;
function getSeparatedKernel(e) {
  const i = new SVD(e, { autoTranspose: !0 });
  if (i.rank !== 1) return null;
  const t = Math.sqrt(i.s[0]), r = i.U.to2DArray().map((a) => a[0] * t), n = i.V.to2DArray().map((a) => a[0] * t);
  return [r, n];
}
function convolution(e, i = {}) {
  let {
    channels: t,
    bitDepth: r,
    normalize: n = !1,
    divisor: a = 1,
    border: s = "copy",
    algorithm: o = "auto"
  } = i, h = {};
  r && (h.bitDepth = r);
  let l = Image.createFrom(this, h);
  if (t = validateArrayOfChannels(this, t), o !== "separable")
    ({ kernel: e } = validateKernel(e));
  else if (!Array.isArray(e) || e.length !== 2)
    throw new RangeError(
      "separable convolution requires two arrays of numbers to represent the kernel"
    );
  if (o === "auto") {
    let $ = getSeparatedKernel(e);
    $ !== null ? (o = "separable", e = $) : (e.length > 9 || e[0].length > 9) && this.width <= 4096 && this.height <= 4096 ? o = "fft" : o = "direct";
  }
  let f, b;
  o === "separable" ? (f = Math.floor(e[0].length / 2), b = Math.floor(e[1].length / 2)) : (f = Math.floor(e.length / 2), b = Math.floor(e[0].length / 2));
  let w = l.isClamped, g = new Array(this.height * this.width), E, k, A, T, C, D;
  for (T = 0; T < t.length; T++) {
    for (C = t[T], A = 0; A < this.height; A++)
      for (k = 0; k < this.width; k++)
        E = A * this.width + k, g[E] = this.data[E * this.channels + C];
    if (o === "direct")
      D = srcExports$1.direct(g, e, {
        rows: this.height,
        cols: this.width,
        normalize: n,
        divisor: a
      });
    else if (o === "separable") {
      if (D = convolutionSeparable(
        g,
        e,
        this.width,
        this.height
      ), n) {
        a = 0;
        for (let $ = 0; $ < e[0].length; $++)
          for (let P = 0; P < e[1].length; P++)
            a += e[0][$] * e[1][P];
      }
      if (a !== 1)
        for (let $ = 0; $ < D.length; $++)
          D[$] /= a;
    } else
      D = srcExports$1.fft(g, e, {
        rows: this.height,
        cols: this.width,
        normalize: n,
        divisor: a
      });
    for (A = 0; A < this.height; A++)
      for (k = 0; k < this.width; k++)
        E = A * this.width + k, w ? l.data[E * this.channels + C] = clamp(
          D[E],
          l
        ) : l.data[E * this.channels + C] = D[E];
  }
  if (this.alpha && !t.includes(this.channels))
    for (k = this.components; k < this.data.length; k = k + this.channels)
      l.data[k] = this.data[k];
  return s !== "periodic" && l.setBorder({ size: [b, f], algorithm: s }), l;
}
function gradientFilter(e = {}) {
  let {
    direction: i = "xy",
    border: t = "copy",
    kernelX: r,
    kernelY: n,
    channels: a,
    bitDepth: s = this.bitDepth
  } = e;
  switch (this.checkProcessable("gradientFilter", {
    bitDepth: [8, 16]
  }), i) {
    case "x":
      if (!r) throw new Error("kernelX option is missing");
      return convolution.call(this, r, {
        channels: a,
        border: t,
        bitDepth: s
      });
    case "y":
      if (!n) throw new Error("kernelY option is missing");
      return convolution.call(this, n, {
        channels: a,
        border: t,
        bitDepth: s
      });
    case "xy": {
      if (!r) throw new Error("kernelX option is missing");
      if (!n) throw new Error("kernelY option is missing");
      const o = convolution.call(this, r, {
        channels: a,
        border: t,
        bitDepth: 32
      }), h = convolution.call(this, n, {
        channels: a,
        border: t,
        bitDepth: 32
      });
      return o.hypotenuse(h, { bitDepth: s, channels: a });
    }
    default:
      throw new Error(`Unknown parameter direction: ${i}`);
  }
}
function sobelFilter(e) {
  return gradientFilter.call(
    this,
    Object.assign({}, e, {
      kernelX: SOBEL_X,
      kernelY: SOBEL_Y
    })
  );
}
function scharrFilter(e) {
  return gradientFilter.call(
    this,
    Object.assign({}, e, {
      kernelX: SCHARR_X,
      kernelY: SCHARR_Y
    })
  );
}
var newArray_1, hasRequiredNewArray;
function requireNewArray() {
  if (hasRequiredNewArray) return newArray_1;
  hasRequiredNewArray = 1, newArray_1 = e;
  function e(i, t) {
    i = i || 0;
    for (var r = new Array(i), n = 0; n < i; n++)
      r[n] = t;
    return r;
  }
  return newArray_1;
}
var newArrayExports = requireNewArray();
const newArray = /* @__PURE__ */ getDefaultExportFromCjs(newArrayExports);
function level(e = {}) {
  let {
    algorithm: i = "range",
    channels: t,
    min: r = this.min,
    max: n = this.max
  } = e;
  switch (this.checkProcessable("level", {
    bitDepth: [8, 16, 32]
  }), t = validateArrayOfChannels(this, { channels: t }), t.length !== this.channel && (Array.isArray(r) && r.length === this.channels && (r = r.filter((a, s) => t.includes(s))), Array.isArray(n) && n.length === this.channels && (n = n.filter((a, s) => t.includes(s)))), i) {
    case "range":
      r < 0 && (r = 0), n > this.maxValue && (n = this.maxValue), Array.isArray(r) || (r = newArray(t.length, r)), Array.isArray(n) || (n = newArray(t.length, n)), processImage(this, r, n, t);
      break;
    default:
      throw new Error(`level: algorithm not implement: ${i}`);
  }
  return this;
}
function processImage(e, i, t, r) {
  let n = 1e-5, a = new Array(r.length);
  for (let s = 0; s < r.length; s++)
    i[s] === 0 && t[s] === e.maxValue || t[s] === i[s] ? a[s] = 0 : a[s] = (e.maxValue + 1 - n) / (t[s] - i[s]), i[s] += (0.5 - n / 2) / a[s];
  for (let s = 0; s < r.length; s++) {
    let o = r[s];
    if (a[s] !== 0)
      for (let h = 0; h < e.data.length; h += e.channels)
        e.data[h + o] = Math.min(
          Math.max(0, (e.data[h + o] - i[s]) * a[s] + 0.5 | 0),
          e.maxValue
        );
  }
}
var isArrayType, hasRequiredIsArrayType;
function requireIsArrayType() {
  if (hasRequiredIsArrayType) return isArrayType;
  hasRequiredIsArrayType = 1;
  var e = Object.prototype.toString;
  return isArrayType = function(t) {
    return e.call(t).substr(-6, 5) === "Array";
  }, isArrayType;
}
var isArrayTypeExports = requireIsArrayType();
const isArray = /* @__PURE__ */ getDefaultExportFromCjs(isArrayTypeExports);
function checkNumberArray(e) {
  if (isNaN(e)) {
    if (e instanceof Image)
      return e.data;
    if (!isArray(e))
      throw new Error(
        "checkNumberArray: the value should be either a number, array or Image"
      );
    return e;
  } else {
    if (e <= 0)
      throw new Error("checkNumberArray: the value must be greater than 0");
    return e;
  }
}
function add(e, i = {}) {
  let { channels: t } = i;
  if (this.checkProcessable("add", {
    bitDepth: [8, 16]
  }), t = validateArrayOfChannels(this, { channels: t }), e = checkNumberArray(e), isNaN(e)) {
    if (this.data.length !== e.length)
      throw new Error("add: the data size is different");
    for (let r = 0; r < t.length; r++) {
      let n = t[r];
      for (let a = 0; a < this.data.length; a += this.channels)
        this.data[a + n] = Math.max(
          0,
          Math.min(this.maxValue, this.data[a + n] + e[a + n] >> 0)
        );
    }
  } else
    for (let r = 0; r < t.length; r++) {
      let n = t[r];
      for (let a = 0; a < this.data.length; a += this.channels)
        this.data[a + n] = Math.min(
          this.maxValue,
          this.data[a + n] + e >> 0
        );
    }
  return this;
}
function subtract(e, i = {}) {
  let { channels: t } = i;
  if (this.checkProcessable("subtract", {
    bitDepth: [8, 16]
  }), t = validateArrayOfChannels(this, { channels: t }), e = checkNumberArray(e), isNaN(e)) {
    if (this.data.length !== e.length)
      throw new Error("subtract: the data size is different");
    for (let r = 0; r < t.length; r++) {
      let n = t[r];
      for (let a = 0; a < this.data.length; a += this.channels)
        this.data[a + n] = Math.max(
          0,
          Math.min(this.maxValue, this.data[a + n] - e[a + n] >> 0)
        );
    }
  } else
    for (let r = 0; r < t.length; r++) {
      let n = t[r];
      for (let a = 0; a < this.data.length; a += this.channels)
        this.data[a + n] = Math.max(0, this.data[a + n] - e >> 0);
    }
  return this;
}
function subtractImage(e, i = {}) {
  let { channels: t, absolute: r = !1 } = i;
  if (this.checkProcessable("subtractImage", {
    bitDepth: [8, 16]
  }), this.width !== e.width || this.height !== e.height)
    throw new Error("subtractImage: both images must have the same size");
  if (this.alpha !== e.alpha || this.bitDepth !== e.bitDepth)
    throw new Error(
      "subtractImage: both images must have the same alpha and bitDepth"
    );
  if (this.channels !== e.channels)
    throw new Error(
      "subtractImage: both images must have the same number of channels"
    );
  let n = this.clone();
  t = validateArrayOfChannels(this, { channels: t });
  for (let a = 0; a < t.length; a++) {
    let s = t[a];
    for (let o = s; o < this.data.length; o += this.channels) {
      let h = this.data[o] - e.data[o];
      r ? n.data[o] = Math.abs(h) : n.data[o] = Math.max(h, 0);
    }
  }
  return n;
}
function hypotenuse(e, i = {}) {
  let { bitDepth: t = this.bitDepth, channels: r } = i;
  if (this.checkProcessable("hypotenuse", {
    bitDepth: [8, 16, 32]
  }), this.width !== e.width || this.height !== e.height)
    throw new Error("hypotenuse: both images must have the same size");
  if (this.alpha !== e.alpha || this.bitDepth !== e.bitDepth)
    throw new Error(
      "hypotenuse: both images must have the same alpha and bitDepth"
    );
  if (this.channels !== e.channels)
    throw new Error(
      "hypotenuse: both images must have the same number of channels"
    );
  let n = Image.createFrom(this, { bitDepth: t });
  r = validateArrayOfChannels(this, { channels: r });
  let a = n.isClamped;
  for (let s = 0; s < r.length; s++) {
    let o = r[s];
    for (let h = o; h < this.data.length; h += this.channels) {
      let l = Math.hypot(this.data[h], e.data[h]);
      a ? n.data[h] = Math.min(
        Math.max(Math.round(l), 0),
        n.maxValue
      ) : n.data[h] = l;
    }
  }
  return n;
}
function multiply(e, i = {}) {
  let { channels: t } = i;
  if (this.checkProcessable("multiply", {
    bitDepth: [8, 16]
  }), e <= 0)
    throw new Error("multiply: the value must be greater than 0");
  if (t = validateArrayOfChannels(this, { channels: t }), e = checkNumberArray(e), isNaN(e)) {
    if (this.data.length !== e.length)
      throw new Error("multiply: the data size is different");
    for (let r = 0; r < t.length; r++) {
      let n = t[r];
      for (let a = 0; a < this.data.length; a += this.channels)
        this.data[a + n] = Math.max(
          0,
          Math.min(this.maxValue, this.data[a + n] * e[a + n] >> 0)
        );
    }
  } else
    for (let r = 0; r < t.length; r++) {
      let n = t[r];
      for (let a = 0; a < this.data.length; a += this.channels)
        this.data[a + n] = Math.min(
          this.maxValue,
          this.data[a + n] * e >> 0
        );
    }
  return this;
}
function divide(e, i = {}) {
  let { channels: t } = i;
  if (this.checkProcessable("divide", {
    bitDepth: [8, 16]
  }), t = validateArrayOfChannels(this, { channels: t }), e = checkNumberArray(e), isNaN(e)) {
    if (this.data.length !== e.length)
      throw new Error("divide: the: the data size is different");
    for (let r = 0; r < t.length; r++) {
      let n = t[r];
      for (let a = 0; a < this.data.length; a += this.channels)
        this.data[a + n] = Math.max(
          0,
          Math.min(this.maxValue, this.data[a + n] / e[a + n] >> 0)
        );
    }
  } else
    for (let r = 0; r < t.length; r++) {
      let n = t[r];
      for (let a = 0; a < this.data.length; a += this.channels)
        this.data[a + n] = Math.min(
          this.maxValue,
          this.data[a + n] / e >> 0
        );
    }
  return this;
}
class BaseRegression {
  constructor() {
    if (new.target === BaseRegression)
      throw new Error("BaseRegression must be subclassed");
  }
  predict(i) {
    if (typeof i == "number")
      return this._predict(i);
    if (isAnyArray(i)) {
      const t = [];
      for (let r = 0; r < i.length; r++)
        t.push(this._predict(i[r]));
      return t;
    } else
      throw new TypeError("x must be a number or array");
  }
  _predict() {
    throw new Error("_predict must be implemented");
  }
  train() {
  }
  toString() {
    return "";
  }
  toLaTeX() {
    return "";
  }
  /**
   * Return the correlation coefficient of determination (r) and chi-square.
   * @param {Array<number>} x
   * @param {Array<number>} y
   * @return {object}
   */
  score(i, t) {
    if (!isAnyArray(i) || !isAnyArray(t) || i.length !== t.length)
      throw new Error("x and y must be arrays of the same length");
    const r = i.length, n = new Array(r);
    for (let g = 0; g < r; g++)
      n[g] = this._predict(i[g]);
    let a = 0, s = 0, o = 0, h = 0, l = 0, f = 0, b = 0;
    for (let g = 0; g < r; g++)
      a += n[g], s += t[g], l += n[g] * n[g], f += t[g] * t[g], b += n[g] * t[g], t[g] !== 0 && (o += (t[g] - n[g]) * (t[g] - n[g]) / t[g]), h += (t[g] - n[g]) * (t[g] - n[g]);
    const w = (r * b - a * s) / Math.sqrt((r * l - a * a) * (r * f - s * s));
    return {
      r: w,
      r2: w * w,
      chi2: o,
      rmsd: Math.sqrt(h / r)
    };
  }
}
function squaredEuclidean(e, i) {
  let t = 0;
  for (let r = 0; r < e.length; r++)
    t += (e[r] - i[r]) * (e[r] - i[r]);
  return t;
}
function euclidean(e, i) {
  return Math.sqrt(squaredEuclidean(e, i));
}
const euclidean$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  euclidean,
  squaredEuclidean
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(euclidean$1);
var gaussianKernel, hasRequiredGaussianKernel;
function requireGaussianKernel() {
  if (hasRequiredGaussianKernel) return gaussianKernel;
  hasRequiredGaussianKernel = 1;
  const { squaredEuclidean: e } = require$$0, i = {
    sigma: 1
  };
  class t {
    constructor(n) {
      n = Object.assign({}, i, n), this.sigma = n.sigma, this.divisor = 2 * n.sigma * n.sigma;
    }
    compute(n, a) {
      const s = e(n, a);
      return Math.exp(-s / this.divisor);
    }
  }
  return gaussianKernel = t, gaussianKernel;
}
var polynomialKernel, hasRequiredPolynomialKernel;
function requirePolynomialKernel() {
  if (hasRequiredPolynomialKernel) return polynomialKernel;
  hasRequiredPolynomialKernel = 1;
  const e = {
    degree: 1,
    constant: 1,
    scale: 1
  };
  class i {
    constructor(r) {
      r = Object.assign({}, e, r), this.degree = r.degree, this.constant = r.constant, this.scale = r.scale;
    }
    compute(r, n) {
      for (var a = 0, s = 0; s < r.length; s++)
        a += r[s] * n[s];
      return Math.pow(this.scale * a + this.constant, this.degree);
    }
  }
  return polynomialKernel = i, polynomialKernel;
}
var sigmoidKernel, hasRequiredSigmoidKernel;
function requireSigmoidKernel() {
  if (hasRequiredSigmoidKernel) return sigmoidKernel;
  hasRequiredSigmoidKernel = 1;
  const e = {
    alpha: 0.01,
    constant: -Math.E
  };
  class i {
    constructor(r) {
      r = Object.assign({}, e, r), this.alpha = r.alpha, this.constant = r.constant;
    }
    compute(r, n) {
      for (var a = 0, s = 0; s < r.length; s++)
        a += r[s] * n[s];
      return Math.tanh(this.alpha * a + this.constant);
    }
  }
  return sigmoidKernel = i, sigmoidKernel;
}
var anovaKernel, hasRequiredAnovaKernel;
function requireAnovaKernel() {
  if (hasRequiredAnovaKernel) return anovaKernel;
  hasRequiredAnovaKernel = 1;
  const e = {
    sigma: 1,
    degree: 1
  };
  class i {
    constructor(r) {
      r = Object.assign({}, e, r), this.sigma = r.sigma, this.degree = r.degree;
    }
    compute(r, n) {
      for (var a = 0, s = Math.min(r.length, n.length), o = 1; o <= s; ++o)
        a += Math.pow(
          Math.exp(
            -this.sigma * Math.pow(Math.pow(r[o - 1], o) - Math.pow(n[o - 1], o), 2)
          ),
          this.degree
        );
      return a;
    }
  }
  return anovaKernel = i, anovaKernel;
}
var cauchyKernel, hasRequiredCauchyKernel;
function requireCauchyKernel() {
  if (hasRequiredCauchyKernel) return cauchyKernel;
  hasRequiredCauchyKernel = 1;
  const { squaredEuclidean: e } = require$$0, i = {
    sigma: 1
  };
  class t {
    constructor(n) {
      n = Object.assign({}, i, n), this.sigma = n.sigma;
    }
    compute(n, a) {
      return 1 / (1 + e(n, a) / (this.sigma * this.sigma));
    }
  }
  return cauchyKernel = t, cauchyKernel;
}
var exponentialKernel, hasRequiredExponentialKernel;
function requireExponentialKernel() {
  if (hasRequiredExponentialKernel) return exponentialKernel;
  hasRequiredExponentialKernel = 1;
  const { euclidean: e } = require$$0, i = {
    sigma: 1
  };
  class t {
    constructor(n) {
      n = Object.assign({}, i, n), this.sigma = n.sigma, this.divisor = 2 * n.sigma * n.sigma;
    }
    compute(n, a) {
      const s = e(n, a);
      return Math.exp(-s / this.divisor);
    }
  }
  return exponentialKernel = t, exponentialKernel;
}
var histogramIntersectionKernel, hasRequiredHistogramIntersectionKernel;
function requireHistogramIntersectionKernel() {
  if (hasRequiredHistogramIntersectionKernel) return histogramIntersectionKernel;
  hasRequiredHistogramIntersectionKernel = 1;
  class e {
    compute(t, r) {
      for (var n = Math.min(t.length, r.length), a = 0, s = 0; s < n; ++s)
        a += Math.min(t[s], r[s]);
      return a;
    }
  }
  return histogramIntersectionKernel = e, histogramIntersectionKernel;
}
var laplacianKernel, hasRequiredLaplacianKernel;
function requireLaplacianKernel() {
  if (hasRequiredLaplacianKernel) return laplacianKernel;
  hasRequiredLaplacianKernel = 1;
  const { euclidean: e } = require$$0, i = {
    sigma: 1
  };
  class t {
    constructor(n) {
      n = Object.assign({}, i, n), this.sigma = n.sigma;
    }
    compute(n, a) {
      const s = e(n, a);
      return Math.exp(-s / this.sigma);
    }
  }
  return laplacianKernel = t, laplacianKernel;
}
var multiquadraticKernel, hasRequiredMultiquadraticKernel;
function requireMultiquadraticKernel() {
  if (hasRequiredMultiquadraticKernel) return multiquadraticKernel;
  hasRequiredMultiquadraticKernel = 1;
  const { squaredEuclidean: e } = require$$0, i = {
    constant: 1
  };
  class t {
    constructor(n) {
      n = Object.assign({}, i, n), this.constant = n.constant;
    }
    compute(n, a) {
      return Math.sqrt(e(n, a) + this.constant * this.constant);
    }
  }
  return multiquadraticKernel = t, multiquadraticKernel;
}
var rationalQuadraticKernel, hasRequiredRationalQuadraticKernel;
function requireRationalQuadraticKernel() {
  if (hasRequiredRationalQuadraticKernel) return rationalQuadraticKernel;
  hasRequiredRationalQuadraticKernel = 1;
  const { squaredEuclidean: e } = require$$0, i = {
    constant: 1
  };
  class t {
    constructor(n) {
      n = Object.assign({}, i, n), this.constant = n.constant;
    }
    compute(n, a) {
      const s = e(n, a);
      return 1 - s / (s + this.constant);
    }
  }
  return rationalQuadraticKernel = t, rationalQuadraticKernel;
}
var kernel, hasRequiredKernel;
function requireKernel() {
  if (hasRequiredKernel) return kernel;
  hasRequiredKernel = 1;
  const { Matrix: e, MatrixTransposeView: i } = /* @__PURE__ */ requireMatrix(), t = requireGaussianKernel(), r = requirePolynomialKernel(), n = requireSigmoidKernel(), a = requireAnovaKernel(), s = requireCauchyKernel(), o = requireExponentialKernel(), h = requireHistogramIntersectionKernel(), l = requireLaplacianKernel(), f = requireMultiquadraticKernel(), b = requireRationalQuadraticKernel(), w = {
    gaussian: t,
    rbf: t,
    polynomial: r,
    poly: r,
    anova: a,
    cauchy: s,
    exponential: o,
    histogram: h,
    min: h,
    laplacian: l,
    multiquadratic: f,
    rational: b,
    sigmoid: n,
    mlp: n
  };
  class g {
    constructor(k, A) {
      if (this.kernelType = k, k !== "linear")
        if (typeof k == "string") {
          k = k.toLowerCase();
          var T = w[k];
          if (T)
            this.kernelFunction = new T(A);
          else
            throw new Error(`unsupported kernel type: ${k}`);
        } else if (typeof k == "object" && typeof k.compute == "function")
          this.kernelFunction = k;
        else
          throw new TypeError(
            "first argument must be a valid kernel type or instance"
          );
    }
    compute(k, A) {
      if (k = e.checkMatrix(k), A === void 0 ? A = k : A = e.checkMatrix(A), this.kernelType === "linear")
        return k.mmul(new i(A));
      const T = new e(k.rows, A.rows);
      if (k === A)
        for (let C = 0; C < k.rows; C++)
          for (let D = C; D < k.rows; D++) {
            const $ = this.kernelFunction.compute(
              k.getRow(C),
              k.getRow(D)
            );
            T.set(C, D, $), T.set(D, C, $);
          }
      else
        for (let C = 0; C < k.rows; C++)
          for (let D = 0; D < A.rows; D++)
            T.set(
              C,
              D,
              this.kernelFunction.compute(k.getRow(C), A.getRow(D))
            );
      return T;
    }
  }
  return kernel = g, kernel;
}
var kernelExports = requireKernel();
const Kernel = /* @__PURE__ */ getDefaultExportFromCjs(kernelExports), defaultOptions$2 = {
  lambda: 0.1,
  kernelType: "gaussian",
  kernelOptions: {},
  computeCoefficient: !1
};
class KernelRidgeRegression extends BaseRegression {
  constructor(i, t, r) {
    if (super(), i === !0)
      this.alpha = t.alpha, this.inputs = t.inputs, this.kernelType = t.kernelType, this.kernelOptions = t.kernelOptions, this.kernel = new Kernel(t.kernelType, t.kernelOptions);
    else {
      i = Matrix$1.checkMatrix(i), r = Object.assign({}, defaultOptions$2, r);
      const n = new Kernel(
        r.kernelType,
        r.kernelOptions
      ), a = n.compute(i), s = i.rows;
      a.add(Matrix$1.eye(s, s).mul(r.lambda)), this.alpha = solve(a, t), this.inputs = i, this.kernelType = r.kernelType, this.kernelOptions = r.kernelOptions, this.kernel = n;
    }
  }
  _predict(i) {
    return this.kernel.compute([i], this.inputs).mmul(this.alpha).getRow(0);
  }
  toJSON() {
    return {
      name: "kernelRidgeRegression",
      alpha: this.alpha,
      inputs: this.inputs,
      kernelType: this.kernelType,
      kernelOptions: this.kernelOptions
    };
  }
  static load(i) {
    if (i.name !== "kernelRidgeRegression")
      throw new TypeError("not a KRR model");
    return new KernelRidgeRegression(!0, i);
  }
}
function background$1(e, i, t) {
  const r = new KernelRidgeRegression(e, i, t), n = new Array(this.size);
  for (let o = 0; o < this.width; o++)
    for (let h = 0; h < this.height; h++)
      n[h * this.width + o] = [o, h];
  const a = r.predict(n), s = Image.createFrom(this);
  for (let o = 0; o < this.size; o++)
    s.data[o] = Math.min(this.maxValue, Math.max(0, a[o][0]));
  return s;
}
function dilate(e = {}) {
  let {
    kernel: i = [
      [1, 1, 1],
      [1, 1, 1],
      [1, 1, 1]
    ],
    iterations: t = 1
  } = e;
  if (this.checkProcessable("dilate", {
    bitDepth: [1, 8, 16],
    components: 1,
    alpha: 0
  }), i.columns % 2 === 0 || i.rows % 2 === 0)
    throw new TypeError(
      "dilate: The number of rows and columns of the kernel must be odd"
    );
  let r = !0;
  e: for (const a of i)
    for (const s of a)
      if (s !== 1) {
        r = !1;
        break e;
      }
  let n = this;
  for (let a = 0; a < t; a++)
    if (this.bitDepth === 1)
      if (r) {
        const s = n.clone();
        n = dilateOnceBinaryOnlyOnes(
          n,
          s,
          i.length,
          i[0].length
        );
      } else {
        const s = Image.createFrom(n);
        n = dilateOnceBinary(n, s, i);
      }
    else if (r) {
      const s = Image.createFrom(n);
      n = dilateOnceGreyOnlyOnes(
        n,
        s,
        i.length,
        i[0].length
      );
    } else {
      const s = Image.createFrom(n);
      n = dilateOnceGrey(n, s, i);
    }
  return n;
}
function dilateOnceGrey(e, i, t) {
  const r = t.length, n = t[0].length;
  let a = (r - 1) / 2, s = (n - 1) / 2;
  for (let o = 0; o < e.height; o++)
    for (let h = 0; h < e.width; h++) {
      let l = 0;
      for (let f = 0; f < n; f++)
        for (let b = 0; b < r; b++) {
          if (t[b][f] !== 1) continue;
          let w = b - a + h, g = f - s + o;
          if (w < 0 || g < 0 || w >= e.width || g >= e.height) continue;
          const E = e.getValueXY(w, g, 0);
          E > l && (l = E);
        }
      i.setValueXY(h, o, 0, l);
    }
  return i;
}
function dilateOnceGreyOnlyOnes(e, i, t, r) {
  const n = (t - 1) / 2, a = (r - 1) / 2, s = [];
  for (let o = 0; o < e.width; o++)
    s.push(0);
  for (let o = 0; o < e.height; o++) {
    for (let h = 0; h < e.width; h++) {
      let l = 0;
      for (let f = Math.max(0, o - a); f < Math.min(e.height, o + a + 1); f++) {
        const b = e.getValueXY(h, f, 0);
        b > l && (l = b);
      }
      s[h] = l;
    }
    for (let h = 0; h < e.width; h++) {
      let l = 0;
      for (let f = Math.max(0, h - n); f < Math.min(e.width, h + n + 1); f++)
        s[f] > l && (l = s[f]);
      i.setValueXY(h, o, 0, l);
    }
  }
  return i;
}
function dilateOnceBinary(e, i, t) {
  const r = t.length, n = t[0].length;
  let a = (r - 1) / 2, s = (n - 1) / 2;
  for (let o = 0; o < e.height; o++)
    for (let h = 0; h < e.width; h++) {
      let l = 0;
      e: for (let f = 0; f < n; f++)
        for (let b = 0; b < r; b++) {
          if (t[b][f] !== 1) continue;
          let w = b - a + h, g = f - s + o;
          if (g < 0 || w < 0 || w >= e.width || g >= e.height) continue;
          if (e.getBitXY(w, g) === 1) {
            l = 1;
            break e;
          }
        }
      l === 1 && i.setBitXY(h, o);
    }
  return i;
}
function dilateOnceBinaryOnlyOnes(e, i, t, r) {
  const n = (t - 1) / 2, a = (r - 1) / 2, s = [];
  for (let o = 0; o < e.width; o++)
    s.push(1);
  for (let o = 0; o < e.height; o++) {
    for (let h = 0; h < e.width; h++) {
      s[h] = 0;
      for (let l = Math.max(0, o - a); l < Math.min(e.height, o + a + 1); l++)
        if (e.getBitXY(h, l) === 1) {
          s[h] = 1;
          break;
        }
    }
    for (let h = 0; h < e.width; h++)
      if (i.getBitXY(h, o) !== 1) {
        for (let l = Math.max(0, h - n); l < Math.min(e.width, h + n + 1); l++)
          if (s[l] === 1) {
            i.setBitXY(h, o);
            break;
          }
      }
  }
  return i;
}
function erode(e = {}) {
  let {
    kernel: i = [
      [1, 1, 1],
      [1, 1, 1],
      [1, 1, 1]
    ],
    iterations: t = 1
  } = e;
  if (this.checkProcessable("erode", {
    bitDepth: [1, 8, 16],
    components: 1,
    alpha: 0
  }), i.columns % 2 === 0 || i.rows % 2 === 0)
    throw new TypeError(
      "erode: The number of rows and columns of the kernel must be odd"
    );
  let r = !0;
  e: for (const a of i)
    for (const s of a)
      if (s !== 1) {
        r = !1;
        break e;
      }
  let n = this;
  for (let a = 0; a < t; a++)
    if (this.bitDepth === 1)
      if (r) {
        const s = n.clone();
        n = erodeOnceBinaryOnlyOnes(
          n,
          s,
          i.length,
          i[0].length
        );
      } else {
        const s = Image.createFrom(n);
        n = erodeOnceBinary(n, s, i);
      }
    else if (r) {
      const s = Image.createFrom(n);
      n = erodeOnceGreyOnlyOnes(
        n,
        s,
        i.length,
        i[0].length
      );
    } else {
      const s = Image.createFrom(n);
      n = erodeOnceGrey(n, s, i);
    }
  return n;
}
function erodeOnceGrey(e, i, t) {
  const r = t.length, n = t[0].length;
  let a = (r - 1) / 2, s = (n - 1) / 2;
  for (let o = 0; o < e.height; o++)
    for (let h = 0; h < e.width; h++) {
      let l = e.maxValue;
      for (let f = 0; f < n; f++)
        for (let b = 0; b < r; b++) {
          if (t[b][f] !== 1) continue;
          let w = b - a + h, g = f - s + o;
          if (w < 0 || g < 0 || w >= e.width || g >= e.height) continue;
          const E = e.getValueXY(w, g, 0);
          E < l && (l = E);
        }
      i.setValueXY(h, o, 0, l);
    }
  return i;
}
function erodeOnceGreyOnlyOnes(e, i, t, r) {
  const n = (t - 1) / 2, a = (r - 1) / 2, s = [];
  for (let o = 0; o < e.width; o++)
    s.push(0);
  for (let o = 0; o < e.height; o++) {
    for (let h = 0; h < e.width; h++) {
      let l = e.maxValue;
      for (let f = Math.max(0, o - a); f < Math.min(e.height, o + a + 1); f++) {
        const b = e.getValueXY(h, f, 0);
        b < l && (l = b);
      }
      s[h] = l;
    }
    for (let h = 0; h < e.width; h++) {
      let l = e.maxValue;
      for (let f = Math.max(0, h - n); f < Math.min(e.width, h + n + 1); f++)
        s[f] < l && (l = s[f]);
      i.setValueXY(h, o, 0, l);
    }
  }
  return i;
}
function erodeOnceBinary(e, i, t) {
  const r = t.length, n = t[0].length;
  let a = (r - 1) / 2, s = (n - 1) / 2;
  for (let o = 0; o < e.height; o++)
    for (let h = 0; h < e.width; h++) {
      let l = 1;
      e: for (let f = 0; f < n; f++)
        for (let b = 0; b < r; b++) {
          if (t[b][f] !== 1) continue;
          let w = b - a + h, g = f - s + o;
          if (g < 0 || w < 0 || w >= e.width || g >= e.height) continue;
          if (e.getBitXY(w, g) === 0) {
            l = 0;
            break e;
          }
        }
      l === 1 && i.setBitXY(h, o);
    }
  return i;
}
function erodeOnceBinaryOnlyOnes(e, i, t, r) {
  const n = (t - 1) / 2, a = (r - 1) / 2, s = [];
  for (let o = 0; o < e.width; o++)
    s.push(0);
  for (let o = 0; o < e.height; o++) {
    for (let h = 0; h < e.width; h++) {
      s[h] = 1;
      for (let l = Math.max(0, o - a); l < Math.min(e.height, o + a + 1); l++)
        if (e.getBitXY(h, l) === 0) {
          s[h] = 0;
          break;
        }
    }
    for (let h = 0; h < e.width; h++)
      if (i.getBitXY(h, o) !== 0) {
        for (let l = Math.max(0, h - n); l < Math.min(e.width, h + n + 1); l++)
          if (s[l] === 0) {
            i.clearBitXY(h, o);
            break;
          }
      }
  }
  return i;
}
function open(e = {}) {
  let {
    kernel: i = [
      [1, 1, 1],
      [1, 1, 1],
      [1, 1, 1]
    ],
    iterations: t = 1
  } = e;
  if (this.checkProcessable("open", {
    bitDepth: [8, 16],
    components: 1,
    alpha: 0
  }), i.columns % 2 === 0 || i.rows % 2 === 0)
    throw new TypeError(
      "open: The number of rows and columns of the kernel must be odd"
    );
  let r = this;
  for (let n = 0; n < t; n++)
    r = r.erode({ kernel: i }), r = r.dilate({ kernel: i });
  return r;
}
function close(e = {}) {
  let {
    kernel: i = [
      [1, 1, 1],
      [1, 1, 1],
      [1, 1, 1]
    ],
    iterations: t = 1
  } = e;
  if (this.checkProcessable("close", {
    bitDepth: [1, 8, 16],
    components: 1,
    alpha: 0
  }), i.columns % 2 === 0 || i.rows % 2 === 0)
    throw new TypeError(
      "close: The number of rows and columns of the kernel must be odd"
    );
  let r = this;
  for (let n = 0; n < t; n++)
    r = r.dilate({ kernel: i }).erode({ kernel: i });
  return r;
}
function topHat(e = {}) {
  let {
    kernel: i = [
      [1, 1, 1],
      [1, 1, 1],
      [1, 1, 1]
    ],
    iterations: t = 1
  } = e;
  if (this.checkProcessable("topHat", {
    bitDepth: [8, 16],
    components: 1,
    alpha: 0
  }), i.length % 2 === 0 || i[0].length % 2 === 0)
    throw new TypeError(
      "topHat: The number of rows and columns of the kernel must be odd"
    );
  let r = this;
  for (let n = 0; n < t; n++)
    r = r.open({ kernel: i }).subtractImage(r, { absolute: !0 });
  return r;
}
function blackHat(e = {}) {
  let {
    kernel: i = [
      [1, 1, 1],
      [1, 1, 1],
      [1, 1, 1]
    ],
    iterations: t = 1
  } = e;
  if (this.checkProcessable("blackHat", {
    bitDepth: [8, 16],
    components: 1,
    alpha: 0
  }), i.columns % 2 === 0 || i.rows % 2 === 0)
    throw new TypeError(
      "blackHat: The number of rows and columns of the kernel must be odd"
    );
  let r = this;
  for (let n = 0; n < t; n++)
    r = r.close({ kernel: i }).subtractImage(r, { absolute: !0 });
  return r;
}
function morphologicalGradient(e = {}) {
  let {
    kernel: i = [
      [1, 1, 1],
      [1, 1, 1],
      [1, 1, 1]
    ],
    iterations: t = 1
  } = e;
  if (this.checkProcessable("morphologicalGradient", {
    bitDepth: [8, 16],
    components: 1,
    alpha: 0
  }), i.columns % 2 === 0 || i.rows % 2 === 0)
    throw new TypeError(
      "morphologicalGradient: The number of rows and columns of the kernel must be odd"
    );
  let r = this;
  for (let n = 0; n < t; n++) {
    let a = r.dilate({ kernel: i }), s = r.erode({ kernel: i });
    r = a.subtractImage(s, { absolute: !0 });
  }
  return r;
}
function order4Points(e) {
  let i = 0, t = 0, r = 0, n = 0, a = e[0][0], s = 0;
  for (let l = 1; l < e.length; l++)
    e[l][0] < a && (a = e[l][0], s = l);
  let o = e[(s + 1) % e.length][0], h = (s + 1) % e.length;
  for (let l = 1; l < e.length; l++)
    e[l][0] < o && l !== s && (o = e[l][0], h = l);
  return e[h][1] < e[s][1] ? (i = e[h], n = e[s], s !== (h + 1) % 4 ? (t = e[(h + 1) % 4], r = e[(h + 2) % 4]) : (t = e[(h + 2) % 4], r = e[(h + 3) % 4])) : (n = e[h], i = e[s], h !== (s + 1) % 4 ? (t = e[(s + 1) % 4], r = e[(s + 2) % 4]) : (t = e[(s + 2) % 4], r = e[(s + 3) % 4])), [i, t, r, n];
}
function distance2Points(e, i) {
  return Math.sqrt(Math.pow(e[0] - i[0], 2) + Math.pow(e[1] - i[1], 2));
}
function crossVect(e, i) {
  return [
    e[1] * i[2] - e[2] * i[1],
    e[2] * i[0] - e[0] * i[2],
    e[0] * i[1] - e[1] * i[0]
  ];
}
function dotVect(e, i) {
  return e[0] * i[0] + e[1] * i[1] + e[2] * i[2];
}
function computeWidthAndHeigth(e, i, t, r, n, a) {
  let s = Math.max(distance2Points(e, i), distance2Points(r, t)), o = Math.max(distance2Points(e, r), distance2Points(i, t)), h = 0, l = 0, f = Math.ceil(n / 2), b = Math.ceil(a / 2), w = s / o, g = [e[0], e[1], 1], E = [i[0], i[1], 1], k = [r[0], r[1], 1], A = [t[0], t[1], 1], T = dotVect(crossVect(g, A), k) / dotVect(crossVect(E, A), k), C = dotVect(crossVect(g, A), E) / dotVect(crossVect(k, A), E), D = [T * E[0] - g[0], T * E[1] - g[1], T * E[2] - g[2]], $ = [C * k[0] - g[0], C * k[1] - g[1], C * k[2] - g[2]], P = D[0], z = D[1], B = D[2], F = $[0], O = $[1], N = $[2], G = 1 / (B * N) * (P * F - (P * N + B * F) * f + B * N * f * f + (z * O - (z * N + B * O) * b + B * N * b * b));
  G >= 0 ? G = Math.sqrt(G) : G = Math.sqrt(-G);
  let V = new Matrix$1([
    [G, 0, f],
    [0, G, b],
    [0, 0, 1]
  ]), J = V.transpose(), Q = inverse(J), W = inverse(V), ne = Matrix$1.rowVector(D), pe = Matrix$1.rowVector($), be = Math.sqrt(
    dotVect(ne.mmul(Q).mmul(W).to1DArray(), D) / dotVect(pe.mmul(Q).mmul(W).to1DArray(), $)
  );
  return be === 0 || w === 0 ? (h = Math.ceil(s), l = Math.ceil(o)) : be < w ? (h = Math.ceil(s), l = Math.ceil(h / be)) : (l = Math.ceil(o), h = Math.ceil(be * l)), [h, l];
}
function projectionPoint(e, i, t, r, n, a, s, o, h, l, f, b) {
  let [w, g] = [
    (t * e + r * i + n) / (h * e + l * i + 1),
    (a * e + s * i + o) / (h * e + l * i + 1)
  ];
  return f.getValueXY(Math.floor(w), Math.floor(g), b);
}
function warpingFourPoints(e, i = {}) {
  let { calculateRatio: t = !0 } = i;
  if (e.length !== 4)
    throw new Error(
      `The array pts must have four elements, which are the four corners. Currently, pts have ${e.length} elements`
    );
  let [r, n, a, s] = e, o = [r, n, a, s], [h, l, f, b] = order4Points(o), w, g;
  t ? [w, g] = computeWidthAndHeigth(
    h,
    l,
    f,
    b,
    this.width,
    this.height
  ) : (w = Math.ceil(
    Math.max(distance2Points(h, l), distance2Points(b, f))
  ), g = Math.ceil(
    Math.max(distance2Points(h, b), distance2Points(l, f))
  ));
  let E = Image.createFrom(this, {
    width: w,
    height: g
  }), [k, A] = h, [T, C] = l, [D, $] = f, [P, z] = b, [B, F] = [0, 0], [O, N] = [0, w - 1], [G, V] = [g - 1, w - 1], [J, Q] = [g - 1, 0], W = new Matrix$1([
    [B, F, 1, 0, 0, 0, -B * k, -F * k],
    [O, N, 1, 0, 0, 0, -O * T, -N * T],
    [G, V, 1, 0, 0, 0, -G * D, -F * D],
    [J, Q, 1, 0, 0, 0, -J * P, -Q * P],
    [0, 0, 0, B, F, 1, -B * A, -F * A],
    [0, 0, 0, O, N, 1, -O * C, -N * C],
    [0, 0, 0, G, V, 1, -G * $, -V * $],
    [0, 0, 0, J, Q, 1, -J * z, -Q * z]
  ]), ne = Matrix$1.columnVector([k, T, D, P, A, C, $, z]), be = new SingularValueDecomposition(W).solve(ne), [ve, Ee, Ae, _e, Be, Me, re, Te] = be.to1DArray(), Fe = new Matrix$1(g, w);
  for (let Se = 0; Se < this.channels; Se++) {
    for (let Ye = 0; Ye < g; Ye++)
      for (let Je = 0; Je < w; Je++)
        Fe.set(
          Ye,
          Je,
          projectionPoint(Ye, Je, ve, Ee, Ae, _e, Be, Me, re, Te, this, Se)
        );
    E.setMatrix(Fe, { channel: Se });
  }
  return E;
}
function crop(e = {}) {
  let {
    x: i = 0,
    y: t = 0,
    width: r = this.width - i,
    height: n = this.height - t
  } = e;
  if (this.checkProcessable("crop", {
    bitDepth: [1, 8, 16]
  }), i = Math.round(i), t = Math.round(t), r = Math.round(r), n = Math.round(n), i > this.width - 1 || t > this.height - 1)
    throw new RangeError(
      `crop: origin (x:${i}, y:${t}) out of range (${this.width - 1}; ${this.height - 1})`
    );
  if (r <= 0 || n <= 0)
    throw new RangeError(
      `crop: width and height (width:${r}; height:${n}) must be positive numbers`
    );
  if (i < 0 || t < 0)
    throw new RangeError(
      `crop: x and y (x:${i}, y:${t}) must be positive numbers`
    );
  if (r > this.width - i || n > this.height - t)
    throw new RangeError(
      `crop: (x: ${i}, y:${t}, width:${r}, height:${n}) size is out of range`
    );
  let a = this;
  if (this.bitDepth === 1) {
    const s = new Image(r, n, {
      kind: "BINARY",
      parent: this
    });
    a = cropBinary(this, s, i, t, r, n);
  } else {
    const s = Image.createFrom(this, {
      width: r,
      height: n,
      position: [i, t]
    });
    a = cropDefault(this, s, i, t, r, n);
  }
  return a;
}
function cropDefault(e, i, t, r, n, a) {
  let s = n * e.channels, o = r + a, h = 0, l = t * e.channels;
  for (let f = r; f < o; f++) {
    let b = f * e.width * e.channels + l, w = b + s;
    for (; b < w; b++)
      i.data[h++] = e.data[b];
  }
  return i;
}
function cropBinary(e, i, t, r, n, a) {
  let s = n * e.channels, o = r + a, h = 0, l = t * e.channels;
  for (let f = r; f < o; f++) {
    let b = f * e.width * e.channels + l, w = b + s;
    for (; b < w; b++)
      e.getBit(b) && i.setBit(h), ++h;
  }
  return i;
}
function cropAlpha(e = {}) {
  this.checkProcessable("cropAlpha", {
    alpha: 1
  });
  const { threshold: i = this.maxValue } = e;
  let t = findLeft(this, i, this.components);
  if (t === -1)
    throw new Error(
      "Could not find new dimensions. Threshold may be too high."
    );
  let r = findTop(this, i, this.components, t), n = findBottom(this, i, this.components, t), a = findRight(this, i, this.components, t, r, n);
  return this.crop({
    x: t,
    y: r,
    width: a - t + 1,
    height: n - r + 1
  });
}
function findLeft(e, i, t) {
  for (let r = 0; r < e.width; r++)
    for (let n = 0; n < e.height; n++)
      if (e.getValueXY(r, n, t) >= i)
        return r;
  return -1;
}
function findTop(e, i, t, r) {
  for (let n = 0; n < e.height; n++)
    for (let a = r; a < e.width; a++)
      if (e.getValueXY(a, n, t) >= i)
        return n;
  return -1;
}
function findBottom(e, i, t, r) {
  for (let n = e.height - 1; n >= 0; n--)
    for (let a = r; a < e.width; a++)
      if (e.getValueXY(a, n, t) >= i)
        return n;
  return -1;
}
function findRight(e, i, t, r, n, a) {
  for (let s = e.width - 1; s >= r; s--)
    for (let o = n; o <= a; o++)
      if (e.getValueXY(s, o, t) >= i)
        return s;
  return -1;
}
function getFactor(e) {
  if (typeof e == "string") {
    const i = e[e.length - 1];
    e = parseFloat(e), i === "%" && (e /= 100);
  }
  return e;
}
function getThreshold$1(e, i) {
  if (!i)
    throw Error("getThreshold : the maxValue should be specified");
  if (typeof e == "string") {
    if (e[e.length - 1] !== "%")
      throw Error(
        "getThreshold : if the value is a string it must finish by %"
      );
    return parseFloat(e) / 100 * i;
  } else {
    if (typeof e == "number")
      return e < 1 ? e * i : e;
    throw Error("getThreshold : the value is not valid");
  }
}
function factorDimensions(e, i, t) {
  e = getFactor(e);
  let r = Math.round(e * i), n = Math.round(e * t);
  return r <= 0 && (r = 1), n <= 0 && (n = 1), {
    width: r,
    height: n
  };
}
function checkRow(e, i) {
  if (i < 0 || i >= e.height)
    throw new RangeError(
      `row must be included between 0 and ${e.height - 1}. Current value: ${i}`
    );
}
function checkColumn(e, i) {
  if (i < 0 || i >= e.width)
    throw new RangeError(
      `column must be included between 0 and ${e.width - 1}. Current value: ${i}`
    );
}
function checkChannel(e, i) {
  if (i < 0 || i >= e.channels)
    throw new RangeError(
      `channel must be included between 0 and ${e.channels - 1}. Current value: ${i}`
    );
}
const validInterpolations = {
  nearestneighbor: "nearestNeighbor",
  nearestneighbour: "nearestNeighbor",
  bilinear: "bilinear"
};
function checkInterpolation(e) {
  if (typeof e != "string")
    throw new TypeError("interpolation must be a string");
  if (e = e.toLowerCase(), !validInterpolations[e])
    throw new RangeError(`invalid interpolation algorithm: ${e}`);
  return validInterpolations[e];
}
function nearestNeighbor(e, i, t) {
  const r = this.width / i, n = this.height / t;
  if (this.bitDepth > 1)
    for (let a = 0; a < i; a++) {
      const s = Math.floor((a + 0.5) * r);
      for (let o = 0; o < t; o++) {
        const h = Math.floor((o + 0.5) * n);
        for (let l = 0; l < this.channels; l++)
          e.setValueXY(a, o, l, this.getValueXY(s, h, l));
      }
    }
  else
    for (let a = 0; a < i; a++) {
      const s = Math.floor((a + 0.5) * r);
      for (let o = 0; o < t; o++) {
        const h = Math.floor((o + 0.5) * n);
        this.getBitXY(s, h) && e.setBitXY(a, o);
      }
    }
}
function resize(e = {}) {
  const {
    factor: i = 1,
    interpolation: t = validInterpolations.nearestneighbor,
    preserveAspectRatio: r = !0
  } = e, n = checkInterpolation(t);
  let a = e.width, s = e.height;
  if (a || (s && r ? a = Math.round(s * (this.width / this.height)) : a = this.width), s || (r ? s = Math.round(a * (this.height / this.width)) : s = this.height), { width: a, height: s } = factorDimensions(i, a, s), a === this.width && s === this.height) {
    const f = this.clone();
    return f.position = [0, 0], f;
  }
  let o = Math.round((this.width - a) / 2), h = Math.round((this.height - s) / 2);
  const l = Image.createFrom(this, {
    width: a,
    height: s,
    position: [o, h]
  });
  switch (n) {
    case validInterpolations.nearestneighbor:
      nearestNeighbor.call(this, l, a, s);
      break;
    default:
      throw new Error(
        `unsupported resize interpolation: ${n}`
      );
  }
  return l;
}
function hsv() {
  this.checkProcessable("hsv", {
    bitDepth: [8, 16],
    alpha: [0, 1],
    colorModel: [RGB$1]
  });
  let e = Image.createFrom(this, {
    colorModel: HSV
  }), i = 0, t = this.data;
  for (let r = 0; r < t.length; r += this.channels) {
    let n = t[r], a = t[r + 1], s = t[r + 2], o = Math.min(n, a, s), h = Math.max(n, a, s), l = h - o, f = 0, b = h === 0 ? 0 : l / h, w = h;
    if (h !== o) {
      switch (h) {
        case n:
          f = (a - s) / l + (a < s ? 6 : 0);
          break;
        case a:
          f = (s - n) / l + 2;
          break;
        case s:
          f = (n - a) / l + 4;
          break;
        default:
          throw new Error("unreachable");
      }
      f /= 6;
    }
    e.data[i++] = f * this.maxValue, e.data[i++] = b * this.maxValue, e.data[i++] = w, this.alpha && (e.data[i++] = t[r + 3]);
  }
  return e;
}
function hsl$1() {
  this.checkProcessable("hsl", {
    bitDepth: [8, 16],
    alpha: [0, 1],
    colorModel: [RGB$1]
  });
  let e = Image.createFrom(this, {
    colorModel: HSL
  }), i = Math.floor(this.maxValue / 2), t = 0, r = this.data;
  for (let n = 0; n < r.length; n += this.channels) {
    let a = r[n], s = r[n + 1], o = r[n + 2], h = Math.max(a, s, o), l = Math.min(a, s, o), f = 0, b = 0, w = (h + l) / 2;
    if (h !== l) {
      let g = h - l;
      switch (b = w > i ? g / (2 - h - l) : g / (h + l), h) {
        case a:
          f = (s - o) / g + (s < o ? 6 : 0);
          break;
        case s:
          f = (o - a) / g + 2;
          break;
        case o:
          f = (a - s) / g + 4;
          break;
        default:
          throw new Error("unreachable");
      }
      f /= 6;
    }
    e.data[t++] = f * this.maxValue, e.data[t++] = b * this.maxValue, e.data[t++] = w, this.alpha && (e.data[t++] = r[n + 3]);
  }
  return e;
}
function cmyk() {
  this.checkProcessable("cmyk", {
    bitDepth: [8, 16],
    alpha: [0, 1],
    colorModel: [RGB$1]
  });
  let e = Image.createFrom(this, {
    components: 4,
    colorModel: CMYK$1
  }), i = 0, t = this.data;
  for (let r = 0; r < t.length; r += this.channels) {
    let n = t[r], a = t[r + 1], s = t[r + 2], o = Math.min(
      this.maxValue - n,
      this.maxValue - a,
      this.maxValue - s
    ), h = (this.maxValue - n - o) / (1 - o / this.maxValue), l = (this.maxValue - a - o) / (1 - o / this.maxValue), f = (this.maxValue - s - o) / (1 - o / this.maxValue);
    e.data[i++] = Math.round(h), e.data[i++] = Math.round(l), e.data[i++] = Math.round(f), e.data[i++] = Math.round(o), this.alpha && (e.data[i++] = t[r + 3]);
  }
  return e;
}
function rgba8() {
  return new Image(this.width, this.height, this.getRGBAData(), {
    kind: "RGBA",
    parent: this
  });
}
const methods$1 = {
  luma709(e, i, t) {
    return e * 6966 + i * 23436 + t * 2366 >> 15;
  },
  luma601(e, i, t) {
    return e * 9798 + i * 19235 + t * 3735 >> 15;
  },
  maximum(e, i, t) {
    return Math.max(e, i, t);
  },
  minimum(e, i, t) {
    return Math.min(e, i, t);
  },
  average(e, i, t) {
    return (e + i + t) / 3 >> 0;
  },
  minmax(e, i, t) {
    return (Math.max(e, i, t) + Math.min(e, i, t)) / 2;
  },
  red(e) {
    return e;
  },
  green(e, i) {
    return i;
  },
  blue(e, i, t) {
    return t;
  },
  cyan(e, i, t, r) {
    let n = methods$1.black(e, i, t, r);
    return (r.maxValue - e - n) / (1 - n / r.maxValue) >> 0;
  },
  magenta(e, i, t, r) {
    let n = methods$1.black(e, i, t, r);
    return (r.maxValue - i - n) / (1 - n / r.maxValue) >> 0;
  },
  yellow(e, i, t, r) {
    let n = methods$1.black(e, i, t, r);
    return (r.maxValue - t - n) / (1 - n / r.maxValue) >> 0;
  },
  black(e, i, t, r) {
    return Math.min(
      r.maxValue - e,
      r.maxValue - i,
      r.maxValue - t
    );
  },
  hue(e, i, t, r) {
    let n = methods$1.min(e, i, t), a = methods$1.max(e, i, t);
    if (a === n)
      return 0;
    let s = 0, o = a - n;
    switch (a) {
      case e:
        s = (i - t) / o + (i < t ? 6 : 0);
        break;
      case i:
        s = (t - e) / o + 2;
        break;
      case t:
        s = (e - i) / o + 4;
        break;
      default:
        throw new Error("unreachable");
    }
    return s / 6 * r.maxValue >> 0;
  },
  saturation(e, i, t, r) {
    let n = methods$1.min(e, i, t), a = methods$1.max(e, i, t), s = a - n;
    return a === 0 ? 0 : s / a * r.maxValue;
  },
  lightness(e, i, t) {
    let r = methods$1.min(e, i, t);
    return (methods$1.max(e, i, t) + r) / 2;
  }
};
Object.defineProperty(methods$1, "luminosity", {
  enumerable: !1,
  value: methods$1.lightness
});
Object.defineProperty(methods$1, "luminance", {
  enumerable: !1,
  value: methods$1.lightness
});
Object.defineProperty(methods$1, "min", {
  enumerable: !1,
  value: methods$1.minimum
});
Object.defineProperty(methods$1, "max", {
  enumerable: !1,
  value: methods$1.maximum
});
Object.defineProperty(methods$1, "brightness", {
  enumerable: !1,
  value: methods$1.maximum
});
Object.keys(methods$1).forEach((e) => {
});
function grey(e = {}) {
  let { algorithm: i = "luma709", keepAlpha: t = !1, mergeAlpha: r = !0 } = e;
  if (typeof i != "string" && typeof i != "function")
    throw new TypeError("algorithm must be a string or a function");
  this.checkProcessable("grey", {
    bitDepth: [8, 16],
    alpha: [0, 1]
  }), this.components === 1 && (i = "red"), t &= this.alpha, r &= this.alpha, t && (r = !1);
  let n = getOutputImage(this, e, {
    components: 1,
    alpha: t,
    colorModel: GREY$1
  }), a;
  if (typeof i == "function")
    a = i;
  else if (a = methods$1[i.toLowerCase()], !a)
    throw new Error(`unsupported grey algorithm: ${i}`);
  let s = 0;
  for (let o = 0; o < this.data.length; o += this.channels)
    r ? n.data[s++] = clamp(
      a(this.data[o], this.data[o + 1], this.data[o + 2], this) * this.data[o + this.components] / this.maxValue,
      this
    ) : (n.data[s++] = clamp(
      a(this.data[o], this.data[o + 1], this.data[o + 2], this),
      this
    ), n.alpha && (n.data[s++] = this.data[o + this.components]));
  return n;
}
function huang(e) {
  let i = 0;
  for (let f = 0; f < e.length; f++)
    if (e[f] !== 0) {
      i = f;
      break;
    }
  let t = e.length - 1;
  for (let f = e.length - 1; f >= i; f--)
    if (e[f] !== 0) {
      t = f;
      break;
    }
  let r = 1 / (t - i), n = new Array(e.length), a = 0, s = 0;
  for (let f = i; f < e.length; f++)
    a += f * e[f], s += e[f], n[f] = a / s;
  let o = new Array(e.length);
  a = s = 0;
  for (let f = t; f > 0; f--)
    a += f * e[f], s += e[f], o[f - 1] = a / s;
  let h = -1, l = Number.MAX_VALUE;
  for (let f = 0; f < e.length; f++) {
    let b = 0, w;
    for (let g = 0; g <= f; g++)
      w = 1 / (1 + r * Math.abs(g - n[f])), w < 1e-6 || w > 0.999999 || (b += e[g] * (-w * Math.log(w) - (1 - w) * Math.log(1 - w)));
    for (let g = f + 1; g < e.length; g++)
      w = 1 / (1 + r * Math.abs(g - o[f])), w < 1e-6 || w > 0.999999 || (b += e[g] * (-w * Math.log(w) - (1 - w) * Math.log(1 - w)));
    b < l && (l = b, h = f);
  }
  return h;
}
function intermodes(e) {
  let i = e.slice(), t = 0;
  for (; !bimodalTest$1(i); ) {
    let n = 0, a = 0, s = i[0];
    for (let o = 0; o < e.length - 1; o++)
      n = a, a = s, s = i[o + 1], i[o] = (n + a + s) / 3;
    if (i[e.length - 1] = (a + s) / 3, t++, t > 1e4)
      throw new Error("Intermodes Threshold not found after 10000 iterations");
  }
  let r = 0;
  for (let n = 1; n < e.length - 1; n++)
    i[n - 1] < i[n] && i[n + 1] < i[n] && (r += n);
  return Math.floor(r / 2);
}
function bimodalTest$1(e) {
  let i = !1, t = 0;
  for (let r = 1; r < e.length - 1; r++)
    if (e[r - 1] < e[r] && e[r + 1] < e[r] && (t++, t > 2))
      return !1;
  return t === 2 && (i = !0), i;
}
function isodata(e) {
  let i, t, r, n, a = 0;
  for (let s = 1; s < e.length; s++)
    if (e[s] > 0) {
      a = s + 1;
      break;
    }
  for (; ; ) {
    i = 0, r = 0;
    for (let s = 0; s < a; s++)
      r = r + e[s], i = i + e[s] * s;
    n = 0, t = 0;
    for (let s = a + 1; s < e.length; s++)
      t += e[s], n += e[s] * s;
    if (r > 0 && t > 0 && (i /= r, n /= t, a === Math.round((i + n) / 2)))
      break;
    if (a++, a > e.length - 2)
      throw new Error("Threshold not found");
  }
  return a;
}
function li(e, i) {
  let t, r, n, a, s, o, h, l, f, b, w, g;
  w = 0.5, b = 0;
  for (let E = 0; E < e.length; E++)
    b += E * e[E];
  b /= i, h = b;
  do {
    o = h, t = o + 0.5 | 0, r = 0, a = 0;
    for (let E = 0; E <= t; E++)
      r += E * e[E], a += e[E];
    l = a === 0 ? 0 : r / a, n = 0, s = 0;
    for (let E = t + 1; E < e.length; E++)
      n += E * e[E], s += e[E];
    f = s === 0 ? 0 : n / s, g = (l - f) / (Math.log(l) - Math.log(f)), g < -Number.EPSILON ? h = g - 0.5 | 0 : h = g + 0.5 | 0;
  } while (Math.abs(h - o) > w);
  return t;
}
function maxEntropy(e, i) {
  let t = new Array(e.length);
  for (let w = 0; w < e.length; w++)
    t[w] = e[w] / i;
  let r = new Array(e.length), n = new Array(e.length);
  r[0] = t[0], n[0] = 1 - r[0];
  for (let w = 1; w < e.length; w++)
    r[w] = r[w - 1] + t[w], n[w] = 1 - r[w];
  let a = 0;
  for (let w = 0; w < e.length; w++)
    if (Math.abs(r[w]) >= Number.EPSILON) {
      a = w;
      break;
    }
  let s = e.length - 1;
  for (let w = e.length - 1; w >= a; w--)
    if (Math.abs(n[w]) >= Number.EPSILON) {
      s = w;
      break;
    }
  let o = -1, h, l = Number.MIN_VALUE, f, b;
  for (let w = a; w <= s; w++) {
    f = 0;
    for (let g = 0; g <= w; g++)
      e[g] !== 0 && (f -= t[g] / r[w] * Math.log(t[g] / r[w]));
    b = 0;
    for (let g = w + 1; g < e.length; g++)
      e[g] !== 0 && (b -= t[g] / n[w] * Math.log(t[g] / n[w]));
    h = f + b, l < h && (l = h, o = w);
  }
  return o;
}
function mean$1(e, i) {
  let t = 0;
  for (let r = 0; r < e.length; r++)
    t += r * e[r];
  return Math.floor(t / i);
}
function minError(e, i) {
  let t, r = -2, n, a, s, o, h, l, f, b, w, g, E, k = 0;
  for (let A = 0; A < e.length; A++)
    k += A * e[A];
  for (k /= i, t = k; t !== r; ) {
    let A = sumA(e, t), T = sumA(e, e.length - 1), C = sumB(e, t), D = sumB(e, e.length - 1), $ = sumC(e, t), P = sumC(e, e.length - 1);
    if (n = C / A, a = (D - C) / (T - A), s = A / T, o = (T - A) / T, h = $ / A - n * n, l = (P - $) / (T - A) - a * a, f = 1 / h - 1 / l, b = n / h - a / l, w = n * n / h - a * a / l + Math.log10(h * (o * o) / (l * (s * s))), g = b * b - f * w, g < 0)
      return t;
    r = t, E = (b + Math.sqrt(g)) / f, isNaN(E) ? t = r : t = Math.floor(E);
  }
  return t;
}
function sumA(e, i) {
  let t = 0;
  for (let r = 0; r <= i; r++)
    t += e[r];
  return t;
}
function sumB(e, i) {
  let t = 0;
  for (let r = 0; r <= i; r++)
    t += r * e[r];
  return t;
}
function sumC(e, i) {
  let t = 0;
  for (let r = 0; r <= i; r++)
    t += r * r * e[r];
  return t;
}
function minimum(e) {
  if (e.length < 2)
    return 0;
  let i = 0, t = -1, r = -1, n = new Array(e.length);
  for (let a = 0; a < e.length; a++)
    n[a] = e[a], e[a] > 0 && (r = a);
  for (; !bimodalTest(n); )
    if (n = smoothed(n), i++, i > 1e4)
      return t;
  return t = minimumBetweenPeeks(n, r), t;
}
function smoothed(e) {
  let i = new Array(e.length);
  for (let t = 1; t < e.length - 1; t++)
    i[t] = (e[t - 1] + e[t] + e[t + 1]) / 3;
  return i[0] = (e[0] + e[1]) / 3, i[e.length - 1] = (e[e.length - 2] + e[e.length - 1]) / 3, i;
}
function minimumBetweenPeeks(e, i) {
  let t;
  for (let r = 1; r < i; r++)
    if (e[r - 1] > e[r] && e[r + 1] >= e[r]) {
      t = r;
      break;
    }
  return t;
}
function bimodalTest(e) {
  let i = e.length, t = !1, r = 0;
  for (let n = 1; n < i - 1; n++)
    if (e[n - 1] < e[n] && e[n + 1] < e[n] && (r++, r > 2))
      return !1;
  return r === 2 && (t = !0), t;
}
function moments(e, i) {
  let t = 1, r = 0, n = 0, a = 0, s = 0, o, h, l, f, b, w, g = -1, E = e.length, k = new Array(E);
  for (let A = 0; A < E; A++)
    k[A] = e[A] / i;
  for (let A = 0; A < E; A++)
    r += A * k[A], n += A * A * k[A], a += A * A * A * k[A];
  h = t * n - r * r, l = (-n * n + r * a) / h, f = (t * -a + n * r) / h, b = 0.5 * (-f - Math.sqrt(f * f - 4 * l)), w = 0.5 * (-f + Math.sqrt(f * f - 4 * l)), o = (w - r) / (w - b);
  for (let A = 0; A < E; A++)
    if (s += k[A], s > o) {
      g = A;
      break;
    }
  return g;
}
function otsu(e, i) {
  let t = 0, r = 0, n = 0, a = 0, s = 0;
  for (let o = 0; o < e.length; o++)
    s += o * e[o];
  for (let o = 0; o < e.length; o++) {
    r = r + e[o];
    const h = i - r;
    if (r === 0 || h === 0)
      continue;
    t = t + o * e[o];
    const l = (s - t) / h, f = r * h * (t / r - l) * (t / r - l);
    f >= n && (a = o, n = f);
  }
  return a;
}
function percentile(e) {
  let i = -1, t = 0.5, r = new Array(e.length), n = partialSum(e, e.length - 1), a = 1;
  for (let s = 0; s < e.length; s++)
    r[s] = Math.abs(partialSum(e, s) / n - t), r[s] < a && (a = r[s], i = s);
  return i;
}
function partialSum(e, i) {
  let t = 0;
  for (let r = 0; r <= i; r++)
    t += e[r];
  return t;
}
function renyiEntropy(e, i) {
  let t, r, n, a = new Array(e.length), s = new Array(e.length), o = new Array(e.length), h = 0, l = 0, f = 0, b = 0, w = 0, g = 0, k = 1 / (1 - 0.5), T = 1 / (1 - 2);
  for (let P = 0; P < e.length; P++)
    a[P] = e[P] / i;
  s[0] = a[0], o[0] = 1 - s[0];
  for (let P = 1; P < e.length; P++)
    s[P] = s[P - 1] + a[P], o[P] = 1 - s[P];
  r = 0;
  for (let P = 0; P < e.length; P++)
    if (Math.abs(s[P]) >= Number.EPSILON) {
      r = P;
      break;
    }
  n = e.length - 1;
  for (let P = e.length - 1; P >= r; P--)
    if (Math.abs(o[P]) >= Number.EPSILON) {
      n = P;
      break;
    }
  for (let P = r; P <= n; P++) {
    let z = 0, B = 0, F = 0;
    for (let W = 0; W <= P; W++)
      e[W] !== 0 && (z -= a[W] / s[P] * Math.log(a[W] / s[P])), B += Math.sqrt(a[W] / s[P]), F += a[W] * a[W] / (s[P] * s[P]);
    let O = 0, N = 0, G = 0;
    for (let W = P + 1; W < e.length; W++)
      e[W] !== 0 && (O -= a[W] / o[P] * Math.log(a[W] / o[P])), N += Math.sqrt(a[W] / o[P]), G += a[W] * a[W] / (o[P] * o[P]);
    let V = z + O, J = k * (B * N > 0 ? Math.log(B * N) : 0), Q = T * (F * G > 0 ? Math.log(F * G) : 0);
    V > b && (b = V, h = P), J > w && (w = J, l = P), Q > g && (g = Q, f = P);
  }
  let C = [h, l, f];
  C.sort((P, z) => P - z);
  let D;
  Math.abs(C[0] - C[1]) <= 5 ? Math.abs(C[1] - C[2]) <= 5 ? D = [1, 2, 1] : D = [0, 1, 3] : Math.abs(C[1] - C[2]) <= 5 ? D = [3, 1, 0] : D = [1, 2, 1];
  let $ = s[C[2]] - s[C[0]];
  return t = Math.round(
    C[0] * (s[C[0]] + 0.25 * $ * D[0]) + 0.25 * C[1] * $ * D[1] + C[2] * (o[C[2]] + 0.25 * $ * D[2])
  ), t;
}
function shanbhag(e, i) {
  let t = new Array(e.length);
  for (let g = 0; g < e.length; g++)
    t[g] = e[g] / i;
  let r = new Array(e.length), n = new Array(e.length);
  r[0] = t[0], n[0] = 1 - r[0];
  for (let g = 1; g < e.length; g++)
    r[g] = r[g - 1] + t[g], n[g] = 1 - r[g];
  let a = 0;
  for (let g = 0; g < e.length; g++)
    if (Math.abs(r[g]) >= Number.EPSILON) {
      a = g;
      break;
    }
  let s = e.length - 1;
  for (let g = e.length - 1; g >= a; g--)
    if (Math.abs(n[g]) >= Number.EPSILON) {
      s = g;
      break;
    }
  let o = -1, h = Number.MAX_VALUE, l, f, b, w;
  for (let g = a; g <= s; g++) {
    b = 0, l = 0.5 / r[g];
    for (let E = 1; E <= g; E++)
      b -= t[E] * Math.log(1 - l * r[E - 1]);
    b *= l, w = 0, l = 0.5 / n[g];
    for (let E = g + 1; E < e.length; E++)
      w -= t[E] * Math.log(1 - l * n[E]);
    w *= l, f = Math.abs(b - w), f < h && (h = f, o = g);
  }
  return o;
}
function triangle$1(e) {
  let i = 0, t = 0, r = 0, n = 0;
  for (let b = 0; b < e.length; b++)
    if (e[b] > 0) {
      i = b;
      break;
    }
  i > 0 && i--;
  for (let b = e.length - 1; b > 0; b--)
    if (e[b] > 0) {
      n = b;
      break;
    }
  n < e.length - 1 && n++;
  for (let b = 0; b < e.length; b++)
    e[b] > t && (r = b, t = e[b]);
  let a = !1;
  if (r - i < n - r) {
    a = !0;
    let b = 0, w = e.length - 1;
    for (; b < w; ) {
      let g = e[b];
      e[b] = e[w], e[w] = g, b++, w--;
    }
    i = e.length - 1 - n, r = e.length - 1 - r;
  }
  if (i === r)
    return i;
  let s, o, h;
  s = e[r], o = i - r, h = Math.sqrt(s * s + o * o), s /= h, o /= h, h = s * i + o * e[i];
  let l = i, f = 0;
  for (let b = i + 1; b <= r; b++) {
    let w = s * b + o * e[b] - h;
    w > f && (l = b, f = w);
  }
  if (l--, a) {
    let b = 0, w = e.length - 1;
    for (; b < w; ) {
      let g = e[b];
      e[b] = e[w], e[w] = g, b++, w--;
    }
    return e.length - 1 - l;
  } else
    return l;
}
function yen(e, i) {
  let t = new Array(e.length);
  for (let l = 0; l < e.length; l++)
    t[l] = e[l] / i;
  let r = new Array(e.length);
  r[0] = t[0];
  for (let l = 1; l < e.length; l++)
    r[l] = r[l - 1] + t[l];
  let n = new Array(e.length);
  n[0] = t[0] * t[0];
  for (let l = 1; l < e.length; l++)
    n[l] = n[l - 1] + t[l] * t[l];
  let a = new Array(e.length);
  a[e.length - 1] = 0;
  for (let l = e.length - 2; l >= 0; l--)
    a[l] = a[l + 1] + t[l + 1] * t[l + 1];
  let s = -1, o = Number.MIN_VALUE, h;
  for (let l = 0; l < e.length; l++)
    h = -1 * (n[l] * a[l] > 0 ? Math.log(n[l] * a[l]) : 0) + 2 * (r[l] * (1 - r[l]) > 0 ? Math.log(r[l] * (1 - r[l])) : 0), h > o && (o = h, s = l);
  return s;
}
const methods = {
  huang,
  intermodes,
  isodata,
  li,
  maxentropy: maxEntropy,
  mean: mean$1,
  minerror: minError,
  minimum,
  moments,
  otsu,
  percentile,
  renyientropy: renyiEntropy,
  shanbhag,
  triangle: triangle$1,
  yen
}, names = {};
Object.keys(methods).forEach((e) => {
  names[e] = e;
});
function getThreshold(e = {}) {
  let { algorithm: i = names.otsu } = e;
  this.checkProcessable("getThreshold", {
    components: 1,
    bitDepth: [8, 16]
  });
  let t = methods[i.toLowerCase()];
  if (t) {
    let r = this.getHistogram();
    return t(r, this.size);
  } else
    throw new Error(`unknown thresholding algorithm: ${i}`);
}
const THRESHOLD = "threshold";
function mask(e = {}) {
  let {
    algorithm: i = THRESHOLD,
    threshold: t = 0.5,
    useAlpha: r = !0,
    invert: n = !1
  } = e;
  this.checkProcessable("mask", {
    components: 1,
    bitDepth: [8, 16]
  }), i === THRESHOLD ? t = getThreshold$1(t, this.maxValue) : t = getThreshold.call(this, e);
  let a = new Image(this.width, this.height, {
    kind: "BINARY",
    parent: this
  }), s = 0;
  if (this.alpha && r)
    for (let o = 0; o < this.data.length; o += this.channels) {
      let h = this.data[o] + (this.maxValue - this.data[o]) * (this.maxValue - this.data[o + 1]) / this.maxValue;
      (n && h <= t || !n && h >= t) && a.setBit(s), s++;
    }
  else
    for (let o = 0; o < this.data.length; o += this.channels)
      (n && this.data[o] <= t || !n && this.data[o] >= t) && a.setBit(s), s++;
  return a;
}
function copyImage(e, i, t, r) {
  let n = e.width, a = e.height, s = i.width, o = e.channels;
  for (let h = 0; h < n; h++)
    for (let l = 0; l < a; l++)
      for (let f = 0; f < o; f++) {
        let b = (l * n + h) * o + f, w = ((r + l) * s + t + h) * o + f;
        i.data[w] = e.data[b];
      }
}
function pad(e = {}) {
  let { size: i = 0, algorithm: t = "copy", color: r } = e;
  if (this.checkProcessable("pad", {
    bitDepth: [8, 16]
  }), t === "set") {
    if (r.length !== this.channels)
      throw new Error(
        `pad: the color array must have the same length as the number of channels. Here: ${this.channels}`
      );
    for (let h = 0; h < r.length; h++)
      r[h] === 0 && (r[h] = 1e-3);
  } else
    r = newArray(this.channels, null);
  Array.isArray(i) || (i = [i, i]);
  let n = this.width + i[0] * 2, a = this.height + i[1] * 2, s = this.channels, o = Image.createFrom(this, { width: n, height: a });
  copyImage(this, o, i[0], i[1]);
  for (let h = i[0]; h < n - i[0]; h++)
    for (let l = 0; l < s; l++) {
      let f = r[l] || o.data[(i[1] * n + h) * s + l];
      for (let b = 0; b < i[1]; b++)
        o.data[(b * n + h) * s + l] = f;
      f = r[l] || o.data[((a - i[1] - 1) * n + h) * s + l];
      for (let b = a - i[1]; b < a; b++)
        o.data[(b * n + h) * s + l] = f;
    }
  for (let h = 0; h < a; h++)
    for (let l = 0; l < s; l++) {
      let f = r[l] || o.data[(h * n + i[0]) * s + l];
      for (let b = 0; b < i[0]; b++)
        o.data[(h * n + b) * s + l] = f;
      f = r[l] || o.data[(h * n + n - i[0] - 1) * s + l];
      for (let b = n - i[0]; b < n; b++)
        o.data[(h * n + b) * s + l] = f;
    }
  return o;
}
function colorDepth(e = 8) {
  if (this.checkProcessable("colorDepth", {
    bitDepth: [1, 8, 16]
  }), ![8, 16].includes(e))
    throw Error("You need to specify the new colorDepth as 8 or 16");
  if (this.bitDepth === e)
    return this.clone();
  let i = Image.createFrom(this, { bitDepth: e });
  switch (e) {
    case 8:
      if (this.bitDepth === 1)
        for (let t = 0; t < this.size; t++)
          this.getBit(t) && (i.data[t] = 255);
      else
        for (let t = 0; t < this.data.length; t++)
          i.data[t] = this.data[t] >> 8;
      break;
    case 16:
      if (this.bitDepth === 1)
        for (let t = 0; t < this.size; t++)
          this.getBit(t) && (i.data[t] = 65535);
      else
        for (let t = 0; t < this.data.length; t++)
          i.data[t] = this.data[t] << 8 | this.data[t];
      break;
    default:
      throw new Error("colorDepth conversion unexpected case");
  }
  return i;
}
function rotateFree(e, i = {}) {
  const {
    interpolation: t = validInterpolations.nearestneighbor,
    width: r = this.width,
    height: n = this.height
  } = i;
  if (typeof e != "number")
    throw new TypeError("degrees must be a number");
  const a = checkInterpolation(t), s = e * Math.PI / 180, o = Math.floor(
    Math.abs(r * Math.cos(s)) + Math.abs(n * Math.sin(s))
  ), h = Math.floor(
    Math.abs(n * Math.cos(s)) + Math.abs(r * Math.sin(s))
  ), l = Math.cos(-s), f = Math.sin(-s);
  let b = o / 2, w = h / 2;
  o % 2 === 0 ? (b = b - 0.5, h % 2 === 0 ? w = w - 0.5 : w = Math.floor(w)) : (b = Math.floor(b), h % 2 === 0 ? w = w - 0.5 : w = Math.floor(w));
  const g = Math.floor(r / 2 - b), E = Math.floor(n / 2 - w);
  if (this.bitDepth === 1) {
    const k = new Image(o, h, {
      kind: "BINARY",
      parent: this
    });
    switch (a) {
      case validInterpolations.nearestneighbor:
        return rotateBinaryNearestNeighbor(
          this,
          k,
          g,
          E,
          b,
          w,
          l,
          f
        );
      case validInterpolations.bilinear:
        return rotateBinaryBilinear(
          this,
          k,
          g,
          E,
          b,
          w,
          l,
          f
        );
      default:
        throw new Error(
          `unsupported rotate interpolation: ${a}`
        );
    }
  } else {
    const k = Image.createFrom(this, {
      width: o,
      height: h
    });
    switch (a) {
      case validInterpolations.nearestneighbor:
        return rotateNearestNeighbor(
          this,
          k,
          g,
          E,
          b,
          w,
          l,
          f
        );
      case validInterpolations.bilinear:
        return rotateBilinear(
          this,
          k,
          g,
          E,
          b,
          w,
          l,
          f
        );
      default:
        throw new Error(
          `unsupported rotate interpolation: ${a}`
        );
    }
  }
}
function rotateNearestNeighbor(e, i, t, r, n, a, s, o) {
  for (let h = 0; h < i.width; h += 1)
    for (let l = 0; l < i.height; l += 1)
      for (let f = 0; f < e.channels; f++) {
        let b = Math.round((h - n) * s - (l - a) * o + n) + t, w = Math.round((l - a) * s + (h - n) * o + a) + r;
        b < 0 || b >= e.width || w < 0 || w >= e.height ? e.alpha === 1 && f === e.channels - 1 ? i.setValueXY(h, l, f, 0) : i.setValueXY(h, l, f, e.maxValue) : i.setValueXY(h, l, f, e.getValueXY(b, w, f));
      }
  return i;
}
function rotateBinaryNearestNeighbor(e, i, t, r, n, a, s, o) {
  for (let h = 0; h < i.width; h += 1)
    for (let l = 0; l < i.height; l += 1) {
      let f = Math.round((h - n) * s - (l - a) * o + n) + t, b = Math.round((l - a) * s + (h - n) * o + a) + r;
      (f < 0 || f >= e.width || b < 0 || b >= e.height || e.getBitXY(f, b)) && i.setBitXY(h, l);
    }
  return i;
}
function rotateBilinear(e, i, t, r, n, a, s, o) {
  let h = e.width * e.channels;
  for (let l = 0; l < i.height; l++)
    for (let f = 0; f < i.width; f++) {
      let b = (f - n) * s - (l - a) * o + n + t, w = (l - a) * s + (f - n) * o + a + r, g = b | 0, E = w | 0, k = b - g, A = w - E;
      for (let T = 0; T < e.channels; T++)
        if (b < 0 || b >= e.width || w < 0 || w >= e.height)
          e.alpha === 1 && T === e.channels - 1 ? i.setValueXY(f, l, T, 0) : i.setValueXY(f, l, T, e.maxValue);
        else {
          let C = (E * e.width + g) * e.channels + T, D = e.data[C], $ = e.data[C + e.channels], P = e.data[C + h], z = e.data[C + h + e.channels], B = D + k * ($ - D) + A * (P - D) + k * A * (D - $ - P + z) | 0;
          i.setValueXY(f, l, T, B);
        }
    }
  return i;
}
function rotateBinaryBilinear(e, i, t, r, n, a, s, o) {
  let h = e.width;
  for (let l = 0; l < i.height; l++)
    for (let f = 0; f < i.width; f++) {
      let b = (f - n) * s - (l - a) * o + n + t, w = (l - a) * s + (f - n) * o + a + r, g = b | 0, E = w | 0, k = b - g, A = w - E;
      if (b < 0 || b >= e.width || w < 0 || w >= e.height)
        i.setBitXY(f, l);
      else {
        let T = E * e.width + g, C = e.getBit(T), D = e.getBit(T + 1), $ = e.getBit(T + h), P = e.getBit(T + 1 + h);
        (C | k & D - C | A & $ - C | k & A & C - D - $ + P) > 0 && i.setBitXY(f, l);
      }
    }
  return i;
}
function rotate$1(e, i) {
  if (this.checkProcessable("rotate", {
    bitDepth: [1, 8, 16]
  }), typeof e != "number")
    throw new TypeError("angle must be a number");
  switch (e < 0 && (e = Math.ceil(-e / 360) * 360 + e), e % 360) {
    case 0:
      return this.clone();
    case 90:
      return rotateRight.call(this);
    case 180:
      return rotate180.call(this);
    case 270:
      return rotateLeft.call(this);
    default:
      return rotateFree.call(this, e, i);
  }
}
function rotateLeft() {
  if (this.bitDepth === 1) {
    const e = new Image(this.height, this.width, {
      kind: "BINARY",
      parent: this
    }), i = e.height - 1;
    for (let t = 0; t < this.height; t++)
      for (let r = 0; r < this.width; r++)
        this.getBitXY(r, t) && e.setBitXY(t, i - r);
    return e;
  } else {
    const e = Image.createFrom(this, {
      width: this.height,
      height: this.width
    }), i = e.height - 1;
    for (let t = 0; t < this.height; t++)
      for (let r = 0; r < this.width; r++)
        for (let n = 0; n < this.channels; n++)
          e.setValueXY(t, i - r, n, this.getValueXY(r, t, n));
    return e;
  }
}
function rotateRight() {
  if (this.bitDepth === 1) {
    const e = new Image(this.height, this.width, {
      kind: "BINARY",
      parent: this
    }), i = e.width - 1;
    for (let t = 0; t < this.height; t++)
      for (let r = 0; r < this.width; r++)
        this.getBitXY(r, t) && e.setBitXY(i - t, r);
    return e;
  } else {
    const e = Image.createFrom(this, {
      width: this.height,
      height: this.width
    }), i = e.width - 1;
    for (let t = 0; t < this.height; t++)
      for (let r = 0; r < this.width; r++)
        for (let n = 0; n < this.channels; n++)
          e.setValueXY(i - t, r, n, this.getValueXY(r, t, n));
    return e;
  }
}
function rotate180() {
  if (this.bitDepth === 1) {
    const e = new Image(this.width, this.height, {
      kind: "BINARY",
      parent: this
    }), i = e.width - 1, t = e.height - 1;
    for (let r = 0; r < this.height; r++)
      for (let n = 0; n < this.width; n++)
        this.getBitXY(n, r) && e.setBitXY(i - n, t - r);
    return e;
  } else {
    const e = Image.createFrom(this), i = e.width - 1, t = e.height - 1;
    for (let r = 0; r < this.height; r++)
      for (let n = 0; n < this.width; n++)
        for (let a = 0; a < this.channels; a++)
          e.setValueXY(
            i - n,
            t - r,
            a,
            this.getValueXY(n, r, a)
          );
    return e;
  }
}
function insert(e, i = {}) {
  const t = getImageParameters(e);
  this.checkProcessable("insert", t);
  let { x: r = 0, y: n = 0 } = i;
  const a = getOutputImageOrInPlace(this, i, { copy: !0 }), s = Math.min(a.height, n + e.height), o = Math.min(a.width, r + e.width);
  if (a.bitDepth === 1)
    for (let h = n; h < s; h++)
      for (let l = r; l < o; l++)
        e.getBitXY(l - r, h - n) ? a.setBitXY(l, h) : a.clearBitXY(l, h);
  else
    for (let h = n; h < s; h++)
      for (let l = r; l < o; l++)
        a.setPixelXY(l, h, e.getPixelXY(l - r, h - n));
  return a;
}
function setBorder(e = {}) {
  let { size: i = 0, algorithm: t = "copy", color: r } = e;
  if (this.checkProcessable("setBorder", {
    bitDepth: [8, 16, 32, 64]
  }), t === "set") {
    if (r.length !== this.channels)
      throw new Error(
        `setBorder: the color array must have the same length as the number of channels. Here: ${this.channels}`
      );
    for (let o = 0; o < r.length; o++)
      r[o] === 0 && (r[o] = 1e-3);
  } else
    r = newArray(this.channels, null);
  Array.isArray(i) || (i = [i, i]);
  let n = i[0], a = i[1], s = this.channels;
  for (let o = n; o < this.width - n; o++)
    for (let h = 0; h < s; h++) {
      let l = r[h] || this.data[(o + this.width * a) * s + h];
      for (let f = 0; f < a; f++)
        this.data[(f * this.width + o) * s + h] = l;
      l = r[h] || this.data[(o + this.width * (this.height - a - 1)) * s + h];
      for (let f = this.height - a; f < this.height; f++)
        this.data[(f * this.width + o) * s + h] = l;
    }
  for (let o = 0; o < this.height; o++)
    for (let h = 0; h < s; h++) {
      let l = r[h] || this.data[(o * this.width + n) * s + h];
      for (let f = 0; f < n; f++)
        this.data[(o * this.width + f) * s + h] = l;
      l = r[h] || this.data[(o * this.width + this.width - n - 1) * s + h];
      for (let f = this.width - n; f < this.width; f++)
        this.data[(o * this.width + f) * s + h] = l;
    }
  return this;
}
function split(e = {}) {
  let { preserveAlpha: i = !0 } = e;
  if (this.checkProcessable("split", {
    bitDepth: [8, 16]
  }), this.components === 1)
    return new Stack([this.clone()]);
  let t = new Stack(), r = this.data;
  if (this.alpha && i)
    for (let n = 0; n < this.components; n++) {
      let a = Image.createFrom(this, {
        components: 1,
        alpha: !0,
        colorModel: GREY$1
      }), s = 0;
      for (let o = 0; o < r.length; o += this.channels)
        a.data[s++] = r[o + n], a.data[s++] = r[o + this.components];
      t.push(a);
    }
  else
    for (let n = 0; n < this.channels; n++) {
      let a = Image.createFrom(this, {
        components: 1,
        alpha: !1,
        colorModel: GREY$1
      }), s = 0;
      for (let o = 0; o < r.length; o += this.channels)
        a.data[s++] = r[o + n];
      t.push(a);
    }
  return t;
}
function getChannel(e, i = {}) {
  let { keepAlpha: t = !1, mergeAlpha: r = !1 } = i;
  t &= this.alpha, r &= this.alpha, this.checkProcessable("getChannel", {
    bitDepth: [8, 16]
  }), e = validateChannel(this, e);
  let n = Image.createFrom(this, {
    components: 1,
    alpha: t,
    colorModel: GREY$1
  }), a = 0;
  for (let s = 0; s < this.data.length; s += this.channels)
    r ? n.data[a++] = this.data[s + e] * this.data[s + this.components] / this.maxValue : (n.data[a++] = this.data[s + e], t && (n.data[a++] = this.data[s + this.components]));
  return n;
}
function combineChannels(e = defaultCombineMethod, i = {}) {
  let { mergeAlpha: t = !1, keepAlpha: r = !1 } = i;
  t &= this.alpha, r &= this.alpha, this.checkProcessable("combineChannels", {
    bitDepth: [8, 16]
  });
  let n = Image.createFrom(this, {
    components: 1,
    alpha: r,
    colorModel: GREY$1
  }), a = 0;
  for (let s = 0; s < this.size; s++) {
    let o = e(this.getPixel(s));
    t ? n.data[a++] = o * this.data[s * this.channels + this.components] / this.maxValue : (n.data[a++] = o, r && (n.data[a++] = this.data[s * this.channels + this.components]));
  }
  return n;
}
function defaultCombineMethod(e) {
  return (e[0] + e[1] + e[2]) / 3;
}
function setChannel(e, i) {
  if (this.checkProcessable("setChannel", {
    bitDepth: [8, 16]
  }), i.checkProcessable("setChannel (image parameter check)", {
    bitDepth: [this.bitDepth],
    alpha: [0],
    components: [1]
  }), i.width !== this.width || i.height !== this.height)
    throw new Error("Images must have exactly the same width and height");
  e = validateChannel(this, e);
  let t = e;
  for (let r = 0; r < i.data.length; r++)
    this.data[t] = i.data[r], t += this.channels;
  return this;
}
function getSimilarity(e, i = {}) {
  let {
    shift: t = [0, 0],
    average: r,
    channels: n,
    defaultAlpha: a,
    normalize: s,
    border: o = [0, 0]
  } = i;
  if (this.checkProcessable("getSimilarity", {
    bitDepth: [8, 16]
  }), Array.isArray(o) || (o = [o, o]), n = validateArrayOfChannels(this, {
    channels: n,
    defaultAlpha: a
  }), this.bitDepth !== e.bitDepth)
    throw new Error("Both images must have the same bitDepth");
  if (this.channels !== e.channels)
    throw new Error("Both images must have the same number of channels");
  if (this.colorModel !== e.colorModel)
    throw new Error("Both images must have the same colorModel");
  typeof r > "u" && (r = !0);
  let h = Math.max(o[0], -t[0]), l = Math.min(this.width - o[0], this.width - t[0]), f = Math.max(o[1], -t[1]), b = Math.min(this.height - o[1], this.height - t[1]), w = newArray(n.length, 0);
  for (let g = 0; g < n.length; g++) {
    let E = n[g], k = s ? this.sum[E] : Math.max(this.sum[E], e.sum[E]), A = s ? e.sum[E] : Math.max(this.sum[E], e.sum[E]);
    if (k !== 0 && A !== 0)
      for (let T = h; T < l; T++)
        for (let C = f; C < b; C++) {
          let D = T * this.multiplierX + C * this.multiplierY + E, $ = D + t[0] * this.multiplierX + t[1] * this.multiplierY;
          w[g] += Math.min(
            this.data[D] / k,
            e.data[$] / A
          );
        }
  }
  return r ? w.reduce((g, E) => g + E) / w.length : w;
}
function getPixelsGrid(e = {}) {
  let { sampling: i = [10, 10], painted: t = !1, mask: r } = e;
  this.checkProcessable("getPixelsGrid", {
    bitDepth: [8, 16],
    channels: 1
  }), Array.isArray(i) || (i = [i, i]);
  const n = i[0], a = i[1], s = [], o = [], h = this.width / n, l = this.height / a;
  let f = Math.floor(h / 2);
  for (let w = 0; w < n; w++) {
    let g = Math.floor(l / 2);
    for (let E = 0; E < a; E++) {
      let k = Math.round(f), A = Math.round(g);
      (!r || r.getBitXY(k, A)) && (s.push([k, A]), o.push(this.getPixelXY(k, A))), g += l;
    }
    f += h;
  }
  const b = { xyS: s, zS: o };
  return t && (b.painted = this.rgba8().paintPoints(s)), b;
}
function Matrix(e, i, t) {
  const r = new Array(e);
  for (let n = 0; n < e; n++)
    r[n] = new Array(i);
  if (t)
    for (let n = 0; n < e; n++)
      for (let a = 0; a < i; a++)
        r[n][a] = t;
  return r.width = e, r.height = i, Object.setPrototypeOf(r, Matrix.prototype), r;
}
Matrix.prototype.localMin = function(e, i) {
  let t = this[e][i], r = [e, i];
  for (let n = Math.max(0, e - 1); n < Math.min(this.length, e + 2); n++)
    for (let a = Math.max(0, i - 1); a < Math.min(this[0].length, i + 2); a++)
      this[n][a] < t && (t = this[n][a], r = [n, a]);
  return {
    position: r,
    value: t
  };
};
Matrix.prototype.localMax = function(e, i) {
  let t = this[e][i], r = [e, i];
  for (let n = Math.max(0, e - 1); n < Math.min(this.length, e + 2); n++)
    for (let a = Math.max(0, i - 1); a < Math.min(this[0].length, i + 2); a++)
      this[n][a] > t && (t = this[n][a], r = [n, a]);
  return {
    position: r,
    value: t
  };
};
Matrix.prototype.localSearch = function(e, i, t) {
  let r = [];
  for (let n = Math.max(0, e - 1); n < Math.min(this.length, e + 2); n++)
    for (let a = Math.max(0, i - 1); a < Math.min(this[0].length, i + 2); a++)
      this[n][a] === t && r.push([n, a]);
  return r;
};
function getBestMatch(e, i = {}) {
  let { border: t } = i;
  if (this.checkProcessable("getChannel", {
    bitDepth: [8, 16]
  }), this.bitDepth !== e.bitDepth)
    throw new Error("Both images must have the same bitDepth");
  if (this.channels !== e.channels)
    throw new Error("Both images must have the same number of channels");
  if (this.colorModel !== e.colorModel)
    throw new Error("Both images must have the same colorModel");
  let r = new Matrix(e.width, e.height, -1 / 0), n = Math.floor(e.width / 2), a = Math.floor(e.height / 2), s = n, o = a, h = !1;
  for (; !h; ) {
    let l = r.localSearch(
      n,
      a,
      -1 / 0
    );
    for (let b = 0; b < l.length; b++) {
      let w = l[b], g = this.getSimilarity(e, {
        border: t,
        shift: [s - w[0], o - w[1]]
      });
      r[w[0]][w[1]] = g;
    }
    let f = r.localMax(n, a);
    f.position[0] !== n || f.position[1] !== a ? (n = f.position[0], a = f.position[1]) : h = !0;
  }
  return [n - s, a - o];
}
function getRow(e, i = 0) {
  this.checkProcessable("getRow", {
    bitDepth: [8, 16]
  }), checkRow(this, e), checkChannel(this, i);
  let t = new Array(this.width), r = 0, n = e * this.width * this.channels + i, a = n + this.width * this.channels;
  for (let s = n; s < a; s += this.channels)
    t[r++] = this.data[s];
  return t;
}
function getColumn(e, i = 0) {
  this.checkProcessable("getColumn", {
    bitDepth: [8, 16]
  }), checkColumn(this, e), checkChannel(this, i);
  let t = new Array(this.height), r = 0, n = this.width * this.channels;
  for (let a = i + e * this.channels; a < this.data.length; a += n)
    t[r++] = this.data[a];
  return t;
}
function getMatrix(e = {}) {
  let { channel: i } = e;
  if (this.checkProcessable("getMatrix", {
    bitDepth: [8, 16]
  }), i === void 0) {
    if (this.components > 1)
      throw new RangeError(
        "You need to define the channel for an image that contains more than one channel"
      );
    i = 0;
  }
  let t = new Matrix$1(this.height, this.width);
  for (let r = 0; r < this.height; r++)
    for (let n = 0; n < this.width; n++)
      t.set(r, n, this.getValueXY(n, r, i));
  return t;
}
function setMatrix(e, i = {}) {
  e = new Matrix$1(e);
  let { channel: t } = i;
  if (this.checkProcessable("getMatrix", {
    bitDepth: [8, 16]
  }), t === void 0) {
    if (this.components > 1)
      throw new RangeError(
        "You need to define the channel for an image that contains more than one channel"
      );
    t = 0;
  }
  if (this.width !== e.columns || this.height !== e.rows)
    throw new RangeError(
      "The size of the matrix must be equal to the size of the image"
    );
  for (let r = 0; r < this.height; r++)
    for (let n = 0; n < this.width; n++)
      this.setValueXY(n, r, t, e.get(r, n));
  return this;
}
function getPixelsArray() {
  this.checkProcessable("getPixelsArray", {
    bitDepth: [8, 16, 32]
  });
  let e = new Array(this.size), i = 0;
  for (let t = 0; t < this.data.length; t += this.channels) {
    let r = new Array(this.components);
    for (let n = 0; n < this.components; n++)
      r[n] = this.data[t + n];
    e[i++] = r;
  }
  return e;
}
function getIntersection(e) {
  let i = this, t = i.getClosestCommonParent(e), r = i.getRelativePosition(t, {
    defaultFurther: !0
  }), n = getRelativePositionForAllPixels(i, r), a = e.getRelativePosition(t, {
    defaultFurther: !0
  }), s = getRelativePositionForAllPixels(e, a), o = getCommonSurface(n, s), h = {
    whitePixelsMask1: [],
    whitePixelsMask2: [],
    commonWhitePixels: []
  };
  for (let l = 0; l < o.length; l++) {
    let f = o[l], b = [
      f[0] - r[0],
      f[1] - r[1]
    ], w = [
      f[0] - a[0],
      f[1] - a[1]
    ], g = i.getBitXY(b[0], b[1]), E = e.getBitXY(w[0], w[1]);
    g === 1 && E === 1 && h.commonWhitePixels.push(f);
  }
  for (let l = 0; l < n.length; l++) {
    let f, b;
    l !== 0 && (f = Math.floor(l / i.width), b = l % i.width), i.getBitXY(f, b) === 1 && h.whitePixelsMask1.push(n[l]);
  }
  for (let l = 0; l < s.length; l++) {
    let f = 0, b = 0;
    l !== 0 && (f = Math.floor(l / e.width), b = l % e.width), e.getBitXY(f, b) === 1 && h.whitePixelsMask2.push(s[l]);
  }
  return h;
}
function getRelativePositionForAllPixels(e, i) {
  let t = [];
  for (let r = 0; r < e.height; r++)
    for (let n = 0; n < e.width; n++) {
      let a = [r, n];
      t.push([
        a[0] + i[0],
        a[1] + i[1]
      ]);
    }
  return t;
}
function getCommonSurface(e, i) {
  let t = 0, r = 0, n = [];
  for (; t < e.length && r < i.length; )
    e[t][0] === i[r][0] && e[t][1] === i[r][1] ? (n.push(e[t]), t++, r++) : e[t][0] < i[r][0] || e[t][0] === i[r][0] && e[t][1] < i[r][1] ? t++ : r++;
  return n;
}
function getClosestCommonParent(e) {
  let i = getDepth(this), t = getDepth(e), r;
  if (i >= t ? r = getFurthestParent(this, i) : r = getFurthestParent(e, t), i === 0 || t === 0)
    return r;
  let n = this, a = e;
  for (; i !== t; )
    if (i > t) {
      if (n = n.parent, n === null)
        return r;
      i = i - 1;
    } else {
      if (a = a.parent, a === null)
        return r;
      t = t - 1;
    }
  for (; n !== a && n !== null && a !== null; )
    if (n = n.parent, a = a.parent, n === null || a === null)
      return r;
  return n !== a ? r : n;
}
function getDepth(e) {
  let i = 0, t = e;
  for (; t.parent != null; )
    t = t.parent, i++;
  return i;
}
function getFurthestParent(e, i) {
  let t = e;
  for (; i > 0; )
    t = t.parent, i = i - 1;
  return t;
}
const defaultOptions$1 = {
  lowThreshold: 10,
  highThreshold: 30,
  gaussianBlur: 1.1
}, Gx = [
  [-1, 0, 1],
  [-2, 0, 2],
  [-1, 0, 1]
], Gy = [
  [-1, -2, -1],
  [0, 0, 0],
  [1, 2, 1]
], convOptions = {
  bitDepth: 32,
  mode: "periodic"
};
function cannyEdgeDetector(e, i) {
  e.checkProcessable("Canny edge detector", {
    bitDepth: 8,
    channels: 1,
    components: 1
  }), i = Object.assign({}, defaultOptions$1, i);
  const t = e.width, r = e.height, n = e.maxValue, a = {
    sigma: i.gaussianBlur,
    radius: 3
  }, s = e.gaussianFilter(a), o = s.convolution(Gy, convOptions), h = s.convolution(Gx, convOptions), l = h.hypotenuse(o), f = e.constructor, b = new f(t, r, {
    kind: "GREY",
    bitDepth: 32
  }), w = new f(t, r, {
    kind: "GREY",
    bitDepth: 32
  }), g = new f(t, r, {
    kind: "GREY"
  });
  for (var E = 1; E < t - 1; E++)
    for (var k = 1; k < r - 1; k++) {
      var A = (Math.round(Math.atan2(h.getValueXY(E, k, 0), o.getValueXY(E, k, 0)) * (5 / Math.PI)) + 5) % 5;
      A === 0 && (l.getValueXY(E, k, 0) <= l.getValueXY(E, k - 1, 0) || l.getValueXY(E, k, 0) <= l.getValueXY(E, k + 1, 0)) || A === 1 && (l.getValueXY(E, k, 0) <= l.getValueXY(E - 1, k + 1, 0) || l.getValueXY(E, k, 0) <= l.getValueXY(E + 1, k - 1, 0)) || A === 2 && (l.getValueXY(E, k, 0) <= l.getValueXY(E - 1, k, 0) || l.getValueXY(E, k, 0) <= l.getValueXY(E + 1, k, 0)) || A === 3 && (l.getValueXY(E, k, 0) <= l.getValueXY(E - 1, k - 1, 0) || l.getValueXY(E, k, 0) <= l.getValueXY(E + 1, k + 1, 0)) || b.setValueXY(E, k, 0, l.getValueXY(E, k, 0));
    }
  for (E = 0; E < t * r; ++E) {
    var T = b.data[E], C = 0;
    T > i.highThreshold && (C++, g.data[E] = n), T > i.lowThreshold && C++, w.data[E] = C;
  }
  var D = [];
  for (E = 1; E < t - 1; ++E)
    for (k = 1; k < r - 1; ++k)
      if (w.getValueXY(E, k, 0) === 1) {
        e: for (var $ = E - 1; $ < E + 2; ++$)
          for (var P = k - 1; P < k + 2; ++P)
            if (w.getValueXY($, P, 0) === 2) {
              D.push([E, k]), g.setValueXY(E, k, 0, n);
              break e;
            }
      }
  for (; D.length > 0; ) {
    var z = [];
    for (E = 0; E < D.length; ++E)
      for (k = -1; k < 2; ++k)
        for ($ = -1; $ < 2; ++$)
          if (!(k === 0 && $ === 0)) {
            var B = D[E][0] + k, F = D[E][1] + $;
            w.getValueXY(B, F, 0) === 1 && g.getValueXY(B, F, 0) === 0 && (z.push([B, F]), g.setValueXY(B, F, 0, n));
          }
    D = z;
  }
  return g;
}
function cannyEdge(e) {
  return cannyEdgeDetector(this, e);
}
function extract(e, i = {}) {
  let { position: t } = i;
  if (this.checkProcessable("extract", {
    bitDepth: [1, 8, 16]
  }), !t && (t = e.getRelativePosition(this), !t))
    throw new Error(
      "extract : can not extract an image because the relative position can not be determined, try to specify manually the position as an array of 2 elements [x,y]."
    );
  if (this.bitDepth > 1) {
    let r = Image.createFrom(this, {
      width: e.width,
      height: e.height,
      alpha: 1,
      // we force the alpha, otherwise difficult to extract a mask ...
      position: t,
      parent: this
    });
    for (let n = 0; n < e.width; n++)
      for (let a = 0; a < e.height; a++) {
        for (let s = 0; s < this.channels; s++) {
          let o = this.getValueXY(
            n + t[0],
            a + t[1],
            s
          );
          r.setValueXY(n, a, s, o);
        }
        e.getBitXY(n, a) || r.setValueXY(n, a, this.components, 0);
      }
    return r;
  } else {
    let r = Image.createFrom(this, {
      width: e.width,
      height: e.height,
      position: t,
      parent: this
    });
    for (let n = 0; n < e.height; n++)
      for (let a = 0; a < e.width; a++)
        e.getBitXY(a, n) && this.getBitXY(a + t[0], n + t[1]) && r.setBitXY(a, n);
    return r;
  }
}
var fastList = { exports: {} }, hasRequiredFastList;
function requireFastList() {
  return hasRequiredFastList || (hasRequiredFastList = 1, function(e, i) {
    (function() {
      function t(n, a, s) {
        this.next = s, s && (s.prev = this), this.prev = a, a && (a.next = this), this.data = n;
      }
      function r() {
        if (!(this instanceof r)) return new r();
        this._head = null, this._tail = null, this.length = 0;
      }
      r.prototype = {
        push: function(n) {
          this._tail = new t(n, this._tail, null), this._head || (this._head = this._tail), this.length++;
        },
        pop: function() {
          if (this.length !== 0) {
            var n = this._tail;
            return this._tail = n.prev, n.prev && (n.prev = this._tail.next = null), this.length--, this.length === 1 ? this._head = this._tail : this.length === 0 && (this._head = this._tail = null), n.data;
          }
        },
        unshift: function(n) {
          this._head = new t(n, null, this._head), this._tail || (this._tail = this._head), this.length++;
        },
        shift: function() {
          if (this.length !== 0) {
            var n = this._head;
            return this._head = n.next, n.next && (n.next = this._head.prev = null), this.length--, this.length === 1 ? this._tail = this._head : this.length === 0 && (this._head = this._tail = null), n.data;
          }
        },
        item: function(n) {
          n < 0 && (n = this.length + n);
          for (var a = this._head; n-- > 0 && a; ) a = a.next;
          return a ? a.data : void 0;
        },
        slice: function(n, a) {
          if (n || (n = 0), a || (a = this.length), a < 0 && (a = this.length + a), n < 0 && (n = this.length + n), a === n)
            return [];
          if (a < n)
            throw new Error("invalid offset: " + n + "," + a + " (length=" + this.length + ")");
          for (var s = a - n, o = new Array(s), h = 0, l = this._head; n-- > 0 && l; ) l = l.next;
          for (; h < s && l; )
            o[h++] = l.data, l = l.next;
          return o;
        },
        drop: function() {
          r.call(this);
        },
        forEach: function(n, a) {
          for (var s = this._head, o = 0, h = this.length; o < h && s; )
            n.call(a || this, s.data, o, this), s = s.next, o++;
        },
        map: function(n, a) {
          var s = new r();
          return this.forEach(function(o, h, l) {
            s.push(n.call(a || l, o, h, l));
          }), s;
        },
        filter: function(n, a) {
          var s = new r();
          return this.forEach(function(o, h, l) {
            n.call(a || l, o, h, l) && s.push(o);
          }), s;
        },
        reduce: function(n, a, s) {
          var o = 0, h = this._head, l = this.length;
          for (a || (o = 1, a = h && h.data, h = h && h.next); o < l && h; )
            a = n.call(s || this, a, h.data, this), o++, h = h.next;
          return a;
        }
      }, e.exports = r;
    })();
  }(fastList)), fastList.exports;
}
var fastListExports = requireFastList();
const LinkedList = /* @__PURE__ */ getDefaultExportFromCjs(fastListExports);
function floodFill(e = {}) {
  const { x: i = 0, y: t = 0, inPlace: r = !0 } = e, n = r ? this : Image.createFrom(this);
  if (this.checkProcessable("floodFill", { bitDepth: 1 }), this.getBitXY(i, t)) return n;
  const s = new LinkedList();
  for (s.push(new Node(i, t)); s.length > 0; ) {
    const o = s.shift();
    n.setBitXY(o.x, o.y);
    for (let h = o.x + 1; h < this.width && (!n.getBitXY(h, o.y) && !this.getBitXY(h, o.y)); h++)
      n.setBitXY(h, o.y), o.y + 1 < this.height && !this.getBitXY(h, o.y + 1) && s.push(new Node(h, o.y + 1)), o.y - 1 >= 0 && !this.getBitXY(h, o.y - 1) && s.push(new Node(h, o.y - 1));
    for (let h = o.x - 1; h >= 0 && (!n.getBitXY(h, o.y) && !this.getBitXY(h, o.y)); h++)
      n.setBitXY(h, o.y), o.y + 1 < this.height && !this.getBitXY(h, o.y + 1) && s.push(new Node(h, o.y + 1)), o.y - 1 >= 0 && !this.getBitXY(h, o.y - 1) && s.push(new Node(h, o.y - 1));
  }
  return n;
}
function Node(e, i) {
  this.x = e, this.y = i;
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(e) {
    for (var i = 1; i < arguments.length; i++) {
      var t = arguments[i];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (e[r] = t[r]);
    }
    return e;
  }, _extends.apply(null, arguments);
}
function hsv2rgb(e, i, t) {
  i = i / 100, t = t / 100;
  var r = [], n = t * i, a = e / 60, s = n * (1 - Math.abs(a % 2 - 1)), o = t - n;
  return a >= 0 && a < 1 ? r = [n, s, 0] : a >= 1 && a < 2 ? r = [s, n, 0] : a >= 2 && a < 3 ? r = [0, n, s] : e >= 3 && a < 4 ? r = [0, s, n] : e >= 4 && a < 5 ? r = [s, 0, n] : e >= 5 && a <= 6 ? r = [n, 0, s] : r = [0, 0, 0], {
    r: Math.round(255 * (r[0] + o)),
    g: Math.round(255 * (r[1] + o)),
    b: Math.round(255 * (r[2] + o))
  };
}
function hsl2hsv(e, i, t) {
  return i *= (t < 50 ? t : 100 - t) / 100, {
    h: e,
    s: 2 * i / (t + i) * 100,
    v: t + i
  };
}
function hsl2rgb$1(e, i, t) {
  var r = hsl2hsv(e, i, t);
  return hsv2rgb(r.h, r.s, r.v);
}
var colors = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 132, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 255, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 203],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [119, 128, 144],
  slategrey: [119, 128, 144],
  snow: [255, 255, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 5]
};
function parse(e) {
  return named(e) || hex3(e) || hex6(e) || rgb(e) || rgba$1(e) || hsl(e) || hsla(e);
}
function named(e) {
  var i = colors[e.toLowerCase()];
  if (i)
    return {
      r: i[0],
      g: i[1],
      b: i[2],
      a: 100
    };
}
function rgb(e) {
  var i = e.match(/rgb\(([^)]+)\)/);
  if (i) {
    var t = i[1].split(/ *, */).map(Number);
    return {
      r: t[0],
      g: t[1],
      b: t[2],
      a: 100
    };
  }
}
function rgba$1(e) {
  var i = e.match(/rgba\(([^)]+)\)/);
  if (i) {
    var t = i[1].split(/ *, */).map(Number);
    return {
      r: t[0],
      g: t[1],
      b: t[2],
      a: t[3] * 100
    };
  }
}
function hex6(e) {
  if (e[0] === "#" && e.length === 7)
    return {
      r: parseInt(e.slice(1, 3), 16),
      g: parseInt(e.slice(3, 5), 16),
      b: parseInt(e.slice(5, 7), 16),
      a: 100
    };
}
function hex3(e) {
  if (e[0] === "#" && e.length === 4)
    return {
      r: parseInt(e[1] + e[1], 16),
      g: parseInt(e[2] + e[2], 16),
      b: parseInt(e[3] + e[3], 16),
      a: 100
    };
}
function hsl(e) {
  var i = e.match(/hsl\(([^)]+)\)/);
  if (i) {
    var t = i[1].split(/ *, */), r = parseInt(t[0], 10), n = parseInt(t[1], 10), a = parseInt(t[2], 10), s = hsl2rgb$1(r, n, a);
    return _extends({}, s, {
      a: 100
    });
  }
}
function hsla(e) {
  var i = e.match(/hsla\(([^)]+)\)/);
  if (i) {
    var t = i[1].split(/ *, */), r = parseInt(t[0], 10), n = parseInt(t[1], 10), a = parseInt(t[2], 10), s = parseInt(parseFloat(t[3]) * 100, 10), o = hsl2rgb$1(r, n, a);
    return _extends({}, o, {
      a: s
    });
  }
}
function css2array(e) {
  let i = parse(e);
  return [i.r, i.g, i.b, Math.round(i.a * 255 / 100)];
}
function hue2rgb(e, i, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? e + (i - e) * 6 * t : t < 1 / 2 ? i : t < 2 / 3 ? e + (i - e) * (2 / 3 - t) * 6 : e;
}
function hsl2rgb(e, i, t) {
  let r, n, a, s, o, h;
  return i /= 100, t /= 100, i === 0 ? s = o = h = t * 255 : (t <= 0.5 ? n = t * (i + 1) : n = t + i - t * i, r = t * 2 - n, a = e / 360, s = hue2rgb(r, n, a + 1 / 3), o = hue2rgb(r, n, a), h = hue2rgb(r, n, a - 1 / 3)), { r: s, g: o, b: h };
}
function getDistinctColors(e) {
  let i = new Array(e), t = 0;
  for (let r = 0; r < 360; r += 360 / e) {
    t++;
    let n = hsl2rgb(r, 100, 30 + t % 4 * 15);
    i[t - 1] = [
      Math.round(n.r * 255),
      Math.round(n.g * 255),
      Math.round(n.b * 255)
    ];
  }
  return i;
}
function getRandomColor() {
  return [
    Math.floor(Math.random() * 256),
    Math.floor(Math.random() * 256),
    Math.floor(Math.random() * 256)
  ];
}
function getColors(e) {
  let {
    color: i,
    colors: t,
    randomColors: r,
    // true / false
    numberColors: n = 50
  } = e;
  if (i && !Array.isArray(i) && (i = css2array(i)), i)
    return [i];
  if (t)
    return t = t.map(function(a) {
      return Array.isArray(a) ? a : css2array(a);
    }), t;
  if (r) {
    t = new Array(n);
    for (let a = 0; a < n; a++)
      t[a] = getRandomColor();
  }
  return getDistinctColors(n);
}
function paintLabels(e, i, t = {}) {
  let { color: r = "blue", colors: n, font: a = "12px Helvetica", rotate: s = 0 } = t;
  if (this.checkProcessable("paintMasks", {
    channels: [3, 4],
    bitDepth: [8, 16],
    colorModel: RGB$1
  }), !Array.isArray(e))
    throw Error("paintLabels: labels must be an array");
  if (!Array.isArray(i))
    throw Error("paintLabels: positions must be an array");
  if (r && !Array.isArray(r) && (r = css2array(r)), n ? n = n.map(function(l) {
    return Array.isArray(l) ? l : css2array(l);
  }) : n = [r], e.length !== i.length)
    throw Error(
      "paintLabels: positions and labels must be arrays from the same size"
    );
  Array.isArray(a) || (a = [a]), Array.isArray(s) || (s = [s]);
  let h = this.getCanvas().getContext("2d");
  for (let l = 0; l < e.length; l++) {
    h.save();
    let f = n[l % n.length];
    h.fillStyle = `rgba(${f[0]},${f[1]},${f[2]},${f[3] / this.maxValue})`, h.font = a[l % a.length];
    let b = i[l];
    h.translate(b[0], b[1]), h.rotate(s[l % s.length] / 180 * Math.PI), h.fillText(e[l], 0, 0), h.restore();
  }
  return this.data = Uint8Array.from(
    h.getImageData(0, 0, this.width, this.height).data
  ), this;
}
function paintMasks(e, i = {}) {
  let {
    alpha: t = 255,
    labels: r = [],
    labelsPosition: n = [],
    labelColor: a = "blue",
    labelFont: s = "12px Helvetica"
  } = i;
  this.checkProcessable("paintMasks", {
    channels: [3, 4],
    bitDepth: [8, 16],
    colorModel: RGB$1
  });
  let o = getColors(
    Object.assign({}, i, { numberColors: e.length })
  );
  Array.isArray(e) || (e = [e]);
  for (let h = 0; h < e.length; h++) {
    let l = e[h], f = o[h % o.length];
    for (let b = 0; b < l.width; b++)
      for (let w = 0; w < l.height; w++)
        if (l.getBitXY(b, w))
          for (let g = 0; g < Math.min(this.components, f.length); g++)
            if (t === 255)
              this.setValueXY(
                b + l.position[0],
                w + l.position[1],
                g,
                f[g]
              );
            else {
              let E = this.getValueXY(
                b + l.position[0],
                w + l.position[1],
                g
              );
              E = Math.round(
                (E * (255 - t) + f[g] * t) / 255
              ), this.setValueXY(
                b + l.position[0],
                w + l.position[1],
                g,
                E
              );
            }
  }
  if (Array.isArray(r) && r.length > 0) {
    let l = this.getCanvas().getContext("2d");
    l.fillStyle = a, l.font = s;
    for (let f = 0; f < Math.min(e.length, r.length); f++) {
      let b = n[f] ? n[f] : e[f].position;
      l.fillText(r[f], b[0], b[1]);
    }
    this.data = Uint8Array.from(
      l.getImageData(0, 0, this.width, this.height).data
    );
  }
  return this;
}
function zerosMatrix(e, i) {
  let t = new Array(e);
  for (let r = 0; r < e; r++)
    t[r] = new Array(i).fill(0);
  return t;
}
const cross = [
  [0, 0, 1, 0, 0],
  [0, 0, 1, 0, 0],
  [1, 1, 1, 1, 1],
  [0, 0, 1, 0, 0],
  [0, 0, 1, 0, 0]
], smallCross = [
  [0, 1, 0],
  [1, 1, 1],
  [0, 1, 0]
];
class Shape {
  constructor(i = {}) {
    let { kind: t = "cross", shape: r, size: n, width: a, height: s, filled: o = !0 } = i;
    if (n && (a = n, s = n), r)
      switch (r.toLowerCase()) {
        case "square":
        case "rectangle":
          this.matrix = rectangle(a, s, { filled: o });
          break;
        case "circle":
        case "ellipse":
          this.matrix = ellipse(a, s, { filled: o });
          break;
        case "triangle":
          this.matrix = triangle(a, s, { filled: o });
          break;
        default:
          throw new Error(`Shape: unexpected shape: ${r}`);
      }
    else if (t)
      switch (t.toLowerCase()) {
        case "cross":
          this.matrix = cross;
          break;
        case "smallcross":
          this.matrix = smallCross;
          break;
        default:
          throw new Error(`Shape: unexpected kind: ${t}`);
      }
    else
      throw new Error("Shape: expected a kind or a shape option");
    this.height = this.matrix.length, this.width = this.matrix[0].length, this.halfHeight = this.height / 2 >> 0, this.halfWidth = this.width / 2 >> 0;
  }
  /**
   * Returns an array of [x,y] points
   * @return {Array<Array<number>>} - Array of [x,y] points
   */
  getPoints() {
    let i = this.matrix, t = [];
    for (let r = 0; r < i.length; r++)
      for (let n = 0; n < i[0].length; n++)
        i[r][n] && t.push([n - this.halfWidth, r - this.halfHeight]);
    return t;
  }
  /**
   * Returns a Mask (1 bit Image) corresponding to this shape.
   * @return {Image}
   */
  getMask() {
    let i = new Image(this.width, this.height, {
      kind: BINARY
    });
    for (let t = 0; t < this.matrix.length; t++)
      for (let r = 0; r < this.matrix[0].length; r++)
        this.matrix[t][r] && i.setBitXY(r, t);
    return i;
  }
}
function rectangle(e, i, t) {
  const r = zerosMatrix(i, e);
  if (t.filled)
    for (let n = 0; n < i; n++)
      for (let a = 0; a < e; a++)
        r[n][a] = 1;
  else {
    for (let n of [0, i - 1])
      for (let a = 0; a < e; a++)
        r[n][a] = 1;
    for (let n = 0; n < i; n++)
      for (let a of [0, e - 1])
        r[n][a] = 1;
  }
  return r;
}
function ellipse(e, i, t) {
  const r = zerosMatrix(i, e);
  let n = 1 - i % 2, a = 1 - e % 2, s = Math.floor((e - 1) / 2), o = Math.floor((i - 1) / 2), h = s * s, l = o * o;
  if (t.filled)
    for (let f = 0; f <= o; f++) {
      let b = Math.floor(Math.sqrt(h - h * f * f / l));
      for (let w = s - b; w <= s; w++)
        r[o - f][w] = 1, r[o + f + n][w] = 1, r[o - f][e - w - 1] = 1, r[o + f + n][e - w - 1] = 1;
    }
  else {
    for (let f = 0; f <= o; f++) {
      let b = Math.floor(Math.sqrt(h - h * f * f / l)), w = s - b;
      r[o - f][w] = 1, r[o + f + n][w] = 1, r[o - f][e - w - 1] = 1, r[o + f + n][e - w - 1] = 1;
    }
    for (let f = 0; f <= s; f++) {
      let b = Math.floor(Math.sqrt(l - l * f * f / h)), w = o - b;
      r[w][s - f] = 1, r[w][s + f + a] = 1, r[i - w - 1][s - f] = 1, r[i - w - 1][s + f + a] = 1;
    }
  }
  return r;
}
function triangle(e, i, t) {
  if (!t.filled)
    throw new Error("Non filled triangle is not implemented");
  const r = zerosMatrix(i, e);
  for (let n = 0; n < i; n++) {
    let a = Math.floor((1 - n / i) * e / 2);
    for (let s = a; s < e - a; s++)
      r[n][s] = 1;
  }
  return r;
}
function paintPoints(e, i = {}) {
  let { shape: t } = i;
  this.checkProcessable("paintPoints", {
    bitDepth: [8, 16]
  });
  let r = getColors(
    Object.assign({}, i, { numberColors: e.length })
  ), n = new Shape(t).getPoints(), a = Math.min(this.channels, r[0].length);
  for (let s = 0; s < e.length; s++) {
    let o = r[s % r.length], h = e[s][0], l = e[s][1];
    for (let f = 0; f < n.length; f++) {
      let b = n[f][0], w = n[f][1];
      if (h + b >= 0 && l + w >= 0 && h + b < this.width && l + w < this.height) {
        let g = (h + b + (l + w) * this.width) * this.channels;
        for (let E = 0; E < a; E++)
          this.data[g + E] = o[E];
      }
    }
  }
  return this;
}
function paintPolyline(e, i = {}) {
  let { color: t = [this.maxValue, 0, 0], closed: r = !1 } = i;
  this.checkProcessable("paintPoints", {
    bitDepth: [1, 8, 16]
  });
  let n = Math.min(this.channels, t.length);
  for (let a = 0; a < e.length - 1 + r; a++) {
    let s = e[a], o = e[(a + 1) % e.length], h = o[0] - s[0], l = o[1] - s[1], f = Math.max(Math.abs(h), Math.abs(l)), b = h / f, w = l / f, g = s[0], E = s[1];
    for (let k = 0; k <= f; k++) {
      let A = Math.round(g), T = Math.round(E);
      if (A >= 0 && T >= 0 && A < this.width && T < this.height)
        if (this.bitDepth === 1)
          this.setBitXY(A, T);
        else {
          let C = (A + T * this.width) * this.channels;
          for (let D = 0; D < n; D++)
            this.data[C + D] = t[D];
        }
      g = g + b, E = E + w;
    }
  }
  return this;
}
function paintPolylines(e, i = {}) {
  let t = Object.assign({}, i);
  this.checkProcessable("paintPolylines", {
    bitDepth: [8, 16]
  });
  let r = getColors(
    Object.assign({}, i, { numberColors: e.length })
  );
  for (let n = 0; n < e.length; n++)
    t.color = r[n % r.length], this.paintPolyline(e[n], t);
  return this;
}
function paintPolygon(e, i = {}) {
  let { color: t = [this.maxValue, 0, 0], filled: r = !1 } = i;
  this.checkProcessable("paintPoints", {
    bitDepth: [1, 8, 16]
  }), i.closed = !0;
  let n = deleteDouble(e);
  if (r === !1)
    return this.paintPolyline(e, i);
  {
    let a = Array(this.height);
    for (let s = 0; s < this.height; s++) {
      a[s] = [];
      for (let o = 0; o < this.width; o++)
        a[s].push(0);
    }
    for (let s = 0; s < n.length; s++) {
      const o = lineBetweenTwoPoints(
        n[s],
        n[(s + 1) % n.length]
      );
      for (let h = 0; h < this.height; h++)
        for (let l = 0; l < this.width; l++)
          isAtTheRightOfTheLine(l, h, o, this.height) && (a[h][l] = a[h][l] === 0 ? 1 : 0);
    }
    for (let s = 0; s < this.height; s++)
      for (let o = 0; o < this.width; o++)
        if (a[s][o] === 1)
          if (this.bitDepth === 1)
            this.setBitXY(o, s);
          else {
            let h = Math.min(this.channels, t.length), l = (o + s * this.width) * this.channels;
            for (let f = 0; f < h; f++)
              this.data[l + f] = t[f];
          }
    return this.paintPolyline(e, i);
  }
}
function deleteDouble(e) {
  let i = [];
  for (let t = 0; t < e.length; t++)
    if (!(e[t][0] === e[(t + 1) % e.length][0] && e[t][1] === e[(t + 1) % e.length][1])) {
      if (e[t][0] === e[(t - 1 + e.length) % e.length][0] && e[t][1] === e[(t - 1 + e.length) % e.length][1])
        continue;
      if (e[(t + 1) % e.length][0] === e[(t - 1 + e.length) % e.length][0] && e[(t - 1 + e.length) % e.length][1] === e[(t + 1) % e.length][1])
        continue;
      i.push(e[t]);
    }
  return i;
}
function lineBetweenTwoPoints(e, i) {
  if (e[0] === i[0])
    return { a: 0, b: e[0], vertical: !0 };
  {
    const t = (i[1] - e[1]) / (i[0] - e[0]), r = e[1] - t * e[0];
    return { a: t, b: r, vertical: !1 };
  }
}
function isAtTheRightOfTheLine(e, i, t, r) {
  if (t.vertical === !0)
    return t.b <= e;
  if (t.a === 0)
    return !1;
  {
    const n = (i - t.b) / t.a;
    return n < e && n >= 0 && n <= r;
  }
}
function paintPolygons(e, i = {}) {
  let t = Object.assign({}, i);
  this.checkProcessable("paintPolygons", {
    bitDepth: [8, 16]
  });
  let r = getColors(
    Object.assign({}, i, { numberColors: e.length })
  );
  for (let n = 0; n < e.length; n++)
    t.color = r[n % r.length], this.paintPolygon(e[n], t);
  return this;
}
function getHistogram(e = {}) {
  let { maxSlots: i = 256, channel: t, useAlpha: r = !0 } = e;
  if (this.checkProcessable("getHistogram", {
    bitDepth: [1, 8, 16]
  }), t === void 0) {
    if (this.components > 1)
      throw new RangeError(
        "You need to define the channel for an image that contains more than one channel"
      );
    t = 0;
  }
  return getChannelHistogram.call(this, t, { useAlpha: r, maxSlots: i });
}
function getHistograms(e = {}) {
  const { maxSlots: i = 256, useAlpha: t = !0 } = e;
  this.checkProcessable("getHistograms", {
    bitDepth: [8, 16]
  });
  let r = new Array(t ? this.components : this.channels);
  for (let n = 0; n < r.length; n++)
    r[n] = getChannelHistogram.call(this, n, { useAlpha: t, maxSlots: i });
  return r;
}
function getChannelHistogram(e, i) {
  let { useAlpha: t, maxSlots: r } = i;
  if (this.bitDepth === 1) {
    let h = [0, 0];
    for (let l = 0; l < this.height; l++)
      for (let f = 0; f < this.width; f++) {
        let b = this.getBitXY(l, f);
        b === 0 ? h[0] += 1 : b === 1 && (h[1] += 1);
      }
    return h;
  }
  let n = Math.log2(r);
  if (!isInteger(n))
    throw new RangeError(
      "maxSlots must be a power of 2, for example: 64, 256, 1024"
    );
  let a = 0;
  this.bitDepth > n && (a = this.bitDepth - n);
  let s = this.data, o = newArray(Math.pow(2, Math.min(this.bitDepth, n)), 0);
  if (t && this.alpha) {
    let h = this.channels - e - 1;
    for (let l = e; l < s.length; l += this.channels)
      o[s[l] >> a] += s[l + h] / this.maxValue;
  } else
    for (let h = e; h < s.length; h += this.channels)
      o[s[h] >> a]++;
  return o;
}
function getColorHistogram(e = {}) {
  let { useAlpha: i = !0, nbSlots: t = 512 } = e;
  this.checkProcessable("getColorHistogram", {
    bitDepth: [8, 16],
    components: [3]
  });
  let r = Math.log(t) / Math.log(8);
  if (r !== Math.floor(r))
    throw new RangeError(
      "nbSlots must be a power of 8. Usually 8, 64, 512 or 4096"
    );
  let n = this.bitDepth - r, a = this.data, s = newArray(Math.pow(8, r), 0), o = Math.pow(2, r * 2), h = Math.pow(2, r);
  for (let l = 0; l < a.length; l += this.channels) {
    let f = (a[l] >> n) * o + (a[l + 1] >> n) * h + (a[l + 2] >> n);
    i && this.alpha ? s[f] += a[l + this.channels - 1] / this.maxValue : s[f]++;
  }
  return s;
}
function min() {
  this.checkProcessable("min", {
    bitDepth: [8, 16, 32]
  });
  let e = newArray(this.channels, 1 / 0);
  for (let i = 0; i < this.data.length; i += this.channels)
    for (let t = 0; t < this.channels; t++)
      this.data[i + t] < e[t] && (e[t] = this.data[i + t]);
  return e;
}
function max() {
  this.checkProcessable("max", {
    bitDepth: [8, 16, 32]
  });
  let e = newArray(this.channels, -1 / 0);
  for (let i = 0; i < this.data.length; i += this.channels)
    for (let t = 0; t < this.channels; t++)
      this.data[i + t] > e[t] && (e[t] = this.data[i + t]);
  return e;
}
function sum() {
  this.checkProcessable("sum", {
    bitDepth: [8, 16]
  });
  let e = newArray(this.channels, 0);
  for (let i = 0; i < this.data.length; i += this.channels)
    for (let t = 0; t < this.channels; t++)
      e[t] += this.data[i + t];
  return e;
}
function getMoment(e = 0, i = 0) {
  this.checkProcessable("getMoment", {
    bitDepth: [1]
  });
  let t = 0;
  for (let r = 0; r < this.width; r++)
    for (let n = 0; n < this.height; n++)
      this.getBitXY(r, n) === 1 && (t += r ** e * n ** i);
  return t;
}
function localMaxima(e = {}) {
  let {
    mask: i,
    region: t = 3,
    removeClosePoints: r = 0,
    invert: n = !1,
    maxEquals: a = 2
  } = e, s = this;
  this.checkProcessable("localMaxima", {
    bitDepth: [8, 16],
    components: 1
  }), t *= 4;
  let o = n ? 0 : 1, h = [1, 0, -1, 0, 1, 1, -1, -1, 2, 0, -2, 0, 2, 2, -2, -2], l = [0, 1, 0, -1, 1, -1, 1, -1, 0, 2, 0, -2, 2, -2, 2, -2], f = t <= 8 ? 1 : 2, b = [];
  for (let w = f; w < s.height - f; w++)
    for (let g = f; g < s.width - f; g++) {
      if (i && i.getBitXY(g, w) !== o)
        continue;
      let E = 0, k = 0, A = s.data[g + w * s.width];
      for (let T = 0; T < t; T++)
        n ? s.data[g + h[T] + (w + l[T]) * s.width] > A && E++ : s.data[g + h[T] + (w + l[T]) * s.width] < A && E++, s.data[g + h[T] + (w + l[T]) * s.width] === A && k++;
      E + k === t && k <= a && b.push([g, w]);
    }
  if (r > 0)
    for (let w = 0; w < b.length; w++)
      for (let g = w + 1; g < b.length; g++)
        Math.sqrt(
          Math.pow(b[w][0] - b[g][0], 2) + Math.pow(b[w][1] - b[g][1], 2)
        ) < r && (b[w][0] = b[w][0] + b[g][0] >> 1, b[w][1] = b[w][1] + b[g][1] >> 1, b.splice(g, 1), g--);
  return b;
}
function mean() {
  let e = this.getHistograms({ maxSlots: this.maxValue + 1 }), i = new Array(e.length);
  for (let t = 0; t < e.length; t++) {
    let r = e[t];
    i[t] = mean$2(r);
  }
  return i;
}
function median() {
  let e = this.getHistograms({ maxSlots: this.maxValue + 1 }), i = new Array(e.length);
  for (let t = 0; t < e.length; t++) {
    let r = e[t];
    i[t] = median$2(r);
  }
  return i;
}
function points() {
  this.checkProcessable("points", {
    bitDepth: [1]
  });
  const e = [];
  for (let i = 0; i < this.width; i++)
    for (let t = 0; t < this.height; t++)
      this.getBitXY(i, t) === 1 && e.push([i, t]);
  return e;
}
function extendedPoints() {
  this.checkProcessable("extendedPoints", {
    bitDepth: [1]
  });
  const e = [];
  for (let i = 0; i < this.height; i++)
    for (let t = 0; t < this.width; t++)
      if (this.getBitXY(t, i) === 1)
        for (e.push([t, i]), this.getBitXY(t + 1, i) !== 1 ? (e.push([t + 1, i]), e.push([t + 1, i + 1]), this.getBitXY(t, i + 1) !== 1 && e.push([t, i + 1])) : this.getBitXY(t, i + 1) !== 1 && (e.push([t, i + 1]), e.push([t + 1, i + 1])); t < this.width - 2 && this.getBitXY(t + 1, i) === 1 && this.getBitXY(t + 2, i) === 1; )
          t++;
  return e;
}
function getRelativePosition(e, i = {}) {
  if (this === e)
    return [0, 0];
  let t = [0, 0], r = this;
  for (; r; ) {
    if (r === e)
      return t;
    r.position && (t[0] += r.position[0], t[1] += r.position[1]), r = r.parent;
  }
  return i.defaultFurther ? t : !1;
}
function countAlphaPixels(e = {}) {
  let { alpha: i = 1 } = e;
  this.checkProcessable("countAlphaPixels", {
    bitDepth: [8, 16],
    alpha: 1
  });
  let t = 0;
  if (i !== void 0) {
    for (let r = this.components; r < this.data.length; r += this.channels)
      this.data[r] === i && t++;
    return t;
  } else
    return this.size;
}
function monotoneChainConvexHull$1(e, i = {}) {
  const { sorted: t } = i;
  t || (e = e.slice().sort(byXThenY));
  const r = e.length, n = new Array(r * 2);
  let a = 0;
  for (let o = 0; o < r; o++) {
    const h = e[o];
    for (; a >= 2 && cw(n[a - 2], n[a - 1], h) <= 0; )
      a--;
    n[a++] = h;
  }
  const s = a + 1;
  for (let o = r - 2; o >= 0; o--) {
    const h = e[o];
    for (; a >= s && cw(n[a - 2], n[a - 1], h) <= 0; )
      a--;
    n[a++] = h;
  }
  return n.slice(0, a - 1);
}
function cw(e, i, t) {
  return (i[1] - e[1]) * (t[0] - e[0]) - (i[0] - e[0]) * (t[1] - e[1]);
}
function byXThenY(e, i) {
  return e[0] === i[0] ? e[1] - i[1] : e[0] - i[0];
}
function monotoneChainConvexHull() {
  return monotoneChainConvexHull$1(this.extendedPoints, { sorted: !1 });
}
function round(e) {
  for (let i = 0; i < e.length; i++)
    e[i][0] = Math.round(e[i][0]), e[i][1] = Math.round(e[i][1]);
  return e;
}
function difference(e, i) {
  return [e[0] - i[0], e[1] - i[1]];
}
function normalize(e) {
  let i = Math.sqrt(e[0] ** 2 + e[1] ** 2);
  return [e[0] / i, e[1] / i];
}
function rotate(e, i, t) {
  t === void 0 && (t = new Array(i.length));
  let r = Math.cos(e), n = Math.sin(e);
  for (let a = 0; a < t.length; ++a)
    t[a] = [
      r * i[a][0] - n * i[a][1],
      n * i[a][0] + r * i[a][1]
    ];
  return t;
}
function perimeter(e) {
  let i = 0;
  for (let t = 0; t < e.length; t++) {
    let r = e[t][0], n = e[t][1], a = e[t === e.length - 1 ? 0 : t + 1][0], s = e[t === e.length - 1 ? 0 : t + 1][1];
    i += Math.sqrt((a - r) ** 2 + (s - n) ** 2);
  }
  return i;
}
function surface(e) {
  let i = 0;
  for (let t = 0; t < e.length; t++) {
    let r = e[t][0], n = e[t === e.length - 1 ? 0 : t + 1][1], a = e[t === e.length - 1 ? 0 : t + 1][0], s = e[t][1];
    i += r * n * 0.5, i -= a * s * 0.5;
  }
  return Math.abs(i);
}
function minMax(e) {
  let i = 1 / 0, t = 1 / 0, r = -1 / 0, n = -1 / 0;
  for (let a = 0; a < e.length; a++)
    e[a][0] < i && (i = e[a][0]), e[a][0] > r && (r = e[a][0]), e[a][1] < t && (t = e[a][1]), e[a][1] > n && (n = e[a][1]);
  return [
    [i, t],
    [r, n]
  ];
}
function moveToZeroZero(e, i) {
  i === void 0 && (i = new Array(e.length).fill(0).map(() => []));
  let t = minMax(e), r = t[0][0], n = t[0][1];
  for (let a = 0; a < e.length; a++)
    i[a][0] = e[a][0] - r, i[a][1] = e[a][1] - n;
  return i;
}
function minimalBoundingRectangle(e = {}) {
  const { originalPoints: i = monotoneChainConvexHull.call(this) } = e;
  if (i.length === 0)
    return [];
  if (i.length === 1)
    return [
      i[0],
      i[0],
      i[0],
      i[0]
    ];
  const t = new Array(i.length);
  let r = 1 / 0, n = 0, a;
  for (let s = 0; s < t.length; s++) {
    let o = getAngle$1(i[s], i[(s + 1) % t.length]);
    rotate(-o, i, t);
    let h = t[s][0], l = t[s][1], f = t[(s + 1) % t.length][0], b = t[(s + 1) % t.length][1], w = !0, g = 0, E = 0, k = 0;
    for (let D = 0; D < t.length; D++) {
      let $ = t[D][0], P = t[D][1], z = ($ - h) / (f - h);
      w === !0 ? (w = !1, g = z, E = z) : (z < g && (g = z), z > E && (E = z));
      let B = (-(f - h) * P + f * l - b * h) / (f - h);
      Math.abs(B) > Math.abs(k) && (k = B);
    }
    let A = [h + g * (f - h), l], T = [h + E * (f - h), l], C = Math.abs(k * (g - E) * (f - h));
    C < r && (n = o, r = C, a = [
      A,
      T,
      [T[0], T[1] - k],
      [A[0], A[1] - k]
    ]);
  }
  return rotate(n, a, a), a;
}
function getAngle$1(e, i) {
  let t = difference(i, e), r = normalize(t), n = Math.acos(r[0]);
  return r[1] < 0 ? -n : n;
}
function extend$1(e) {
  let i = { inPlace: !0 };
  e.extendMethod("invert", invert), e.extendMethod("abs", abs), e.extendMethod("level", level, i), e.extendMethod("add", add, i), e.extendMethod("subtract", subtract, i), e.extendMethod("subtractImage", subtractImage), e.extendMethod("multiply", multiply, i), e.extendMethod("divide", divide, i), e.extendMethod("hypotenuse", hypotenuse), e.extendMethod("background", background$1), e.extendMethod("flipX", flipX), e.extendMethod("flipY", flipY), e.extendMethod("blurFilter", blurFilter), e.extendMethod("medianFilter", medianFilter), e.extendMethod("gaussianFilter", gaussianFilter), e.extendMethod("sobelFilter", sobelFilter), e.extendMethod("gradientFilter", gradientFilter), e.extendMethod("scharrFilter", scharrFilter), e.extendMethod("dilate", dilate), e.extendMethod("erode", erode), e.extendMethod("open", open), e.extendMethod("close", close), e.extendMethod("topHat", topHat), e.extendMethod("blackHat", blackHat), e.extendMethod("morphologicalGradient", morphologicalGradient), e.extendMethod("warpingFourPoints", warpingFourPoints), e.extendMethod("crop", crop), e.extendMethod("cropAlpha", cropAlpha), e.extendMethod("resize", resize).extendMethod("scale", resize), e.extendMethod("hsv", hsv), e.extendMethod("hsl", hsl$1), e.extendMethod("cmyk", cmyk), e.extendMethod("rgba8", rgba8), e.extendMethod("grey", grey).extendMethod("gray", grey), e.extendMethod("mask", mask), e.extendMethod("pad", pad), e.extendMethod("colorDepth", colorDepth), e.extendMethod("setBorder", setBorder, i), e.extendMethod("rotate", rotate$1), e.extendMethod("rotateLeft", rotateLeft), e.extendMethod("rotateRight", rotateRight), e.extendMethod("insert", insert), e.extendMethod("getRow", getRow), e.extendMethod("getColumn", getColumn), e.extendMethod("getMatrix", getMatrix), e.extendMethod("setMatrix", setMatrix), e.extendMethod("getPixelsArray", getPixelsArray), e.extendMethod("getIntersection", getIntersection), e.extendMethod("getClosestCommonParent", getClosestCommonParent), e.extendMethod("getThreshold", getThreshold), e.extendMethod("split", split), e.extendMethod("getChannel", getChannel), e.extendMethod("combineChannels", combineChannels), e.extendMethod("setChannel", setChannel), e.extendMethod("getSimilarity", getSimilarity), e.extendMethod("getPixelsGrid", getPixelsGrid), e.extendMethod("getBestMatch", getBestMatch), e.extendMethod("cannyEdge", cannyEdge), e.extendMethod("convolution", convolution), e.extendMethod("extract", extract), e.extendMethod("floodFill", floodFill), e.extendMethod("paintLabels", paintLabels, i), e.extendMethod("paintMasks", paintMasks, i), e.extendMethod("paintPoints", paintPoints, i), e.extendMethod("paintPolyline", paintPolyline, i), e.extendMethod("paintPolylines", paintPolylines, i), e.extendMethod("paintPolygon", paintPolygon, i), e.extendMethod("paintPolygons", paintPolygons, i), e.extendMethod("countAlphaPixels", countAlphaPixels), e.extendMethod("monotoneChainConvexHull", monotoneChainConvexHull), e.extendMethod("minimalBoundingRectangle", minimalBoundingRectangle), e.extendMethod("getHistogram", getHistogram).extendProperty(
    "histogram",
    getHistogram
  ), e.extendMethod("getHistograms", getHistograms).extendProperty(
    "histograms",
    getHistograms
  ), e.extendMethod("getColorHistogram", getColorHistogram).extendProperty(
    "colorHistogram",
    getColorHistogram
  ), e.extendMethod("getMin", min).extendProperty("min", min), e.extendMethod("getMax", max).extendProperty("max", max), e.extendMethod("getSum", sum).extendProperty("sum", sum), e.extendMethod("getMoment", getMoment).extendProperty(
    "moment",
    getMoment
  ), e.extendMethod("getLocalMaxima", localMaxima), e.extendMethod("getMedian", median).extendProperty(
    "median",
    median
  ), e.extendMethod("getMean", mean).extendProperty("mean", mean), e.extendMethod("getPoints", points).extendProperty(
    "points",
    points
  ), e.extendMethod("getExtendedPoints", extendedPoints).extendProperty(
    "extendedPoints",
    extendedPoints
  ), e.extendMethod("getRelativePosition", getRelativePosition);
}
var quantities$1 = { exports: {} }, quantities = quantities$1.exports, hasRequiredQuantities;
function requireQuantities() {
  return hasRequiredQuantities || (hasRequiredQuantities = 1, function(e, i) {
    (function(t, r) {
      e.exports = r();
    })(quantities, function() {
      function t(M) {
        return typeof M == "string" || M instanceof String;
      }
      var r = Number.isFinite || window.isFinite;
      function n(M) {
        return r(M);
      }
      function a(M) {
        return M;
      }
      function s(M) {
        var _ = {};
        return M.filter(function(d) {
          return _.hasOwnProperty(d) ? !1 : _[d] = !0;
        });
      }
      function o(M, _) {
        if (_.length !== M.length)
          return !1;
        for (var d = 0; d < M.length; d++)
          if (_[d].compareArray && !_[d].compareArray(M[d]) || _[d] !== M[d])
            return !1;
        return !0;
      }
      function h(M, _) {
        Object.keys(_).forEach(function(d) {
          M[d] = _[d];
        });
      }
      function l() {
        for (var M = 1, _ = 0, d = 0; d < arguments.length; d++) {
          var u = arguments[d];
          _ = _ + w(u), M *= u;
        }
        return _ !== 0 ? b(M, _) : M;
      }
      function f(M, _) {
        if (_ === 0)
          throw new Error("Divide by zero");
        var d = Math.pow(10, w(_)), u = d / (d * _);
        return l(M, u);
      }
      function b(M, _) {
        return Math.round(M * Math.pow(10, _)) / Math.pow(10, _);
      }
      function w(M) {
        if (!isFinite(M))
          return 0;
        for (var _ = 0; M % 1 !== 0; )
          M *= 10, _++;
        return _;
      }
      function g() {
        var M;
        if (!this)
          return M = Object.create(g.prototype), g.apply(M, arguments), M;
        M = Error.apply(this, arguments), this.name = "QtyError", this.message = M.message, this.stack = M.stack;
      }
      g.prototype = Object.create(Error.prototype, { constructor: { value: g } });
      function E(M, _) {
        throw new g("Incompatible units: " + M + " and " + _);
      }
      var k = {
        /* prefixes */
        "<googol>": [["googol"], 1e100, "prefix"],
        "<kibi>": [["Ki", "Kibi", "kibi"], Math.pow(2, 10), "prefix"],
        "<mebi>": [["Mi", "Mebi", "mebi"], Math.pow(2, 20), "prefix"],
        "<gibi>": [["Gi", "Gibi", "gibi"], Math.pow(2, 30), "prefix"],
        "<tebi>": [["Ti", "Tebi", "tebi"], Math.pow(2, 40), "prefix"],
        "<pebi>": [["Pi", "Pebi", "pebi"], Math.pow(2, 50), "prefix"],
        "<exi>": [["Ei", "Exi", "exi"], Math.pow(2, 60), "prefix"],
        "<zebi>": [["Zi", "Zebi", "zebi"], Math.pow(2, 70), "prefix"],
        "<yebi>": [["Yi", "Yebi", "yebi"], Math.pow(2, 80), "prefix"],
        "<yotta>": [["Y", "Yotta", "yotta"], 1e24, "prefix"],
        "<zetta>": [["Z", "Zetta", "zetta"], 1e21, "prefix"],
        "<exa>": [["E", "Exa", "exa"], 1e18, "prefix"],
        "<peta>": [["P", "Peta", "peta"], 1e15, "prefix"],
        "<tera>": [["T", "Tera", "tera"], 1e12, "prefix"],
        "<giga>": [["G", "Giga", "giga"], 1e9, "prefix"],
        "<mega>": [["M", "Mega", "mega"], 1e6, "prefix"],
        "<kilo>": [["k", "kilo"], 1e3, "prefix"],
        "<hecto>": [["h", "Hecto", "hecto"], 100, "prefix"],
        "<deca>": [["da", "Deca", "deca", "deka"], 10, "prefix"],
        "<deci>": [["d", "Deci", "deci"], 0.1, "prefix"],
        "<centi>": [["c", "Centi", "centi"], 0.01, "prefix"],
        "<milli>": [["m", "Milli", "milli"], 1e-3, "prefix"],
        "<micro>": [
          ["u", "", "", "Micro", "mc", "micro"],
          1e-6,
          "prefix"
        ],
        "<nano>": [["n", "Nano", "nano"], 1e-9, "prefix"],
        "<pico>": [["p", "Pico", "pico"], 1e-12, "prefix"],
        "<femto>": [["f", "Femto", "femto"], 1e-15, "prefix"],
        "<atto>": [["a", "Atto", "atto"], 1e-18, "prefix"],
        "<zepto>": [["z", "Zepto", "zepto"], 1e-21, "prefix"],
        "<yocto>": [["y", "Yocto", "yocto"], 1e-24, "prefix"],
        "<1>": [["1", "<1>"], 1, ""],
        /* length units */
        "<meter>": [["m", "meter", "meters", "metre", "metres"], 1, "length", ["<meter>"]],
        "<inch>": [["in", "inch", "inches", '"'], 0.0254, "length", ["<meter>"]],
        "<foot>": [["ft", "foot", "feet", "'"], 0.3048, "length", ["<meter>"]],
        "<yard>": [["yd", "yard", "yards"], 0.9144, "length", ["<meter>"]],
        "<mile>": [["mi", "mile", "miles"], 1609.344, "length", ["<meter>"]],
        "<naut-mile>": [["nmi", "naut-mile"], 1852, "length", ["<meter>"]],
        "<league>": [["league", "leagues"], 4828, "length", ["<meter>"]],
        "<furlong>": [["furlong", "furlongs"], 201.2, "length", ["<meter>"]],
        "<rod>": [["rd", "rod", "rods"], 5.029, "length", ["<meter>"]],
        "<mil>": [["mil", "mils"], 254e-7, "length", ["<meter>"]],
        "<angstrom>": [["ang", "angstrom", "angstroms"], 1e-10, "length", ["<meter>"]],
        "<fathom>": [["fathom", "fathoms"], 1.829, "length", ["<meter>"]],
        "<pica>": [["pica", "picas"], 0.00423333333, "length", ["<meter>"]],
        "<point>": [["pt", "point", "points"], 352777778e-12, "length", ["<meter>"]],
        "<redshift>": [["z", "red-shift", "redshift"], 1302773e20, "length", ["<meter>"]],
        "<AU>": [["AU", "astronomical-unit"], 1495979e5, "length", ["<meter>"]],
        "<light-second>": [["ls", "light-second"], 299792500, "length", ["<meter>"]],
        "<light-minute>": [["lmin", "light-minute"], 1798755e4, "length", ["<meter>"]],
        "<light-year>": [["ly", "light-year"], 9460528e9, "length", ["<meter>"]],
        "<parsec>": [["pc", "parsec", "parsecs"], 3085678e10, "length", ["<meter>"]],
        "<datamile>": [["DM", "datamile"], 1828.8, "length", ["<meter>"]],
        /* mass */
        "<kilogram>": [["kg", "kilogram", "kilograms"], 1, "mass", ["<kilogram>"]],
        "<AMU>": [["u", "AMU", "amu"], 1660538921e-36, "mass", ["<kilogram>"]],
        "<dalton>": [["Da", "Dalton", "Daltons", "dalton", "daltons"], 1660538921e-36, "mass", ["<kilogram>"]],
        "<slug>": [["slug", "slugs"], 14.5939029, "mass", ["<kilogram>"]],
        "<short-ton>": [["tn", "ton", "short-ton"], 907.18474, "mass", ["<kilogram>"]],
        "<metric-ton>": [["t", "tonne", "metric-ton"], 1e3, "mass", ["<kilogram>"]],
        "<carat>": [["ct", "carat", "carats"], 2e-4, "mass", ["<kilogram>"]],
        "<pound>": [["lbs", "lb", "pound", "pounds", "#"], 0.45359237, "mass", ["<kilogram>"]],
        "<ounce>": [["oz", "ounce", "ounces"], 0.0283495231, "mass", ["<kilogram>"]],
        "<gram>": [["g", "gram", "grams", "gramme", "grammes"], 1e-3, "mass", ["<kilogram>"]],
        "<grain>": [["grain", "grains", "gr"], 6479891e-11, "mass", ["<kilogram>"]],
        "<dram>": [["dram", "drams", "dr"], 0.0017718452, "mass", ["<kilogram>"]],
        "<stone>": [["stone", "stones", "st"], 6.35029318, "mass", ["<kilogram>"]],
        /* area */
        "<hectare>": [["hectare"], 1e4, "area", ["<meter>", "<meter>"]],
        "<acre>": [["acre", "acres"], 4046.85642, "area", ["<meter>", "<meter>"]],
        "<sqft>": [["sqft"], 1, "area", ["<foot>", "<foot>"]],
        /* volume */
        "<liter>": [["l", "L", "liter", "liters", "litre", "litres"], 1e-3, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<gallon>": [["gal", "gallon", "gallons"], 0.0037854118, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<gallon-imp>": [["galimp", "gallon-imp", "gallons-imp"], 454609e-8, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<quart>": [["qt", "quart", "quarts"], 94635295e-11, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<pint>": [["pt", "pint", "pints"], 473176475e-12, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<pint-imp>": [["ptimp", "pint-imp", "pints-imp"], 56826125e-11, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<cup>": [["cu", "cup", "cups"], 236588238e-12, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<fluid-ounce>": [["floz", "fluid-ounce", "fluid-ounces"], 295735297e-13, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<fluid-ounce-imp>": [["flozimp", "floz-imp", "fluid-ounce-imp", "fluid-ounces-imp"], 284130625e-13, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<tablespoon>": [["tb", "tbsp", "tbs", "tablespoon", "tablespoons"], 147867648e-13, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<teaspoon>": [["tsp", "teaspoon", "teaspoons"], 492892161e-14, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<bushel>": [["bu", "bsh", "bushel", "bushels"], 0.035239072, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<oilbarrel>": [["bbl", "oilbarrel", "oilbarrels", "oil-barrel", "oil-barrels"], 0.158987294928, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<beerbarrel>": [["bl", "bl-us", "beerbarrel", "beerbarrels", "beer-barrel", "beer-barrels"], 0.1173477658, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<beerbarrel-imp>": [["blimp", "bl-imp", "beerbarrel-imp", "beerbarrels-imp", "beer-barrel-imp", "beer-barrels-imp"], 0.16365924, "volume", ["<meter>", "<meter>", "<meter>"]],
        /* speed */
        "<kph>": [["kph"], 0.277777778, "speed", ["<meter>"], ["<second>"]],
        "<mph>": [["mph"], 0.44704, "speed", ["<meter>"], ["<second>"]],
        "<knot>": [["kt", "kn", "kts", "knot", "knots"], 0.514444444, "speed", ["<meter>"], ["<second>"]],
        "<fps>": [["fps"], 0.3048, "speed", ["<meter>"], ["<second>"]],
        /* acceleration */
        "<gee>": [["gee"], 9.80665, "acceleration", ["<meter>"], ["<second>", "<second>"]],
        "<Gal>": [["Gal"], 0.01, "acceleration", ["<meter>"], ["<second>", "<second>"]],
        /* temperature_difference */
        "<kelvin>": [["degK", "kelvin"], 1, "temperature", ["<kelvin>"]],
        "<celsius>": [["degC", "celsius", "celsius", "centigrade"], 1, "temperature", ["<kelvin>"]],
        "<fahrenheit>": [["degF", "fahrenheit"], 5 / 9, "temperature", ["<kelvin>"]],
        "<rankine>": [["degR", "rankine"], 5 / 9, "temperature", ["<kelvin>"]],
        "<temp-K>": [["tempK", "temp-K"], 1, "temperature", ["<temp-K>"]],
        "<temp-C>": [["tempC", "temp-C"], 1, "temperature", ["<temp-K>"]],
        "<temp-F>": [["tempF", "temp-F"], 5 / 9, "temperature", ["<temp-K>"]],
        "<temp-R>": [["tempR", "temp-R"], 5 / 9, "temperature", ["<temp-K>"]],
        /* time */
        "<second>": [["s", "sec", "secs", "second", "seconds"], 1, "time", ["<second>"]],
        "<minute>": [["min", "mins", "minute", "minutes"], 60, "time", ["<second>"]],
        "<hour>": [["h", "hr", "hrs", "hour", "hours"], 3600, "time", ["<second>"]],
        "<day>": [["d", "day", "days"], 3600 * 24, "time", ["<second>"]],
        "<week>": [["wk", "week", "weeks"], 7 * 3600 * 24, "time", ["<second>"]],
        "<fortnight>": [["fortnight", "fortnights"], 1209600, "time", ["<second>"]],
        "<year>": [["y", "yr", "year", "years", "annum"], 31556926, "time", ["<second>"]],
        "<decade>": [["decade", "decades"], 315569260, "time", ["<second>"]],
        "<century>": [["century", "centuries"], 3155692600, "time", ["<second>"]],
        /* pressure */
        "<pascal>": [["Pa", "pascal", "Pascal"], 1, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<bar>": [["bar", "bars"], 1e5, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<mmHg>": [["mmHg"], 133.322368, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<inHg>": [["inHg"], 3386.3881472, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<torr>": [["torr"], 133.322368, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<atm>": [["atm", "ATM", "atmosphere", "atmospheres"], 101325, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<psi>": [["psi"], 6894.76, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<cmh2o>": [["cmH2O", "cmh2o"], 98.0638, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<inh2o>": [["inH2O", "inh2o"], 249.082052, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        /* viscosity */
        "<poise>": [["P", "poise"], 0.1, "viscosity", ["<kilogram>"], ["<meter>", "<second>"]],
        "<stokes>": [["St", "stokes"], 1e-4, "viscosity", ["<meter>", "<meter>"], ["<second>"]],
        /* substance */
        "<mole>": [["mol", "mole"], 1, "substance", ["<mole>"]],
        /* molar_concentration */
        "<molar>": [["M", "molar"], 1e3, "molar_concentration", ["<mole>"], ["<meter>", "<meter>", "<meter>"]],
        "<wtpercent>": [["wt%", "wtpercent"], 10, "molar_concentration", ["<kilogram>"], ["<meter>", "<meter>", "<meter>"]],
        /* activity */
        "<katal>": [["kat", "katal", "Katal"], 1, "activity", ["<mole>"], ["<second>"]],
        "<unit>": [["U", "enzUnit", "unit"], 16667e-19, "activity", ["<mole>"], ["<second>"]],
        /* capacitance */
        "<farad>": [["F", "farad", "Farad"], 1, "capacitance", ["<second>", "<second>", "<second>", "<second>", "<ampere>", "<ampere>"], ["<meter>", "<meter>", "<kilogram>"]],
        /* charge */
        "<coulomb>": [["C", "coulomb", "Coulomb"], 1, "charge", ["<ampere>", "<second>"]],
        "<Ah>": [["Ah"], 3600, "charge", ["<ampere>", "<second>"]],
        /* current */
        "<ampere>": [["A", "Ampere", "ampere", "amp", "amps"], 1, "current", ["<ampere>"]],
        /* conductance */
        "<siemens>": [["S", "Siemens", "siemens"], 1, "conductance", ["<second>", "<second>", "<second>", "<ampere>", "<ampere>"], ["<kilogram>", "<meter>", "<meter>"]],
        /* inductance */
        "<henry>": [["H", "Henry", "henry"], 1, "inductance", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>", "<ampere>", "<ampere>"]],
        /* potential */
        "<volt>": [["V", "Volt", "volt", "volts"], 1, "potential", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>", "<second>", "<ampere>"]],
        /* resistance */
        "<ohm>": [
          [
            "Ohm",
            "ohm",
            "",
            ""
            /* as ohm sign*/
          ],
          1,
          "resistance",
          ["<meter>", "<meter>", "<kilogram>"],
          ["<second>", "<second>", "<second>", "<ampere>", "<ampere>"]
        ],
        /* magnetism */
        "<weber>": [["Wb", "weber", "webers"], 1, "magnetism", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>", "<ampere>"]],
        "<tesla>": [["T", "tesla", "teslas"], 1, "magnetism", ["<kilogram>"], ["<second>", "<second>", "<ampere>"]],
        "<gauss>": [["G", "gauss"], 1e-4, "magnetism", ["<kilogram>"], ["<second>", "<second>", "<ampere>"]],
        "<maxwell>": [["Mx", "maxwell", "maxwells"], 1e-8, "magnetism", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>", "<ampere>"]],
        "<oersted>": [["Oe", "oersted", "oersteds"], 250 / Math.PI, "magnetism", ["<ampere>"], ["<meter>"]],
        /* energy */
        "<joule>": [["J", "joule", "Joule", "joules", "Joules"], 1, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<erg>": [["erg", "ergs"], 1e-7, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<btu>": [["BTU", "btu", "BTUs"], 1055.056, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<calorie>": [["cal", "calorie", "calories"], 4.184, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<Calorie>": [["Cal", "Calorie", "Calories"], 4184, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<therm-US>": [["th", "therm", "therms", "Therm", "therm-US"], 105480400, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<Wh>": [["Wh"], 3600, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<electronvolt>": [["eV", "electronvolt", "electronvolts"], 1602176634e-28, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        /* force */
        "<newton>": [["N", "Newton", "newton"], 1, "force", ["<kilogram>", "<meter>"], ["<second>", "<second>"]],
        "<dyne>": [["dyn", "dyne"], 1e-5, "force", ["<kilogram>", "<meter>"], ["<second>", "<second>"]],
        "<pound-force>": [["lbf", "pound-force"], 4.448222, "force", ["<kilogram>", "<meter>"], ["<second>", "<second>"]],
        /* frequency */
        "<hertz>": [["Hz", "hertz", "Hertz"], 1, "frequency", ["<1>"], ["<second>"]],
        /* angle */
        "<radian>": [["rad", "radian", "radians"], 1, "angle", ["<radian>"]],
        "<degree>": [["deg", "degree", "degrees"], Math.PI / 180, "angle", ["<radian>"]],
        "<arcminute>": [["arcmin", "arcminute", "arcminutes"], Math.PI / 10800, "angle", ["<radian>"]],
        "<arcsecond>": [["arcsec", "arcsecond", "arcseconds"], Math.PI / 648e3, "angle", ["<radian>"]],
        "<gradian>": [["gon", "grad", "gradian", "grads"], Math.PI / 200, "angle", ["<radian>"]],
        "<steradian>": [["sr", "steradian", "steradians"], 1, "solid_angle", ["<steradian>"]],
        /* rotation */
        "<rotation>": [["rotation"], 2 * Math.PI, "angle", ["<radian>"]],
        "<rpm>": [["rpm"], 2 * Math.PI / 60, "angular_velocity", ["<radian>"], ["<second>"]],
        /* information */
        "<byte>": [["B", "byte", "bytes"], 1, "information", ["<byte>"]],
        "<bit>": [["b", "bit", "bits"], 0.125, "information", ["<byte>"]],
        /* information rate */
        "<Bps>": [["Bps"], 1, "information_rate", ["<byte>"], ["<second>"]],
        "<bps>": [["bps"], 0.125, "information_rate", ["<byte>"], ["<second>"]],
        /* currency */
        "<dollar>": [["USD", "dollar"], 1, "currency", ["<dollar>"]],
        "<cents>": [["cents"], 0.01, "currency", ["<dollar>"]],
        /* luminosity */
        "<candela>": [["cd", "candela"], 1, "luminosity", ["<candela>"]],
        "<lumen>": [["lm", "lumen"], 1, "luminous_power", ["<candela>", "<steradian>"]],
        "<lux>": [["lux"], 1, "illuminance", ["<candela>", "<steradian>"], ["<meter>", "<meter>"]],
        /* power */
        "<watt>": [["W", "watt", "watts"], 1, "power", ["<kilogram>", "<meter>", "<meter>"], ["<second>", "<second>", "<second>"]],
        "<volt-ampere>": [["VA", "volt-ampere"], 1, "power", ["<kilogram>", "<meter>", "<meter>"], ["<second>", "<second>", "<second>"]],
        "<volt-ampere-reactive>": [["var", "Var", "VAr", "VAR", "volt-ampere-reactive"], 1, "power", ["<kilogram>", "<meter>", "<meter>"], ["<second>", "<second>", "<second>"]],
        "<horsepower>": [["hp", "horsepower"], 745.699872, "power", ["<kilogram>", "<meter>", "<meter>"], ["<second>", "<second>", "<second>"]],
        /* radiation */
        "<gray>": [["Gy", "gray", "grays"], 1, "radiation", ["<meter>", "<meter>"], ["<second>", "<second>"]],
        "<roentgen>": [["R", "roentgen"], 933e-5, "radiation", ["<meter>", "<meter>"], ["<second>", "<second>"]],
        "<sievert>": [["Sv", "sievert", "sieverts"], 1, "radiation", ["<meter>", "<meter>"], ["<second>", "<second>"]],
        "<becquerel>": [["Bq", "becquerel", "becquerels"], 1, "radiation", ["<1>"], ["<second>"]],
        "<curie>": [["Ci", "curie", "curies"], 37e9, "radiation", ["<1>"], ["<second>"]],
        /* rate */
        "<cpm>": [["cpm"], 1 / 60, "rate", ["<count>"], ["<second>"]],
        "<dpm>": [["dpm"], 1 / 60, "rate", ["<count>"], ["<second>"]],
        "<bpm>": [["bpm"], 1 / 60, "rate", ["<count>"], ["<second>"]],
        /* resolution / typography */
        "<dot>": [["dot", "dots"], 1, "resolution", ["<each>"]],
        "<pixel>": [["pixel", "px"], 1, "resolution", ["<each>"]],
        "<ppi>": [["ppi"], 1, "resolution", ["<pixel>"], ["<inch>"]],
        "<dpi>": [["dpi"], 1, "typography", ["<dot>"], ["<inch>"]],
        /* other */
        "<cell>": [["cells", "cell"], 1, "counting", ["<each>"]],
        "<each>": [["each"], 1, "counting", ["<each>"]],
        "<count>": [["count"], 1, "counting", ["<each>"]],
        "<base-pair>": [["bp", "base-pair"], 1, "counting", ["<each>"]],
        "<nucleotide>": [["nt", "nucleotide"], 1, "counting", ["<each>"]],
        "<molecule>": [["molecule", "molecules"], 1, "counting", ["<1>"]],
        "<dozen>": [["doz", "dz", "dozen"], 12, "prefix_only", ["<each>"]],
        "<percent>": [["%", "percent"], 0.01, "prefix_only", ["<1>"]],
        "<ppm>": [["ppm"], 1e-6, "prefix_only", ["<1>"]],
        "<ppb>": [["ppb"], 1e-9, "prefix_only", ["<1>"]],
        "<ppt>": [["ppt"], 1e-12, "prefix_only", ["<1>"]],
        "<ppq>": [["ppq"], 1e-15, "prefix_only", ["<1>"]],
        "<gross>": [["gr", "gross"], 144, "prefix_only", ["<dozen>", "<dozen>"]],
        "<decibel>": [["dB", "decibel", "decibels"], 1, "logarithmic", ["<decibel>"]]
      }, A = ["<meter>", "<kilogram>", "<second>", "<mole>", "<ampere>", "<radian>", "<kelvin>", "<temp-K>", "<byte>", "<dollar>", "<candela>", "<each>", "<steradian>", "<decibel>"], T = "<1>", C = [T];
      function D(M, _) {
        var d = _[1], u = _[3] || [], v = _[4] || [];
        if (!n(d))
          throw new g(M + ": Invalid unit definition. 'scalar' must be a number");
        u.forEach(function(S) {
          if (k[S] === void 0)
            throw new g(M + ": Invalid unit definition. Unit " + S + " in 'numerator' is not recognized");
        }), v.forEach(function(S) {
          if (k[S] === void 0)
            throw new g(M + ": Invalid unit definition. Unit " + S + " in 'denominator' is not recognized");
        });
      }
      var $ = {}, P = {}, z = {}, B = {}, F = {};
      for (var O in k)
        if (k.hasOwnProperty(O)) {
          var N = k[O];
          if (N[2] === "prefix") {
            $[O] = N[1];
            for (var G = 0; G < N[0].length; G++)
              P[N[0][G]] = O;
          } else {
            D(O, N), z[O] = {
              scalar: N[1],
              numerator: N[3],
              denominator: N[4]
            };
            for (var V = 0; V < N[0].length; V++)
              B[N[0][V]] = O;
          }
          F[O] = N[0][0];
        }
      function J(M) {
        var _, d = [], u = Object.keys(k);
        if (typeof M > "u")
          for (_ = 0; _ < u.length; _++)
            ["", "prefix"].indexOf(k[u[_]][2]) === -1 && d.push(u[_].substr(1, u[_].length - 2));
        else {
          if (this.getKinds().indexOf(M) === -1)
            throw new g("Kind not recognized");
          for (_ = 0; _ < u.length; _++)
            k[u[_]][2] === M && d.push(u[_].substr(1, u[_].length - 2));
        }
        return d.sort(function(v, S) {
          return v.toLowerCase() < S.toLowerCase() ? -1 : v.toLowerCase() > S.toLowerCase() ? 1 : 0;
        });
      }
      function Q(M) {
        if (!B[M])
          throw new g("Unit not recognized");
        return k[B[M]][0];
      }
      var W = ["length", "time", "temperature", "mass", "current", "substance", "luminosity", "currency", "information", "angle"];
      function ne() {
        if (this.signature)
          return this.signature;
        for (var M = pe.call(this), _ = 0; _ < M.length; _++)
          M[_] *= Math.pow(20, _);
        return M.reduce(
          function(d, u) {
            return d + u;
          },
          0
        );
      }
      function pe() {
        if (!this.isBase())
          return pe.call(this.toBase());
        for (var M = new Array(W.length), _ = 0; _ < M.length; _++)
          M[_] = 0;
        for (var d, u, v = 0; v < this.numerator.length; v++)
          (d = k[this.numerator[v]]) && (u = W.indexOf(d[2]), u >= 0 && (M[u] = M[u] + 1));
        for (var S = 0; S < this.denominator.length; S++)
          (d = k[this.denominator[S]]) && (u = W.indexOf(d[2]), u >= 0 && (M[u] = M[u] - 1));
        return M;
      }
      var be = "[+-]", ve = "\\d+", Ee = be + "?" + ve, Ae = "\\." + ve, _e = "(?:" + ve + "(?:" + Ae + ")?)|(?:" + Ae + ")", Be = "[Ee]" + Ee, Me = "(?:" + _e + ")(?:" + Be + ")?", re = be + "?\\s*" + Me, Te = "(" + re + ")?\\s*([^/]*)(?:/(.+))?", Fe = new RegExp("^" + Te + "$"), Se = "\\^|\\*{2}", Ye = "[01234]", Je = new RegExp("([^ \\*\\d]+?)(?:" + Se + ")?(-?" + Ye + "(?![a-zA-Z]))"), et = new RegExp("([^ \\*\\d]+?)(?:" + Se + ")?(" + Ye + "(?![a-zA-Z]))");
      function Ve(M) {
        t(M) || (M = M.toString()), M = M.trim();
        var _ = Fe.exec(M);
        if (!_)
          throw new g(M + ": Quantity not recognized");
        var d = _[1];
        d ? (d = d.replace(/\s/g, ""), this.scalar = parseFloat(d)) : this.scalar = 1;
        for (var u = _[2], v = _[3], S, L, q; _ = Je.exec(u); ) {
          if (S = parseFloat(_[2]), isNaN(S))
            throw new g("Unit exponent is not a number");
          if (S === 0 && !Ge.test(_[1]))
            throw new g("Unit not recognized");
          L = _[1] + " ", q = "";
          for (var X = 0; X < Math.abs(S); X++)
            q += L;
          S >= 0 ? u = u.replace(_[0], q) : (v = v ? v + q : q, u = u.replace(_[0], ""));
        }
        for (; _ = et.exec(v); ) {
          if (S = parseFloat(_[2]), isNaN(S))
            throw new g("Unit exponent is not a number");
          if (S === 0 && !Ge.test(_[1]))
            throw new g("Unit not recognized");
          L = _[1] + " ", q = "";
          for (var j = 0; j < S; j++)
            q += L;
          v = v.replace(_[0], q);
        }
        u && (this.numerator = Qe(u.trim())), v && (this.denominator = Qe(v.trim()));
      }
      var tt = Object.keys(P).sort(function(M, _) {
        return _.length - M.length;
      }).join("|"), qe = Object.keys(B).sort(function(M, _) {
        return _.length - M.length;
      }).join("|"), Re = "\\b|$", nt = "(" + tt + ")??(" + qe + ")(?:" + Re + ")", Ge = new RegExp("^\\s*(" + nt + "[\\s\\*]*)+$"), Ne = new RegExp(nt, "g"), he = {};
      function Qe(M) {
        var _ = he[M];
        if (_)
          return _;
        var d, u = [];
        if (!Ge.test(M))
          throw new g("Unit not recognized");
        for (; d = Ne.exec(M); )
          u.push(d.slice(1));
        return u = u.map(function(v) {
          return P[v[0]] ? [P[v[0]], B[v[1]]] : [B[v[1]]];
        }), u = u.reduce(function(v, S) {
          return v.concat(S);
        }, []), u = u.filter(function(v) {
          return v;
        }), he[M] = u, u;
      }
      function Ze(M) {
        if (!t(M))
          throw new g("Argument should be a string");
        try {
          return this(M);
        } catch {
          return null;
        }
      }
      function He(M) {
        return M instanceof De;
      }
      function De(M, _) {
        if (lt.apply(null, arguments), !He(this))
          return new De(M, _);
        if (this.scalar = null, this.baseScalar = null, this.signature = null, this._conversionCache = {}, this.numerator = C, this.denominator = C, ot(M) ? (this.scalar = M.scalar, this.numerator = M.numerator && M.numerator.length !== 0 ? M.numerator : C, this.denominator = M.denominator && M.denominator.length !== 0 ? M.denominator : C) : _ ? (Ve.call(this, _), this.scalar = M) : Ve.call(this, M), this.denominator.join("*").indexOf("temp") >= 0)
          throw new g("Cannot divide with temperatures");
        if (this.numerator.join("*").indexOf("temp") >= 0) {
          if (this.numerator.length > 1)
            throw new g("Cannot multiply by temperatures");
          if (!o(this.denominator, C))
            throw new g("Cannot divide with temperatures");
        }
        if (this.initValue = M, Le.call(this), this.isTemperature() && this.baseScalar < 0)
          throw new g("Temperatures must not be less than absolute zero");
      }
      De.prototype = {
        // Properly set up constructor
        constructor: De
      };
      function lt(M, _) {
        if (_) {
          if (!(n(M) && t(_)))
            throw new g("Only number accepted as initialization value when units are explicitly provided");
        } else if (!(t(M) || n(M) || He(M) || ot(M)))
          throw new g("Only string, number or quantity accepted as single initialization value");
      }
      function ot(M) {
        return M && typeof M == "object" && M.hasOwnProperty("scalar");
      }
      function Le() {
        if (this.baseScalar)
          return this.baseScalar;
        if (this.isBase())
          this.baseScalar = this.scalar, this.signature = ne.call(this);
        else {
          var M = this.toBase();
          this.baseScalar = M.scalar, this.signature = M.signature;
        }
      }
      var ze = {
        "-312078": "elastance",
        "-312058": "resistance",
        "-312038": "inductance",
        "-152058": "potential",
        "-152040": "magnetism",
        "-152038": "magnetism",
        "-7997": "specific_volume",
        "-79": "snap",
        "-59": "jolt",
        "-39": "acceleration",
        "-38": "radiation",
        "-20": "frequency",
        "-19": "speed",
        "-18": "viscosity",
        "-17": "volumetric_flow",
        "-1": "wavenumber",
        0: "unitless",
        1: "length",
        2: "area",
        3: "volume",
        20: "time",
        400: "temperature",
        7941: "yank",
        7942: "power",
        7959: "pressure",
        7961: "force",
        7962: "energy",
        7979: "viscosity",
        7981: "momentum",
        7982: "angular_momentum",
        7997: "density",
        7998: "area_density",
        8e3: "mass",
        152020: "radiation_exposure",
        159999: "magnetism",
        16e4: "current",
        160020: "charge",
        312058: "conductance",
        312078: "capacitance",
        3199980: "activity",
        3199997: "molar_concentration",
        32e5: "substance",
        63999998: "illuminance",
        64e6: "luminous_power",
        128e7: "currency",
        "25599999980": "information_rate",
        "25600000000": "information",
        "511999999980": "angular_velocity",
        "512000000000": "angle"
      };
      function je() {
        return s(Object.keys(ze).map(function(M) {
          return ze[M];
        }));
      }
      De.prototype.kind = function() {
        return ze[this.signature.toString()];
      }, h(De.prototype, {
        isDegrees: function() {
          return (this.signature === null || this.signature === 400) && this.numerator.length === 1 && o(this.denominator, C) && (this.numerator[0].match(/<temp-[CFRK]>/) || this.numerator[0].match(/<(kelvin|celsius|rankine|fahrenheit)>/));
        },
        isTemperature: function() {
          return this.isDegrees() && this.numerator[0].match(/<temp-[CFRK]>/);
        }
      });
      function Oe(M, _) {
        var d = M.units(), u = _.to(d), v = De(ue(d));
        return De({ scalar: M.scalar - u.scalar, numerator: v.numerator, denominator: v.denominator });
      }
      function st(M, _) {
        var d = _.to(ue(M.units()));
        return De({ scalar: M.scalar - d.scalar, numerator: M.numerator, denominator: M.denominator });
      }
      function Z(M, _) {
        var d = _.to(ue(M.units()));
        return De({ scalar: M.scalar + d.scalar, numerator: M.numerator, denominator: M.denominator });
      }
      function ue(M) {
        if (M === "tempK")
          return "degK";
        if (M === "tempC")
          return "degC";
        if (M === "tempF")
          return "degF";
        if (M === "tempR")
          return "degR";
        throw new g("Unknown type for temp conversion from: " + M);
      }
      function xe(M, _) {
        var d = ke(M), u = _.units(), v;
        if (u === "degK")
          v = d.scalar;
        else if (u === "degC")
          v = d.scalar;
        else if (u === "degF")
          v = d.scalar * 9 / 5;
        else if (u === "degR")
          v = d.scalar * 9 / 5;
        else
          throw new g("Unknown type for degree conversion to: " + u);
        return De({ scalar: v, numerator: _.numerator, denominator: _.denominator });
      }
      function ke(M) {
        var _ = M.units(), d;
        if (_.match(/(deg)[CFRK]/))
          d = M.baseScalar;
        else if (_ === "tempK")
          d = M.scalar;
        else if (_ === "tempC")
          d = M.scalar;
        else if (_ === "tempF")
          d = M.scalar * 5 / 9;
        else if (_ === "tempR")
          d = M.scalar * 5 / 9;
        else
          throw new g("Unknown type for temp conversion from: " + _);
        return De({ scalar: d, numerator: ["<kelvin>"], denominator: C });
      }
      function te(M, _) {
        var d = _.units(), u;
        if (d === "tempK")
          u = M.baseScalar;
        else if (d === "tempC")
          u = M.baseScalar - 273.15;
        else if (d === "tempF")
          u = M.baseScalar * 9 / 5 - 459.67;
        else if (d === "tempR")
          u = M.baseScalar * 9 / 5;
        else
          throw new g("Unknown type for temp conversion to: " + d);
        return De({ scalar: u, numerator: _.numerator, denominator: _.denominator });
      }
      function me(M) {
        var _ = M.units(), d;
        if (_.match(/(deg)[CFRK]/))
          d = M.baseScalar;
        else if (_ === "tempK")
          d = M.scalar;
        else if (_ === "tempC")
          d = M.scalar + 273.15;
        else if (_ === "tempF")
          d = (M.scalar + 459.67) * 5 / 9;
        else if (_ === "tempR")
          d = M.scalar * 5 / 9;
        else
          throw new g("Unknown type for temp conversion from: " + _);
        return De({ scalar: d, numerator: ["<temp-K>"], denominator: C });
      }
      h(De.prototype, {
        /**
         * Converts to other compatible units.
         * Instance's converted quantities are cached for faster subsequent calls.
         *
         * @param {(string|Qty)} other - Target units as string or retrieved from
         *                               other Qty instance (scalar is ignored)
         *
         * @returns {Qty} New converted Qty instance with target units
         *
         * @throws {QtyError} if target units are incompatible
         *
         * @example
         * var weight = Qty("25 kg");
         * weight.to("lb"); // => Qty("55.11556554621939 lbs");
         * weight.to(Qty("3 g")); // => Qty("25000 g"); // scalar of passed Qty is ignored
         */
        to: function(M) {
          var _, d;
          if (M == null)
            return this;
          if (!t(M))
            return this.to(M.units());
          if (_ = this._conversionCache[M], _)
            return _;
          if (d = De(M), d.units() === this.units())
            return this;
          if (!this.isCompatible(d))
            this.isInverse(d) ? d = this.inverse().to(M) : E(this.units(), d.units());
          else if (d.isTemperature())
            d = te(this, d);
          else if (d.isDegrees())
            d = xe(this, d);
          else {
            var u = f(this.baseScalar, d.baseScalar);
            d = De({ scalar: u, numerator: d.numerator, denominator: d.denominator });
          }
          return this._conversionCache[M] = d, d;
        },
        // convert to base SI units
        // results of the conversion are cached so subsequent calls to this will be fast
        toBase: function() {
          if (this.isBase())
            return this;
          if (this.isTemperature())
            return me(this);
          var M = ye[this.units()];
          return M || (M = it(this.numerator, this.denominator), ye[this.units()] = M), M.mul(this.scalar);
        },
        // Converts the unit back to a float if it is unitless.  Otherwise raises an exception
        toFloat: function() {
          if (this.isUnitless())
            return this.scalar;
          throw new g("Can't convert to Float unless unitless.  Use Unit#scalar");
        },
        /**
         * Returns the nearest multiple of quantity passed as
         * precision
         *
         * @param {(Qty|string|number)} precQuantity - Quantity, string formated
         *   quantity or number as expected precision
         *
         * @returns {Qty} Nearest multiple of precQuantity
         *
         * @example
         * Qty('5.5 ft').toPrec('2 ft'); // returns 6 ft
         * Qty('0.8 cu').toPrec('0.25 cu'); // returns 0.75 cu
         * Qty('6.3782 m').toPrec('cm'); // returns 6.38 m
         * Qty('1.146 MPa').toPrec('0.1 bar'); // returns 1.15 MPa
         *
         */
        toPrec: function(M) {
          if (t(M) && (M = De(M)), n(M) && (M = De(M + " " + this.units())), this.isUnitless() ? M.isUnitless() || E(this.units(), M.units()) : M = M.to(this.units()), M.scalar === 0)
            throw new g("Divide by zero");
          var _ = l(
            Math.round(this.scalar / M.scalar),
            M.scalar
          );
          return De(_ + this.units());
        }
      });
      function U(M, _) {
        var d = De(M), u = De(_);
        if (d.eq(u))
          return a;
        var v;
        return d.isTemperature() ? v = function(S) {
          return d.mul(S).to(u).scalar;
        } : v = function(S) {
          return S * d.baseScalar / u.baseScalar;
        }, function(L) {
          var q, X, j;
          if (Array.isArray(L)) {
            for (X = L.length, j = [], q = 0; q < X; q++)
              j.push(v(L[q]));
            return j;
          } else
            return v(L);
        };
      }
      var ye = {};
      function it(M, _) {
        for (var d = [], u = [], v = 1, S, L = 0; L < M.length; L++)
          S = M[L], $[S] ? v = l(v, $[S]) : z[S] && (v *= z[S].scalar, z[S].numerator && d.push(z[S].numerator), z[S].denominator && u.push(z[S].denominator));
        for (var q = 0; q < _.length; q++)
          S = _[q], $[S] ? v /= $[S] : z[S] && (v /= z[S].scalar, z[S].numerator && u.push(z[S].numerator), z[S].denominator && d.push(z[S].denominator));
        return d = d.reduce(function(X, j) {
          return X.concat(j);
        }, []), u = u.reduce(function(X, j) {
          return X.concat(j);
        }, []), De({ scalar: v, numerator: d, denominator: u });
      }
      De.parse = Ze, De.getUnits = J, De.getAliases = Q, De.mulSafe = l, De.divSafe = f, De.getKinds = je, De.swiftConverter = U, De.Error = g, h(De.prototype, {
        // Returns new instance with units of this
        add: function(M) {
          if (t(M) && (M = De(M)), this.isCompatible(M) || E(this.units(), M.units()), this.isTemperature() && M.isTemperature())
            throw new g("Cannot add two temperatures");
          return this.isTemperature() ? Z(this, M) : M.isTemperature() ? Z(M, this) : De({ scalar: this.scalar + M.to(this).scalar, numerator: this.numerator, denominator: this.denominator });
        },
        sub: function(M) {
          if (t(M) && (M = De(M)), this.isCompatible(M) || E(this.units(), M.units()), this.isTemperature() && M.isTemperature())
            return Oe(this, M);
          if (this.isTemperature())
            return st(this, M);
          if (M.isTemperature())
            throw new g("Cannot subtract a temperature from a differential degree unit");
          return De({ scalar: this.scalar - M.to(this).scalar, numerator: this.numerator, denominator: this.denominator });
        },
        mul: function(M) {
          if (n(M))
            return De({ scalar: l(this.scalar, M), numerator: this.numerator, denominator: this.denominator });
          if (t(M) && (M = De(M)), (this.isTemperature() || M.isTemperature()) && !(this.isUnitless() || M.isUnitless()))
            throw new g("Cannot multiply by temperatures");
          var _ = this, d = M;
          _.isCompatible(d) && _.signature !== 400 && (d = d.to(_));
          var u = I(_.numerator, _.denominator, d.numerator, d.denominator);
          return De({ scalar: l(_.scalar, d.scalar, u[2]), numerator: u[0], denominator: u[1] });
        },
        div: function(M) {
          if (n(M)) {
            if (M === 0)
              throw new g("Divide by zero");
            return De({ scalar: this.scalar / M, numerator: this.numerator, denominator: this.denominator });
          } else t(M) && (M = De(M));
          if (M.scalar === 0)
            throw new g("Divide by zero");
          if (M.isTemperature())
            throw new g("Cannot divide with temperatures");
          if (this.isTemperature() && !M.isUnitless())
            throw new g("Cannot divide with temperatures");
          var _ = this, d = M;
          _.isCompatible(d) && _.signature !== 400 && (d = d.to(_));
          var u = I(_.numerator, _.denominator, d.denominator, d.numerator);
          return De({ scalar: l(_.scalar, u[2]) / d.scalar, numerator: u[0], denominator: u[1] });
        },
        // Returns a Qty that is the inverse of this Qty,
        inverse: function() {
          if (this.isTemperature())
            throw new g("Cannot divide with temperatures");
          if (this.scalar === 0)
            throw new g("Divide by zero");
          return De({ scalar: 1 / this.scalar, numerator: this.denominator, denominator: this.numerator });
        }
      });
      function I(M, _, d, u) {
        function v(we) {
          return we !== T;
        }
        M = M.filter(v), d = d.filter(v), _ = _.filter(v), u = u.filter(v);
        var S = {};
        function L(we, le) {
          for (var ge, Ue, ie, Ce = 0; Ce < we.length; Ce++)
            if ($[we[Ce]] ? (ge = we[Ce + 1], Ue = we[Ce], ie = $[Ue], Ce++) : (ge = we[Ce], Ue = null, ie = 1), ge && ge !== T)
              if (S[ge]) {
                S[ge][0] += le;
                var Xe = S[ge][2] ? $[S[ge][2]] : 1;
                S[ge][le === 1 ? 3 : 4] *= f(ie, Xe);
              } else
                S[ge] = [le, ge, Ue, 1, 1];
        }
        L(M, 1), L(_, -1), L(d, 1), L(u, -1);
        var q = [], X = [], j = 1;
        for (var ae in S)
          if (S.hasOwnProperty(ae)) {
            var K = S[ae], ce;
            if (K[0] > 0)
              for (ce = 0; ce < K[0]; ce++)
                q.push(K[2] === null ? K[1] : [K[2], K[1]]);
            else if (K[0] < 0)
              for (ce = 0; ce < -K[0]; ce++)
                X.push(K[2] === null ? K[1] : [K[2], K[1]]);
            j *= f(K[3], K[4]);
          }
        return q.length === 0 && (q = C), X.length === 0 && (X = C), q = q.reduce(function(we, le) {
          return we.concat(le);
        }, []), X = X.reduce(function(we, le) {
          return we.concat(le);
        }, []), [q, X, j];
      }
      h(De.prototype, {
        eq: function(M) {
          return this.compareTo(M) === 0;
        },
        lt: function(M) {
          return this.compareTo(M) === -1;
        },
        lte: function(M) {
          return this.eq(M) || this.lt(M);
        },
        gt: function(M) {
          return this.compareTo(M) === 1;
        },
        gte: function(M) {
          return this.eq(M) || this.gt(M);
        },
        // Compare two Qty objects. Throws an exception if they are not of compatible types.
        // Comparisons are done based on the value of the quantity in base SI units.
        //
        // NOTE: We cannot compare inverses as that breaks the general compareTo contract:
        //   if a.compareTo(b) < 0 then b.compareTo(a) > 0
        //   if a.compareTo(b) == 0 then b.compareTo(a) == 0
        //
        //   Since "10S" == ".1ohm" (10 > .1) and "10ohm" == ".1S" (10 > .1)
        //     Qty("10S").inverse().compareTo("10ohm") == -1
        //     Qty("10ohm").inverse().compareTo("10S") == -1
        //
        //   If including inverses in the sort is needed, I suggest writing: Qty.sort(qtyArray,units)
        compareTo: function(M) {
          if (t(M))
            return this.compareTo(De(M));
          if (this.isCompatible(M) || E(this.units(), M.units()), this.baseScalar < M.baseScalar)
            return -1;
          if (this.baseScalar === M.baseScalar)
            return 0;
          if (this.baseScalar > M.baseScalar)
            return 1;
        },
        // Return true if quantities and units match
        // Unit("100 cm").same(Unit("100 cm"))  # => true
        // Unit("100 cm").same(Unit("1 m"))     # => false
        same: function(M) {
          return this.scalar === M.scalar && this.units() === M.units();
        }
      }), h(De.prototype, {
        // returns true if no associated units
        // false, even if the units are "unitless" like 'radians, each, etc'
        isUnitless: function() {
          return [this.numerator, this.denominator].every(function(M) {
            return o(M, C);
          });
        },
        /*
        check to see if units are compatible, but not the scalar part
        this check is done by comparing signatures for performance reasons
        if passed a string, it will create a unit object with the string and then do the comparison
        this permits a syntax like:
        unit =~ "mm"
        if you want to do a regexp on the unit string do this ...
        unit.units =~ /regexp/
        */
        isCompatible: function(M) {
          return t(M) ? this.isCompatible(De(M)) : He(M) && M.signature !== void 0 ? this.signature === M.signature : !1;
        },
        /*
        check to see if units are inverse of each other, but not the scalar part
        this check is done by comparing signatures for performance reasons
        if passed a string, it will create a unit object with the string and then do the comparison
        this permits a syntax like:
        unit =~ "mm"
        if you want to do a regexp on the unit string do this ...
        unit.units =~ /regexp/
        */
        isInverse: function(M) {
          return this.inverse().isCompatible(M);
        },
        // Returns 'true' if the Unit is represented in base units
        isBase: function() {
          return this._isBase !== void 0 ? this._isBase : this.isDegrees() && this.numerator[0].match(/<(kelvin|temp-K)>/) ? (this._isBase = !0, this._isBase) : (this.numerator.concat(this.denominator).forEach(function(M) {
            M !== T && A.indexOf(M) === -1 && (this._isBase = !1);
          }, this), this._isBase === !1 ? this._isBase : (this._isBase = !0, this._isBase));
        }
      });
      function fe() {
      }
      fe.prototype.get = function(M) {
        return arguments.length > 1 && (M = Array.apply(null, arguments)), M.reduce(
          function(_, d, u) {
            if (_) {
              var v = _[d];
              return u === M.length - 1 ? v ? v.data : void 0 : v;
            }
          },
          this
        );
      }, fe.prototype.set = function(M, _) {
        return arguments.length > 2 && (M = Array.prototype.slice.call(arguments, 0, -1), _ = arguments[arguments.length - 1]), M.reduce(function(d, u, v) {
          var S = d[u];
          return S === void 0 && (S = d[u] = {}), v === M.length - 1 ? (S.data = _, _) : S;
        }, this);
      };
      function de(M, _) {
        return (M + " " + _).trim();
      }
      De.formatter = de, h(De.prototype, {
        // returns the 'unit' part of the Unit object without the scalar
        units: function() {
          if (this._units !== void 0)
            return this._units;
          var M = o(this.numerator, C), _ = o(this.denominator, C);
          if (M && _)
            return this._units = "", this._units;
          var d = ee(this.numerator), u = ee(this.denominator);
          return this._units = d + (_ ? "" : "/" + u), this._units;
        },
        /**
         * Stringifies the quantity
         * Deprecation notice: only units parameter is supported.
         *
         * @param {(number|string|Qty)} targetUnitsOrMaxDecimalsOrPrec -
         *                              target units if string,
         *                              max number of decimals if number,
         *                              passed to #toPrec before converting if Qty
         *
         * @param {number=} maxDecimals - Maximum number of decimals of
         *                                formatted output
         *
         * @returns {string} reparseable quantity as string
         */
        toString: function(M, _) {
          var d;
          if (n(M))
            d = this.units(), _ = M;
          else if (t(M))
            d = M;
          else if (He(M))
            return this.toPrec(M).toString(_);
          var u = this.to(d), v = _ !== void 0 ? b(u.scalar, _) : u.scalar;
          return u = (v + " " + u.units()).trim(), u;
        },
        /**
         * Format the quantity according to optional passed target units
         * and formatter
         *
         * @param {string} [targetUnits=current units] -
         *                 optional units to convert to before formatting
         *
         * @param {function} [formatter=Qty.formatter] -
         *                   delegates formatting to formatter callback.
         *                   formatter is called back with two parameters (scalar, units)
         *                   and should return formatted result.
         *                   If unspecified, formatting is delegated to default formatter
         *                   set to Qty.formatter
         *
         * @example
         * var roundingAndLocalizingFormatter = function(scalar, units) {
         *   // localize or limit scalar to n max decimals for instance
         *   // return formatted result
         * };
         * var qty = Qty('1.1234 m');
         * qty.format(); // same units, default formatter => "1.234 m"
         * qty.format("cm"); // converted to "cm", default formatter => "123.45 cm"
         * qty.format(roundingAndLocalizingFormatter); // same units, custom formatter => "1,2 m"
         * qty.format("cm", roundingAndLocalizingFormatter); // convert to "cm", custom formatter => "123,4 cm"
         *
         * @returns {string} quantity as string
         */
        format: function(M, _) {
          arguments.length === 1 && typeof M == "function" && (_ = M, M = void 0), _ = _ || De.formatter;
          var d = this.to(M);
          return _.call(this, d.scalar, d.units());
        }
      });
      var H = new fe();
      function ee(M) {
        var _ = H.get(M);
        if (_)
          return _;
        var d = o(M, C);
        return d ? _ = "1" : _ = We(oe(M)).join("*"), H.set(M, _), _;
      }
      function oe(M) {
        for (var _ = [], d, u, v = 0; v < M.length; v++)
          d = M[v], u = M[v + 1], $[d] ? (_.push(F[d] + F[u]), v++) : _.push(F[d]);
        return _;
      }
      function We(M) {
        var _ = M.reduce(function(d, u) {
          var v = d[u];
          return v || d.push(v = d[u] = [u, 0]), v[1]++, d;
        }, []);
        return _.map(function(d) {
          return d[0] + (d[1] > 1 ? d[1] : "");
        });
      }
      return De.version = "1.8.0", De;
    });
  }(quantities$1)), quantities$1.exports;
}
var quantitiesExports = requireQuantities();
const Qty = /* @__PURE__ */ getDefaultExportFromCjs(quantitiesExports);
function deepValue(e, i = "") {
  let t = i.split(".");
  for (let r of t) {
    if (e[r] === void 0) return;
    e = e[r];
  }
  return e;
}
var orientation = { exports: {} }, twoProduct_1, hasRequiredTwoProduct;
function requireTwoProduct() {
  if (hasRequiredTwoProduct) return twoProduct_1;
  hasRequiredTwoProduct = 1, twoProduct_1 = i;
  var e = +(Math.pow(2, 27) + 1);
  function i(t, r, n) {
    var a = t * r, s = e * t, o = s - t, h = s - o, l = t - h, f = e * r, b = f - r, w = f - b, g = r - w, E = a - h * w, k = E - l * w, A = k - h * g, T = l * g - A;
    return n ? (n[0] = T, n[1] = a, n) : [T, a];
  }
  return twoProduct_1;
}
var robustSum, hasRequiredRobustSum;
function requireRobustSum() {
  if (hasRequiredRobustSum) return robustSum;
  hasRequiredRobustSum = 1, robustSum = i;
  function e(t, r) {
    var n = t + r, a = n - t, s = n - a, o = r - a, h = t - s, l = h + o;
    return l ? [l, n] : [n];
  }
  function i(t, r) {
    var n = t.length | 0, a = r.length | 0;
    if (n === 1 && a === 1)
      return e(t[0], r[0]);
    var s = n + a, o = new Array(s), h = 0, l = 0, f = 0, b = Math.abs, w = t[l], g = b(w), E = r[f], k = b(E), A, T;
    g < k ? (T = w, l += 1, l < n && (w = t[l], g = b(w))) : (T = E, f += 1, f < a && (E = r[f], k = b(E))), l < n && g < k || f >= a ? (A = w, l += 1, l < n && (w = t[l], g = b(w))) : (A = E, f += 1, f < a && (E = r[f], k = b(E)));
    for (var C = A + T, D = C - A, $ = T - D, P = $, z = C, B, F, O, N, G; l < n && f < a; )
      g < k ? (A = w, l += 1, l < n && (w = t[l], g = b(w))) : (A = E, f += 1, f < a && (E = r[f], k = b(E))), T = P, C = A + T, D = C - A, $ = T - D, $ && (o[h++] = $), B = z + C, F = B - z, O = B - F, N = C - F, G = z - O, P = G + N, z = B;
    for (; l < n; )
      A = w, T = P, C = A + T, D = C - A, $ = T - D, $ && (o[h++] = $), B = z + C, F = B - z, O = B - F, N = C - F, G = z - O, P = G + N, z = B, l += 1, l < n && (w = t[l]);
    for (; f < a; )
      A = E, T = P, C = A + T, D = C - A, $ = T - D, $ && (o[h++] = $), B = z + C, F = B - z, O = B - F, N = C - F, G = z - O, P = G + N, z = B, f += 1, f < a && (E = r[f]);
    return P && (o[h++] = P), z && (o[h++] = z), h || (o[h++] = 0), o.length = h, o;
  }
  return robustSum;
}
var twoSum, hasRequiredTwoSum;
function requireTwoSum() {
  if (hasRequiredTwoSum) return twoSum;
  hasRequiredTwoSum = 1, twoSum = e;
  function e(i, t, r) {
    var n = i + t, a = n - i, s = n - a, o = t - a, h = i - s;
    return r ? (r[0] = h + o, r[1] = n, r) : [h + o, n];
  }
  return twoSum;
}
var robustScale, hasRequiredRobustScale;
function requireRobustScale() {
  if (hasRequiredRobustScale) return robustScale;
  hasRequiredRobustScale = 1;
  var e = requireTwoProduct(), i = requireTwoSum();
  robustScale = t;
  function t(r, n) {
    var a = r.length;
    if (a === 1) {
      var s = e(r[0], n);
      return s[0] ? s : [s[1]];
    }
    var o = new Array(2 * a), h = [0.1, 0.1], l = [0.1, 0.1], f = 0;
    e(r[0], n, h), h[0] && (o[f++] = h[0]);
    for (var b = 1; b < a; ++b) {
      e(r[b], n, l);
      var w = h[1];
      i(w, l[0], h), h[0] && (o[f++] = h[0]);
      var g = l[1], E = h[1], k = g + E, A = k - g, T = E - A;
      h[1] = k, T && (o[f++] = T);
    }
    return h[1] && (o[f++] = h[1]), f === 0 && (o[f++] = 0), o.length = f, o;
  }
  return robustScale;
}
var robustDiff, hasRequiredRobustDiff;
function requireRobustDiff() {
  if (hasRequiredRobustDiff) return robustDiff;
  hasRequiredRobustDiff = 1, robustDiff = i;
  function e(t, r) {
    var n = t + r, a = n - t, s = n - a, o = r - a, h = t - s, l = h + o;
    return l ? [l, n] : [n];
  }
  function i(t, r) {
    var n = t.length | 0, a = r.length | 0;
    if (n === 1 && a === 1)
      return e(t[0], -r[0]);
    var s = n + a, o = new Array(s), h = 0, l = 0, f = 0, b = Math.abs, w = t[l], g = b(w), E = -r[f], k = b(E), A, T;
    g < k ? (T = w, l += 1, l < n && (w = t[l], g = b(w))) : (T = E, f += 1, f < a && (E = -r[f], k = b(E))), l < n && g < k || f >= a ? (A = w, l += 1, l < n && (w = t[l], g = b(w))) : (A = E, f += 1, f < a && (E = -r[f], k = b(E)));
    for (var C = A + T, D = C - A, $ = T - D, P = $, z = C, B, F, O, N, G; l < n && f < a; )
      g < k ? (A = w, l += 1, l < n && (w = t[l], g = b(w))) : (A = E, f += 1, f < a && (E = -r[f], k = b(E))), T = P, C = A + T, D = C - A, $ = T - D, $ && (o[h++] = $), B = z + C, F = B - z, O = B - F, N = C - F, G = z - O, P = G + N, z = B;
    for (; l < n; )
      A = w, T = P, C = A + T, D = C - A, $ = T - D, $ && (o[h++] = $), B = z + C, F = B - z, O = B - F, N = C - F, G = z - O, P = G + N, z = B, l += 1, l < n && (w = t[l]);
    for (; f < a; )
      A = E, T = P, C = A + T, D = C - A, $ = T - D, $ && (o[h++] = $), B = z + C, F = B - z, O = B - F, N = C - F, G = z - O, P = G + N, z = B, f += 1, f < a && (E = -r[f]);
    return P && (o[h++] = P), z && (o[h++] = z), h || (o[h++] = 0), o.length = h, o;
  }
  return robustDiff;
}
var hasRequiredOrientation;
function requireOrientation() {
  return hasRequiredOrientation || (hasRequiredOrientation = 1, function(e) {
    var i = requireTwoProduct(), t = requireRobustSum(), r = requireRobustScale(), n = requireRobustDiff(), a = 5, s = 11102230246251565e-32, o = (3 + 16 * s) * s, h = (7 + 56 * s) * s;
    function l(D, $, P, z) {
      return function(F, O, N) {
        var G = D(D($(O[1], N[0]), $(-N[1], O[0])), D($(F[1], O[0]), $(-O[1], F[0]))), V = D($(F[1], N[0]), $(-N[1], F[0])), J = z(G, V);
        return J[J.length - 1];
      };
    }
    function f(D, $, P, z) {
      return function(F, O, N, G) {
        var V = D(D(P(D($(N[1], G[0]), $(-G[1], N[0])), O[2]), D(P(D($(O[1], G[0]), $(-G[1], O[0])), -N[2]), P(D($(O[1], N[0]), $(-N[1], O[0])), G[2]))), D(P(D($(O[1], G[0]), $(-G[1], O[0])), F[2]), D(P(D($(F[1], G[0]), $(-G[1], F[0])), -O[2]), P(D($(F[1], O[0]), $(-O[1], F[0])), G[2])))), J = D(D(P(D($(N[1], G[0]), $(-G[1], N[0])), F[2]), D(P(D($(F[1], G[0]), $(-G[1], F[0])), -N[2]), P(D($(F[1], N[0]), $(-N[1], F[0])), G[2]))), D(P(D($(O[1], N[0]), $(-N[1], O[0])), F[2]), D(P(D($(F[1], N[0]), $(-N[1], F[0])), -O[2]), P(D($(F[1], O[0]), $(-O[1], F[0])), N[2])))), Q = z(V, J);
        return Q[Q.length - 1];
      };
    }
    function b(D, $, P, z) {
      return function(F, O, N, G, V) {
        var J = D(D(D(P(D(P(D($(G[1], V[0]), $(-V[1], G[0])), N[2]), D(P(D($(N[1], V[0]), $(-V[1], N[0])), -G[2]), P(D($(N[1], G[0]), $(-G[1], N[0])), V[2]))), O[3]), D(P(D(P(D($(G[1], V[0]), $(-V[1], G[0])), O[2]), D(P(D($(O[1], V[0]), $(-V[1], O[0])), -G[2]), P(D($(O[1], G[0]), $(-G[1], O[0])), V[2]))), -N[3]), P(D(P(D($(N[1], V[0]), $(-V[1], N[0])), O[2]), D(P(D($(O[1], V[0]), $(-V[1], O[0])), -N[2]), P(D($(O[1], N[0]), $(-N[1], O[0])), V[2]))), G[3]))), D(P(D(P(D($(N[1], G[0]), $(-G[1], N[0])), O[2]), D(P(D($(O[1], G[0]), $(-G[1], O[0])), -N[2]), P(D($(O[1], N[0]), $(-N[1], O[0])), G[2]))), -V[3]), D(P(D(P(D($(G[1], V[0]), $(-V[1], G[0])), O[2]), D(P(D($(O[1], V[0]), $(-V[1], O[0])), -G[2]), P(D($(O[1], G[0]), $(-G[1], O[0])), V[2]))), F[3]), P(D(P(D($(G[1], V[0]), $(-V[1], G[0])), F[2]), D(P(D($(F[1], V[0]), $(-V[1], F[0])), -G[2]), P(D($(F[1], G[0]), $(-G[1], F[0])), V[2]))), -O[3])))), D(D(P(D(P(D($(O[1], V[0]), $(-V[1], O[0])), F[2]), D(P(D($(F[1], V[0]), $(-V[1], F[0])), -O[2]), P(D($(F[1], O[0]), $(-O[1], F[0])), V[2]))), G[3]), D(P(D(P(D($(O[1], G[0]), $(-G[1], O[0])), F[2]), D(P(D($(F[1], G[0]), $(-G[1], F[0])), -O[2]), P(D($(F[1], O[0]), $(-O[1], F[0])), G[2]))), -V[3]), P(D(P(D($(N[1], G[0]), $(-G[1], N[0])), O[2]), D(P(D($(O[1], G[0]), $(-G[1], O[0])), -N[2]), P(D($(O[1], N[0]), $(-N[1], O[0])), G[2]))), F[3]))), D(P(D(P(D($(N[1], G[0]), $(-G[1], N[0])), F[2]), D(P(D($(F[1], G[0]), $(-G[1], F[0])), -N[2]), P(D($(F[1], N[0]), $(-N[1], F[0])), G[2]))), -O[3]), D(P(D(P(D($(O[1], G[0]), $(-G[1], O[0])), F[2]), D(P(D($(F[1], G[0]), $(-G[1], F[0])), -O[2]), P(D($(F[1], O[0]), $(-O[1], F[0])), G[2]))), N[3]), P(D(P(D($(O[1], N[0]), $(-N[1], O[0])), F[2]), D(P(D($(F[1], N[0]), $(-N[1], F[0])), -O[2]), P(D($(F[1], O[0]), $(-O[1], F[0])), N[2]))), -G[3]))))), Q = D(D(D(P(D(P(D($(G[1], V[0]), $(-V[1], G[0])), N[2]), D(P(D($(N[1], V[0]), $(-V[1], N[0])), -G[2]), P(D($(N[1], G[0]), $(-G[1], N[0])), V[2]))), F[3]), P(D(P(D($(G[1], V[0]), $(-V[1], G[0])), F[2]), D(P(D($(F[1], V[0]), $(-V[1], F[0])), -G[2]), P(D($(F[1], G[0]), $(-G[1], F[0])), V[2]))), -N[3])), D(P(D(P(D($(N[1], V[0]), $(-V[1], N[0])), F[2]), D(P(D($(F[1], V[0]), $(-V[1], F[0])), -N[2]), P(D($(F[1], N[0]), $(-N[1], F[0])), V[2]))), G[3]), P(D(P(D($(N[1], G[0]), $(-G[1], N[0])), F[2]), D(P(D($(F[1], G[0]), $(-G[1], F[0])), -N[2]), P(D($(F[1], N[0]), $(-N[1], F[0])), G[2]))), -V[3]))), D(D(P(D(P(D($(N[1], V[0]), $(-V[1], N[0])), O[2]), D(P(D($(O[1], V[0]), $(-V[1], O[0])), -N[2]), P(D($(O[1], N[0]), $(-N[1], O[0])), V[2]))), F[3]), P(D(P(D($(N[1], V[0]), $(-V[1], N[0])), F[2]), D(P(D($(F[1], V[0]), $(-V[1], F[0])), -N[2]), P(D($(F[1], N[0]), $(-N[1], F[0])), V[2]))), -O[3])), D(P(D(P(D($(O[1], V[0]), $(-V[1], O[0])), F[2]), D(P(D($(F[1], V[0]), $(-V[1], F[0])), -O[2]), P(D($(F[1], O[0]), $(-O[1], F[0])), V[2]))), N[3]), P(D(P(D($(O[1], N[0]), $(-N[1], O[0])), F[2]), D(P(D($(F[1], N[0]), $(-N[1], F[0])), -O[2]), P(D($(F[1], O[0]), $(-O[1], F[0])), N[2]))), -V[3])))), W = z(J, Q);
        return W[W.length - 1];
      };
    }
    function w(D) {
      var $ = D === 3 ? l : D === 4 ? f : b;
      return $(t, i, r, n);
    }
    var g = w(3), E = w(4), k = [
      function() {
        return 0;
      },
      function() {
        return 0;
      },
      function($, P) {
        return P[0] - $[0];
      },
      function($, P, z) {
        var B = ($[1] - z[1]) * (P[0] - z[0]), F = ($[0] - z[0]) * (P[1] - z[1]), O = B - F, N;
        if (B > 0) {
          if (F <= 0)
            return O;
          N = B + F;
        } else if (B < 0) {
          if (F >= 0)
            return O;
          N = -(B + F);
        } else
          return O;
        var G = o * N;
        return O >= G || O <= -G ? O : g($, P, z);
      },
      function($, P, z, B) {
        var F = $[0] - B[0], O = P[0] - B[0], N = z[0] - B[0], G = $[1] - B[1], V = P[1] - B[1], J = z[1] - B[1], Q = $[2] - B[2], W = P[2] - B[2], ne = z[2] - B[2], pe = O * J, be = N * V, ve = N * G, Ee = F * J, Ae = F * V, _e = O * G, Be = Q * (pe - be) + W * (ve - Ee) + ne * (Ae - _e), Me = (Math.abs(pe) + Math.abs(be)) * Math.abs(Q) + (Math.abs(ve) + Math.abs(Ee)) * Math.abs(W) + (Math.abs(Ae) + Math.abs(_e)) * Math.abs(ne), re = h * Me;
        return Be > re || -Be > re ? Be : E($, P, z, B);
      }
    ];
    function A(D) {
      var $ = k[D.length];
      return $ || ($ = k[D.length] = w(D.length)), $.apply(void 0, D);
    }
    function T(D, $, P, z, B, F, O) {
      return function(G, V, J, Q, W) {
        switch (arguments.length) {
          case 0:
          case 1:
            return 0;
          case 2:
            return z(G, V);
          case 3:
            return B(G, V, J);
          case 4:
            return F(G, V, J, Q);
          case 5:
            return O(G, V, J, Q, W);
        }
        for (var ne = new Array(arguments.length), pe = 0; pe < arguments.length; ++pe)
          ne[pe] = arguments[pe];
        return D(ne);
      };
    }
    function C() {
      for (; k.length <= a; )
        k.push(w(k.length));
      e.exports = T.apply(void 0, [A].concat(k));
      for (var D = 0; D <= a; ++D)
        e.exports[D] = k[D];
    }
    C();
  }(orientation)), orientation.exports;
}
var robustPnp, hasRequiredRobustPnp;
function requireRobustPnp() {
  if (hasRequiredRobustPnp) return robustPnp;
  hasRequiredRobustPnp = 1, robustPnp = i;
  var e = requireOrientation();
  function i(t, r) {
    for (var n = r[0], a = r[1], s = t.length, o = 1, h = s, l = 0, f = s - 1; l < h; f = l++) {
      var b = t[l], w = t[f], g = b[1], E = w[1];
      if (E < g) {
        if (E < a && a < g) {
          var k = e(b, w, r);
          if (k === 0)
            return 0;
          o ^= 0 < k | 0;
        } else if (a === g) {
          var A = t[(l + 1) % s], T = A[1];
          if (g < T) {
            var k = e(b, w, r);
            if (k === 0)
              return 0;
            o ^= 0 < k | 0;
          }
        }
      } else if (g < E) {
        if (g < a && a < E) {
          var k = e(b, w, r);
          if (k === 0)
            return 0;
          o ^= k < 0 | 0;
        } else if (a === g) {
          var A = t[(l + 1) % s], T = A[1];
          if (T < g) {
            var k = e(b, w, r);
            if (k === 0)
              return 0;
            o ^= k < 0 | 0;
          }
        }
      } else if (a === g) {
        var C = Math.min(b[0], w[0]), D = Math.max(b[0], w[0]);
        if (l === 0) {
          for (; f > 0; ) {
            var $ = (f + s - 1) % s, P = t[$];
            if (P[1] !== a)
              break;
            var z = P[0];
            C = Math.min(C, z), D = Math.max(D, z), f = $;
          }
          if (f === 0)
            return C <= n && n <= D ? 0 : 1;
          h = f + 1;
        }
        for (var B = t[(f + s - 1) % s][1]; l + 1 < h; ) {
          var P = t[l + 1];
          if (P[1] !== a)
            break;
          var z = P[0];
          C = Math.min(C, z), D = Math.max(D, z), l += 1;
        }
        if (C <= n && n <= D)
          return 0;
        var F = t[(l + 1) % s][1];
        n < C && B < a != F < a && (o ^= 1);
      }
    }
    return 2 * o - 1;
  }
  return robustPnp;
}
var robustPnpExports = requireRobustPnp();
const robustPointInPolygon = /* @__PURE__ */ getDefaultExportFromCjs(robustPnpExports);
function feretDiameters(e = {}) {
  const { originalPoints: i = monotoneChainConvexHull.call(this) } = e;
  if (i.length === 0)
    return { min: 0, max: 0, minLine: [], maxLine: [], aspectRatio: 1 };
  if (i.length === 1)
    return {
      min: 1,
      max: 1,
      minLine: [i[0], i[0]],
      maxLine: [i[0], i[0]],
      aspectRatio: 1
    };
  const t = new Array(i.length);
  let r = 1 / 0, n = 0, a = [];
  for (let l = 0; l < i.length; l++) {
    let f = getAngle(
      i[l],
      i[(l + 1) % i.length]
    );
    rotate(-f, i, t);
    let b = 0, w = [];
    for (let g = 0; g < i.length; g++) {
      let E = Math.abs(t[l][1] - t[g][1]);
      E > b && (b = E, w = [], w.push(
        [t[g][0], t[l][1]],
        [t[g][0], t[g][1]]
      ));
    }
    b < r && (r = b, n = f, a = w);
  }
  rotate(n, a, a);
  let s = 0, o = [], h = 0;
  for (let l = 0; l < i.length - 1; l++)
    for (let f = l + 1; f < i.length; f++) {
      let b = (i[l][0] - i[f][0]) ** 2 + (i[l][1] - i[f][1]) ** 2;
      b > h && (h = b, s = Math.sqrt(b), o = [i[l], i[f]]);
    }
  return {
    min: r,
    minLine: a,
    max: s,
    maxLine: o,
    aspectRatio: r / s
  };
}
function getAngle(e, i) {
  let t = difference(i, e), r = normalize(t), n = Math.acos(r[0]);
  return r[1] < 0 ? -n : n;
}
class Roi {
  constructor(i, t) {
    this.map = i, this.id = t, this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.minY = Number.POSITIVE_INFINITY, this.maxY = Number.NEGATIVE_INFINITY, this.meanX = 0, this.meanY = 0, this.surface = 0, this.computed = {};
  }
  /**
   * Returns a binary image (mask) for the corresponding ROI
   * @param {object} [options]
   * @param {number} [options.scale=1] - Scaling factor to apply to the mask
   * @param {string} [options.kind='normal'] - 'contour', 'box', 'filled', 'center', 'hull' or 'normal'
   * @return {Image} - Returns a mask (1 bit Image)
   */
  getMask(i = {}) {
    const { scale: t = 1, kind: r = "" } = i;
    let n;
    switch (r) {
      case "contour":
        n = this.contourMask;
        break;
      case "box":
        n = this.boxMask;
        break;
      case "filled":
        n = this.filledMask;
        break;
      case "center":
        n = this.centerMask;
        break;
      case "mbr":
        n = this.mbrFilledMask;
        break;
      case "hull":
        n = this.convexHullFilledMask;
        break;
      case "hullContour":
        n = this.convexHullMask;
        break;
      case "mbrContour":
        n = this.mbrMask;
        break;
      case "feret":
        n = this.feretMask;
        break;
      default:
        n = this.mask;
    }
    return t < 1 && (n = n.resize({ factor: t }), n.parent = this.mask.parent, n.position[0] += this.minX, n.position[1] += this.minY), n;
  }
  get mean() {
    throw new Error("Roi mean not implemented yet");
  }
  get center() {
    return this.computed.center || (this.computed.center = [this.width / 2 >> 0, this.height / 2 >> 0]), this.computed.center;
  }
  get ratio() {
    return this.width / this.height;
  }
  get width() {
    return this.maxX - this.minX + 1;
  }
  get height() {
    return this.maxY - this.minY + 1;
  }
  _computExternalIDs() {
    let i = this.borderIDs, t = this.borderLengths;
    this.computed.externalIDs = [], this.computed.externalLengths = [];
    let r = this.internalIDs;
    for (let n = 0; n < i.length; n++)
      r.includes(i[n]) || (this.computed.externalIDs.push(i[n]), this.computed.externalLengths.push(t[n]));
  }
  get externalIDs() {
    return this.computed.externalIDs ? this.computed.externalIDs : (this._computExternalIDs(), this.computed.externalIDs);
  }
  get externalLengths() {
    return this.computed.externalLengths ? this.computed.externalLengths : (this._computExternalIDs(), this.computed.externalLengths);
  }
  _computeBorderIDs() {
    let i = getBorders(this);
    this.computed.borderIDs = i.ids, this.computed.borderLengths = i.lengths;
  }
  /**
     Retrieve all the IDs (array of number) of the regions that are in contact with this
     specific region. It may be external or internal
     */
  get borderIDs() {
    return this.computed.borderIDs ? this.computed.borderIDs : (this._computeBorderIDs(), this.computed.borderIDs);
  }
  /**
     Retrieve all the length (array of number) of the contacts with this
     specific region. It may be external or internal
     */
  get borderLengths() {
    return this.computed.borderLengths ? this.computed.borderLengths : (this._computeBorderIDs(), this.computed.borderLengths);
  }
  /**
       Retrieve all the IDs or the Roi touching the box surrouding the region
  
       It should really be an array to solve complex cases related to border effect
  
       Like the image
       <pre>
       0000
       1111
       0000
       1111
       </pre>
  
       The first row of 1 will be surrouned by 2 differents zones
  
       Or even worse
       <pre>
       010
       111
       010
       </pre>
       The cross will be surrouned by 4 differents zones
  
       However in most of the cases it will be an array of one element
       */
  get boxIDs() {
    return this.computed.boxIDs || (this.computed.boxIDs = getBoxIDs(this)), this.computed.boxIDs;
  }
  get internalIDs() {
    return this.computed.internalIDs || (this.computed.internalIDs = getInternalIDs(this)), this.computed.internalIDs;
  }
  /**
     Number of pixels of the Roi that touch the rectangle
     This is useful for the calculation of the border
     because we will ignore those special pixels of the rectangle
     border that don't have neighbours all around them.
     */
  get box() {
    return this.computed.box || (this.computed.box = getBox(this)), this.computed.box;
  }
  /**
     Calculates the number of pixels that are in the external border of the Roi
     Contour are all the pixels that touch an external "zone".
     All the pixels that touch the box are part of the border and
     are calculated in the getBoxPixels procedure
     */
  get external() {
    return this.computed.external || (this.computed.external = getExternal(this)), this.computed.external;
  }
  /**
     Calculates information about holes
     */
  get holesInfo() {
    return this.computed.holesInfo || (this.computed.holesInfo = getHolesInfo(this)), this.computed.holesInfo;
  }
  /**
     Calculates the number of pixels that are involved in border
     Border are all the pixels that touch another "zone". It could be external
     or internal. If there is a hole in the zone it will be counted as a border.
     All the pixels that touch the box are part of the border and
     are calculated in the getBoxPixels procedure
     */
  get border() {
    return this.computed.border || (this.computed.border = getBorder(this)), this.computed.border;
  }
  /**
    Returns a binary image (mask) containing only the border of the mask
  */
  get contourMask() {
    if (!this.computed.contourMask) {
      let i = new Image(this.width, this.height, {
        kind: BINARY,
        position: [this.minX, this.minY],
        parent: this.map.parent
      });
      for (let t = 0; t < this.width; t++)
        for (let r = 0; r < this.height; r++)
          this.map.data[t + this.minX + (r + this.minY) * this.map.width] === this.id && (t > 0 && t < this.width - 1 && r > 0 && r < this.height - 1 ? (this.map.data[t - 1 + this.minX + (r + this.minY) * this.map.width] !== this.id || this.map.data[t + 1 + this.minX + (r + this.minY) * this.map.width] !== this.id || this.map.data[t + this.minX + (r - 1 + this.minY) * this.map.width] !== this.id || this.map.data[t + this.minX + (r + 1 + this.minY) * this.map.width] !== this.id) && i.setBitXY(t, r) : i.setBitXY(t, r));
      this.computed.contourMask = i;
    }
    return this.computed.contourMask;
  }
  get boxMask() {
    if (!this.computed.boxMask) {
      let i = new Image(this.width, this.height, {
        kind: BINARY,
        position: [this.minX, this.minY],
        parent: this.map.parent
      });
      for (let t = 0; t < this.width; t++)
        i.setBitXY(t, 0), i.setBitXY(t, this.height - 1);
      for (let t = 0; t < this.height; t++)
        i.setBitXY(0, t), i.setBitXY(this.width - 1, t);
      this.computed.boxMask = i;
    }
    return this.computed.boxMask;
  }
  /**
     Returns a binary image containing the mask
     */
  get mask() {
    if (!this.computed.mask) {
      let i = new Image(this.width, this.height, {
        kind: BINARY,
        position: [this.minX, this.minY],
        parent: this.map.parent
      });
      for (let t = 0; t < this.width; t++)
        for (let r = 0; r < this.height; r++)
          this.map.data[t + this.minX + (r + this.minY) * this.map.width] === this.id && i.setBitXY(t, r);
      this.computed.mask = i;
    }
    return this.computed.mask;
  }
  get filledMask() {
    if (!this.computed.filledMask) {
      let i = new Image(this.width, this.height, {
        kind: BINARY,
        position: [this.minX, this.minY],
        parent: this.map.parent
      });
      for (let t = 0; t < this.width; t++)
        for (let r = 0; r < this.height; r++) {
          let n = t + this.minX + (r + this.minY) * this.map.width;
          this.internalIDs.includes(this.map.data[n]) && i.setBitXY(t, r);
        }
      this.computed.filledMask = i;
    }
    return this.computed.filledMask;
  }
  get centerMask() {
    if (!this.computed.centerMask) {
      let i = new Shape({ kind: "smallCross" }).getMask();
      i.parent = this.map.parent, i.position = [
        this.minX + this.center[0] - 1,
        this.minY + this.center[1] - 1
      ], this.computed.centerMask = i;
    }
    return this.computed.centerMask;
  }
  get convexHull() {
    if (!this.computed.convexHull) {
      const i = [];
      for (let r = 0; r < this.width; r++)
        for (let n = 0; n < this.height; n++)
          this.map.data[r + this.minX + (n + this.minY) * this.map.width] === this.id && (r > 0 && r < this.width - 1 && n > 0 && n < this.height - 1 ? (this.map.data[r - 1 + this.minX + (n + this.minY) * this.map.width] !== this.id || this.map.data[r + 1 + this.minX + (n + this.minY) * this.map.width] !== this.id || this.map.data[r + this.minX + (n - 1 + this.minY) * this.map.width] !== this.id || this.map.data[r + this.minX + (n + 1 + this.minY) * this.map.width] !== this.id) && (i.push([r, n]), i.push([r + 1, n]), i.push([r, n + 1]), i.push([r + 1, n + 1])) : (i.push([r, n]), i.push([r + 1, n]), i.push([r, n + 1]), i.push([r + 1, n + 1])));
      const t = monotoneChainConvexHull$1(i);
      this.computed.convexHull = {
        polyline: t,
        surface: surface(t),
        perimeter: perimeter(t)
      };
    }
    return this.computed.convexHull;
  }
  get convexHullMask() {
    if (!this.computed.convexHullMask) {
      const i = this.convexHull, t = new Image(this.width + 1, this.height + 1, {
        kind: BINARY,
        position: [this.minX, this.minY],
        parent: this.map.parent
      });
      t.paintPolyline(i.polyline, { closed: !0 }), this.computed.convexHullMask = t;
    }
    return this.computed.convexHullMask;
  }
  get convexHullFilledMask() {
    if (!this.computed.convexHullFilledMask) {
      const i = this.convexHull, t = new Image(this.width, this.height, {
        kind: BINARY,
        position: [this.minX, this.minY],
        parent: this.map.parent
      });
      for (let r = 0; r < this.width; r++)
        for (let n = 0; n < this.height; n++)
          robustPointInPolygon(i.polyline, [r, n]) !== 1 && t.setBitXY(r, n);
      this.computed.convexHullFilledMask = t;
    }
    return this.computed.convexHullFilledMask;
  }
  get mbr() {
    if (!this.computed.mbr) {
      let i = minimalBoundingRectangle({
        originalPoints: this.convexHull.polyline
      });
      if (i.length === 0)
        this.computed.mbr = {
          width: 0,
          height: 0,
          surface: 0,
          perimeter: 0,
          rectangle: i
        };
      else {
        let t = i[0], r = i[1], n = i[2], a = Math.sqrt(
          (t[0] - r[0]) ** 2 + (t[1] - r[1]) ** 2
        ), s = Math.sqrt(
          (n[0] - r[0]) ** 2 + (n[1] - r[1]) ** 2
        );
        this.computed.mbr = {
          width: a,
          height: s,
          elongation: 1 - a / s,
          aspectRatio: a / s,
          surface: a * s,
          perimeter: (a + s) * 2,
          rectangle: i
        };
      }
    }
    return this.computed.mbr;
  }
  get filledSurface() {
    return this.surface + this.holesInfo.surface;
  }
  get fillRatio() {
    return this.surface / (this.surface + this.holesInfo.surface);
  }
  get feretDiameters() {
    return this.computed.feretDiameters || (this.computed.feretDiameters = feretDiameters({
      originalPoints: this.convexHull.polyline
    })), this.computed.feretDiameters;
  }
  /**
   * Diameter of a circle of equal projection area
   */
  get eqpc() {
    return this.computed.eqpc || (this.computed.eqpc = 2 * Math.sqrt(this.surface / Math.PI)), this.computed.eqpc;
  }
  /**
   * Get the category in which each external pixel belongs
   */
  get perimeterInfo() {
    return this.computed.perimeterInfo || (this.computed.perimeterInfo = getPerimeterInfo(this)), this.computed.perimeterInfo;
  }
  /**
   * Return the perimeter of the ROI
   */
  get perimeter() {
    let i = this.perimeterInfo, t = 2 - Math.sqrt(2);
    return i.one + i.two * 2 + i.three * 3 + i.four * 4 - t * (i.two + i.three * 2 + i.four);
  }
  /**
   * Diameter of a circle of equal perimeter
   */
  get ped() {
    return this.computed.ped || (this.computed.ped = this.perimeter / Math.PI), this.computed.ped;
  }
  get feretMask() {
    if (!this.computed.feretMask) {
      const i = new Image(this.width + 1, this.height + 1, {
        kind: BINARY,
        position: [this.minX, this.minY],
        parent: this.map.parent
      });
      i.paintPolyline(this.feretDiameters.minLine), i.paintPolyline(this.feretDiameters.maxLine), this.computed.feretMask = i;
    }
    return this.computed.feretMask;
  }
  get mbrMask() {
    if (!this.computed.mbrMask) {
      let i = round(this.mbr.rectangle);
      if (i.length > 0) {
        const t = minMax(i), r = new Image(
          t[1][0] - t[0][0] + 1,
          t[1][1] - t[0][1] + 1,
          {
            kind: BINARY,
            position: [this.minX + t[0][0], this.minY + t[0][1]],
            parent: this.map.parent
          }
        );
        i = moveToZeroZero(i), r.paintPolyline(i, { closed: !0 }), this.computed.mbrMask = r;
      } else
        this.computed.mbrMask = new Image(1, 1, {
          kind: BINARY,
          position: [this.minX, this.minY],
          parent: this.map.parent
        });
    }
    return this.computed.mbrMask;
  }
  get mbrFilledMask() {
    if (!this.computed.mbrFilledMask) {
      const i = new Image(this.width, this.height, {
        kind: BINARY,
        position: [this.minX, this.minY],
        parent: this.map.parent
      }), t = this.mask.minimalBoundingRectangle();
      for (let r = 0; r < this.width; r++)
        for (let n = 0; n < this.height; n++)
          robustPointInPolygon(t, [r, n]) !== 1 && i.setBitXY(r, n);
      this.computed.mbrFilledMask = i;
    }
    return this.computed.mbrFilledMask;
  }
  get points() {
    if (!this.computed.points) {
      let i = [];
      for (let t = 0; t < this.height; t++)
        for (let r = 0; r < this.width; r++) {
          let n = (t + this.minY) * this.map.width + r + this.minX;
          this.map.data[n] === this.id && i.push([r, t]);
        }
      this.computed.points = i;
    }
    return this.computed.points;
  }
  get maxLengthPoints() {
    if (!this.computed.maxLengthPoints) {
      let i = 0, t;
      const r = this.points;
      for (let n = 0; n < r.length; n++)
        for (let a = n + 1; a < r.length; a++) {
          let s = Math.pow(r[n][0] - r[a][0], 2) + Math.pow(r[n][1] - r[a][1], 2);
          s >= i && (i = s, t = [r[n], r[a]]);
        }
      this.computed.maxLengthPoints = t;
    }
    return this.computed.maxLengthPoints;
  }
  /**
        Calculates the maximum length between two pixels of the Roi.
     */
  get maxLength() {
    if (!this.computed.maxLength) {
      let i = Math.sqrt(
        Math.pow(this.maxLengthPoints[0][0] - this.maxLengthPoints[1][0], 2) + Math.pow(this.maxLengthPoints[0][1] - this.maxLengthPoints[1][1], 2)
      );
      this.computed.maxLength = i;
    }
    return this.computed.maxLength;
  }
  get roundness() {
    return 4 * this.surface / (Math.PI * this.feretDiameters.max ** 2);
  }
  get sphericity() {
    return 2 * Math.sqrt(this.surface * Math.PI) / this.perimeter;
  }
  get solidity() {
    return this.surface / this.convexHull.surface;
  }
  get angle() {
    if (!this.computed.angle) {
      let i = this.maxLengthPoints, t = -Math.atan2(i[0][1] - i[1][1], i[0][0] - i[1][0]) * 180 / Math.PI;
      this.computed.angle = t;
    }
    return this.computed.angle;
  }
  toJSON() {
    return {
      id: this.id,
      minX: this.minX,
      maxX: this.maxX,
      minY: this.minY,
      maxY: this.maxY,
      meanX: this.meanX,
      meanY: this.meanY,
      height: this.height,
      width: this.width,
      filledSurface: this.filledSurface,
      surface: this.surface,
      hullSurface: this.convexHull.surface,
      hullPerimeter: this.convexHull.perimeter,
      mbrWidth: this.mbr.width,
      mbrHeight: this.mbr.height,
      mbrSurface: this.mbr.surface,
      eqpc: this.eqpc,
      ped: this.ped,
      feretDiameterMin: this.feretDiameters.min,
      feretDiameterMax: this.feretDiameters.max,
      aspectRatio: this.feretDiameters.aspectRatio,
      fillRatio: this.fillRatio,
      sphericity: this.sphericity,
      roundness: this.roundness,
      solidity: this.solidity,
      perimeter: this.perimeter
    };
  }
}
function getBorders(e) {
  let i = e.map, t = i.data, r = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Set(), s = [1, 0, -1, 0], o = [0, 1, 0, -1];
  for (let f = e.minX; f <= e.maxX; f++)
    for (let b = e.minY; b <= e.maxY; b++) {
      let w = f + b * i.width;
      if (t[w] === e.id)
        for (let g = 0; g < 4; g++) {
          let E = f + s[g], k = b + o[g];
          if (E >= 0 && k >= 0 && E < i.width && k < i.height) {
            let A = E + k * i.width;
            if (t[A] !== e.id && !a.has(A)) {
              a.add(A), r.add(t[A]);
              let T = n.get(t[A]);
              T ? n.set(t[A], ++T) : n.set(t[A], 1);
            }
          }
        }
    }
  let h = Array.from(r), l = h.map(function(f) {
    return n.get(f);
  });
  return {
    ids: h,
    lengths: l
  };
}
function getBoxIDs(e) {
  let i = /* @__PURE__ */ new Set(), t = e.map, r = t.data;
  for (let n of [0, e.height - 1])
    for (let a = 0; a < e.width; a++) {
      let s = (n + e.minY) * t.width + a + e.minX;
      if (a - e.minX > 0 && r[s] === e.id && r[s - 1] !== e.id) {
        let o = r[s - 1];
        i.add(o);
      }
      if (t.width - a - e.minX > 1 && r[s] === e.id && r[s + 1] !== e.id) {
        let o = r[s + 1];
        i.add(o);
      }
    }
  for (let n of [0, e.width - 1])
    for (let a = 0; a < e.height; a++) {
      let s = (a + e.minY) * t.width + n + e.minX;
      if (a - e.minY > 0 && r[s] === e.id && r[s - t.width] !== e.id) {
        let o = r[s - t.width];
        i.add(o);
      }
      if (t.height - a - e.minY > 1 && r[s] === e.id && r[s + t.width] !== e.id) {
        let o = r[s + t.width];
        i.add(o);
      }
    }
  return Array.from(i);
}
function getBox(e) {
  let i = 0, t = e.map, r = t.data, n = [0];
  e.height > 1 && (n[1] = e.height - 1);
  for (let s of n)
    for (let o = 1; o < e.width - 1; o++) {
      let h = (s + e.minY) * t.width + o + e.minX;
      r[h] === e.id && i++;
    }
  let a = [0];
  e.width > 1 && (a[1] = e.width - 1);
  for (let s of a)
    for (let o = 0; o < e.height; o++) {
      let h = (o + e.minY) * t.width + s + e.minX;
      r[h] === e.id && i++;
    }
  return i;
}
function getBorder(e) {
  let i = 0, t = e.map, r = t.data;
  for (let n = 1; n < e.width - 1; n++)
    for (let a = 1; a < e.height - 1; a++) {
      let s = (a + e.minY) * t.width + n + e.minX;
      r[s] === e.id && (r[s - 1] !== e.id || r[s + 1] !== e.id || r[s - t.width] !== e.id || r[s + t.width] !== e.id) && i++;
    }
  return i + e.box;
}
function getPerimeterInfo(e) {
  let i = e.map, t = i.data, r = 0, n = 0, a = 0, s = 0;
  for (let o = 0; o < e.width; o++)
    for (let h = 0; h < e.height; h++) {
      let l = (h + e.minY) * i.width + o + e.minX;
      if (t[l] === e.id) {
        let f = 0;
        switch ((o === 0 || e.externalIDs.includes(t[l - 1])) && f++, (o === e.width - 1 || e.externalIDs.includes(t[l + 1])) && f++, (h === 0 || e.externalIDs.includes(t[l - i.width])) && f++, (h === e.height - 1 || e.externalIDs.includes(t[l + i.width])) && f++, f) {
          case 1:
            r++;
            break;
          case 2:
            n++;
            break;
          case 3:
            a++;
            break;
          case 4:
            s++;
            break;
        }
      }
    }
  return { one: r, two: n, three: a, four: s };
}
function getExternal(e) {
  let i = 0, t = e.map, r = t.data;
  for (let n = 1; n < e.width - 1; n++)
    for (let a = 1; a < e.height - 1; a++) {
      let s = (a + e.minY) * t.width + n + e.minX;
      r[s] === e.id && (e.externalIDs.includes(r[s - 1]) || e.externalIDs.includes(r[s + 1]) || e.externalIDs.includes(r[s - t.width]) || e.externalIDs.includes(r[s + t.width])) && i++;
    }
  return i + e.box;
}
function getHolesInfo(e) {
  let i = 0, t = e.map.width, r = e.map.data;
  for (let n = 1; n < e.width - 1; n++)
    for (let a = 1; a < e.height - 1; a++) {
      let s = (a + e.minY) * t + n + e.minX;
      e.internalIDs.includes(r[s]) && r[s] !== e.id && i++;
    }
  return {
    number: e.internalIDs.length - 1,
    surface: i
  };
}
function getInternalIDs(e) {
  let i = [e.id], t = e.map, r = t.data;
  if (e.height > 2)
    for (let a = 0; a < e.width; a++) {
      let s = e.minY * t.width + a + e.minX;
      if (i.includes(r[s])) {
        let o = r[s + t.width];
        !i.includes(o) && !e.boxIDs.includes(o) && i.push(o);
      }
    }
  let n = new Array(4);
  for (let a = 1; a < e.width - 1; a++)
    for (let s = 1; s < e.height - 1; s++) {
      let o = (s + e.minY) * t.width + a + e.minX;
      if (i.includes(r[o])) {
        n[0] = r[o - 1], n[1] = r[o + 1], n[2] = r[o - t.width], n[3] = r[o + t.width];
        for (let h = 0; h < 4; h++) {
          let l = n[h];
          !i.includes(l) && !e.boxIDs.includes(l) && i.push(l);
        }
      }
    }
  return i;
}
class RoiLayer {
  constructor(i, t) {
    this.roiMap = i, this.options = t, this.roi = this.createRoi();
  }
  /**
   * Roi are created from a roiMap
   * The roiMap contains mainty an array of identifiers that define
   * for each data to which Roi it belongs
   * @memberof RoiManager
   * @instance
   * @return {Roi[]}
   */
  createRoi() {
    let i = this.roiMap.data, t = {};
    this.roiMap.positive = 0, this.roiMap.negative = 0;
    for (let o = 0; o < i.length; o++)
      i[o] && !t[i[o]] && (t[i[o]] = !0, i[o] > 0 ? this.roiMap.positive++ : this.roiMap.negative++);
    let r = {};
    for (let o in t)
      r[o] = new Roi(this.roiMap, o * 1);
    let n = this.roiMap.width, a = this.roiMap.height;
    for (let o = 0; o < a; o++)
      for (let h = 0; h < n; h++) {
        let l = o * n + h;
        if (i[l] !== 0) {
          const f = i[l], b = r[f];
          h < b.minX && (b.minX = h), h > b.maxX && (b.maxX = h), o < b.minY && (b.minY = o), o > b.maxY && (b.maxY = o), b.meanX += h, b.meanY += o, b.surface++;
        }
      }
    let s = [];
    for (let o in t)
      r[o].meanX /= r[o].surface, r[o].meanY /= r[o].surface, s.push(r[o]);
    return s;
  }
}
function commonBorderLength(e) {
  let i = e.data, t = [1, 0, -1, 0], r = [0, 1, 0, -1], n = e.minMax, a = -n.min, s = n.max + a, o = [];
  for (let l = 0; l <= s; l++)
    o.push(/* @__PURE__ */ Object.create(null));
  for (let l = 0; l < e.width; l++)
    for (let f = 0; f < e.height; f++) {
      let b = l + f * e.width, w = i[b];
      if (w !== 0) {
        let g = /* @__PURE__ */ Object.create(null), E = !1;
        for (let k = 0; k < 4; k++) {
          let A = l + t[k], T = f + r[k];
          if (A >= 0 && T >= 0 && A < e.width && T < e.height) {
            let C = i[A + T * e.width];
            w !== C && (E = !0, C !== 0 && g[C] === void 0 && (g[C] = !0, o[C + a][w] ? o[C + a][w]++ : o[C + a][w] = 1));
          } else
            E = !0;
        }
        E && (o[w + a][w] ? o[w + a][w]++ : o[w + a][w] = 1);
      }
    }
  let h = {};
  for (let l = 0; l < o.length; l++)
    Object.keys(o[l]).length > 0 && (h[l - a] = o[l]);
  return h;
}
function mergeRoi(e = {}) {
  const {
    algorithm: i = "commonBorderLength",
    minCommonBorderLength: t = 5,
    maxCommonBorderLength: r = 100,
    minCommonBorderRatio: n = 0.3,
    maxCommonBorderRatio: a = 1
  } = e;
  let s = function(A, T, C) {
    return A[C] >= t && A[C] <= r;
  };
  typeof i == "function" && (s = i), i.toLowerCase() === "commonborderratio" && (s = function(A, T, C) {
    let D = Math.min(
      A[C] / A[T],
      1
    );
    return D >= n && D <= a;
  });
  const o = this, h = o.commonBorderLength;
  let l = {}, f = {};
  for (let A of Object.keys(h)) {
    let T = h[A], C = Object.keys(T);
    for (let D of C)
      if (D !== A && s(T, A, D)) {
        let $ = D;
        f[D] && ($ = f[D]);
        let P = A;
        if (f[A] && (P = f[A]), Number($) !== P) {
          let z = Math.min($, P), B = Math.max($, P);
          if (l[z] || (l[z] = {}), l[z][B] = !0, f[B] = z, l[B]) {
            for (let F of Object.keys(l[B]))
              l[z][F] = !0, f[F] = z;
            delete l[B];
          }
        }
      }
  }
  let b = o.minMax, w = -b.min, g = b.max + w, E = new Array(g + 1).fill(0);
  for (let A of Object.keys(f))
    E[Number(A) + w] = f[A];
  let k = o.data;
  for (let A = 0; A < k.length; A++) {
    let T = k[A];
    if (T !== 0) {
      let C = E[T + w];
      C !== 0 && (k[A] = C);
    }
  }
  return o.computed = {}, o;
}
class RoiMap {
  constructor(i, t) {
    this.parent = i, this.width = i.width, this.height = i.height, this.data = t, this.negative = 0, this.positive = 0;
  }
  get total() {
    return this.negative + this.positive;
  }
  get minMax() {
    let i = Number.MAX_SAFE_INTEGER, t = Number.MIN_SAFE_INTEGER;
    for (let r = 0; r < this.data.length; r++)
      this.data[r] < i && (i = this.data[r]), this.data[r] > t && (t = this.data[r]);
    return { min: i, max: t };
  }
  get commonBorderLength() {
    return commonBorderLength(this);
  }
  mergeRoi(i = {}) {
    return mergeRoi.call(this, i);
  }
  mergeRois(i) {
    const t = i[0], r = i.slice(1);
    for (let n = 0; n < this.data.length; n++)
      r.includes(this.data[n]) && (this.data[n] = t);
  }
  rowsInfo() {
    let i = new Array(this.height), t = 0;
    for (let r = 0; r < this.data.length; r += this.width) {
      let n = {
        row: t,
        positivePixel: 0,
        negativePixel: 0,
        zeroPixel: 0,
        positiveRoi: 0,
        negativeRoi: 0,
        medianChange: 0
      };
      i[t++] = n;
      let a = {}, s = {}, o = [], h = this.data[r], l = 0;
      for (let f = r; f < r + this.width; f++) {
        let b = this.data[f];
        h !== b && (h = b, o.push(l), l = 0), l++, b > 0 ? (n.positivePixel++, a[b] || (a[b] = !0)) : b < 0 ? (n.negativePixel++, s[b] || (s[b] = !0)) : n.zeroPixel++;
      }
      o.push(l), n.medianChange = o.sort((f, b) => f - b)[Math.floor(o.length / 2)], n.positiveRoiIDs = Object.keys(a), n.negativeRoiIDs = Object.keys(s), n.positiveRoi = n.positiveRoiIDs.length, n.negativeRoi = n.negativeRoiIDs.length;
    }
    return i;
  }
  colsInfo() {
    let i = new Array(this.width), t = 0;
    for (let r = 0; r < this.width; r++) {
      let n = {
        col: t,
        positivePixel: 0,
        negativePixel: 0,
        zeroPixel: 0,
        positiveRoi: 0,
        negativeRoi: 0,
        medianChange: 0
      };
      i[t++] = n;
      let a = {}, s = {}, o = [], h = this.data[r], l = 0;
      for (let f = r; f < r + this.data.length; f += this.width) {
        let b = this.data[f];
        h !== b && (h = b, o.push(l), l = 0), l++, b > 0 ? (n.positivePixel++, a[b] || (a[b] = !0)) : b < 0 ? (n.negativePixel++, s[b] || (s[b] = !0)) : n.zeroPixel++;
      }
      o.push(l), n.medianChange = o.sort((f, b) => f - b)[Math.floor(o.length / 2)], n.positiveRoiIDs = Object.keys(a), n.negativeRoiIDs = Object.keys(s), n.positiveRoi = n.positiveRoiIDs.length, n.negativeRoi = n.negativeRoiIDs.length;
    }
    return i;
  }
}
function fromMask(e, i = {}) {
  const { allowCorners: t = !1 } = i, r = 65535;
  let n = new Int16Array(e.size), a = 0, s = 0, o = new Uint16Array(r + 1), h = new Uint16Array(r + 1);
  for (let f = 0; f < e.width; f++)
    for (let b = 0; b < e.height; b++)
      n[b * e.width + f] === 0 && l(f, b);
  function l(f, b) {
    let w = 0, g = 0, E = e.getBitXY(f, b), k = E ? ++a : --s;
    if (a > 32767 || s < -32768)
      throw new Error("Too many regions of interest");
    for (o[0] = f, h[0] = b; w <= g; ) {
      let A = o[w & r], T = h[w & r];
      if (n[T * e.width + A] = k, A > 0 && n[T * e.width + A - 1] === 0 && e.getBitXY(A - 1, T) === E && (g++, o[g & r] = A - 1, h[g & r] = T, n[T * e.width + A - 1] = -32768), T > 0 && n[(T - 1) * e.width + A] === 0 && e.getBitXY(A, T - 1) === E && (g++, o[g & r] = A, h[g & r] = T - 1, n[(T - 1) * e.width + A] = -32768), A < e.width - 1 && n[T * e.width + A + 1] === 0 && e.getBitXY(A + 1, T) === E && (g++, o[g & r] = A + 1, h[g & r] = T, n[T * e.width + A + 1] = -32768), T < e.height - 1 && n[(T + 1) * e.width + A] === 0 && e.getBitXY(A, T + 1) === E && (g++, o[g & r] = A, h[g & r] = T + 1, n[(T + 1) * e.width + A] = -32768), t && (A > 0 && T > 0 && n[(T - 1) * e.width + A - 1] === 0 && e.getBitXY(A - 1, T - 1) === E && (g++, o[g & r] = A - 1, h[g & r] = T - 1, n[(T - 1) * e.width + A - 1] = -32768), A < e.width - 1 && T > 0 && n[(T - 1) * e.width + A + 1] === 0 && e.getBitXY(A + 1, T - 1) === E && (g++, o[g & r] = A + 1, h[g & r] = T - 1, n[(T - 1) * e.width + A + 1] = -32768), A > 0 && T < e.height - 1 && n[(T + 1) * e.width + A - 1] === 0 && e.getBitXY(A - 1, T + 1) === E && (g++, o[g & r] = A - 1, h[g & r] = T + 1, n[(T + 1) * e.width + A - 1] = -32768), A < e.width - 1 && T < e.height - 1 && n[(T + 1) * e.width + A + 1] === 0 && e.getBitXY(A + 1, T + 1) === E && (g++, o[g & r] = A + 1, h[g & r] = T + 1, n[(T + 1) * e.width + A + 1] = -32768)), w++, g - w > r)
        throw new Error(
          "analyseMask can not finish, the array to manage internal data is not big enough.You could improve mask by changing MAX_ARRAY"
        );
    }
  }
  return new RoiMap(e, n);
}
var DisjointSet_1, hasRequiredDisjointSet;
function requireDisjointSet() {
  if (hasRequiredDisjointSet) return DisjointSet_1;
  hasRequiredDisjointSet = 1;
  class e {
    constructor() {
      this.nodes = /* @__PURE__ */ new Map();
    }
    /**
     * Adds an element as a new set
     * @param {*} value
     * @return {DisjointSetNode} Object holding the element
     */
    add(r) {
      var n = this.nodes.get(r);
      return n || (n = new i(r), this.nodes.set(r, n)), n;
    }
    /**
     * Merges the sets that contain x and y
     * @param {DisjointSetNode} x
     * @param {DisjointSetNode} y
     */
    union(r, n) {
      const a = this.find(r), s = this.find(n);
      a !== s && (a.rank < s.rank ? a.parent = s : a.rank > s.rank ? s.parent = a : (s.parent = a, a.rank++));
    }
    /**
     * Finds and returns the root node of the set that contains node
     * @param {DisjointSetNode} node
     * @return {DisjointSetNode}
     */
    find(r) {
      for (var n = r; n.parent !== null; )
        n = n.parent;
      for (var a = r; a.parent !== null; ) {
        var s = a;
        a = a.parent, s.parent = n;
      }
      return n;
    }
    /**
     * Returns true if x and y belong to the same set
     * @param {DisjointSetNode} x
     * @param {DisjointSetNode} y
     */
    connected(r, n) {
      return this.find(r) === this.find(n);
    }
  }
  DisjointSet_1 = e;
  function i(t) {
    this.value = t, this.parent = null, this.rank = 0;
  }
  return DisjointSet_1;
}
var DisjointSetExports = requireDisjointSet();
const DisjointSet = /* @__PURE__ */ getDefaultExportFromCjs(DisjointSetExports), direction4X = [-1, 0], direction4Y = [0, -1], neighbours4 = [null, null], direction8X = [-1, -1, 0, 1], direction8Y = [0, -1, -1, -1], neighbours8 = [null, null, null, null];
function fromMaskConnectedComponentLabelingAlgorithm(e, i = {}) {
  const { allowCorners: t = !1 } = i;
  let r = 4;
  t && (r = 8);
  let n, a, s;
  if (r === 8)
    n = direction8X, a = direction8Y, s = neighbours8;
  else if (r === 4)
    n = direction4X, a = direction4Y, s = neighbours4;
  else
    throw new RangeError(`unsupported neighbours count: ${r}`);
  const o = e.size, h = e.width, l = e.height, f = new Array(o), b = new Uint32Array(o), w = new DisjointSet();
  let g = 1;
  for (let E = 0; E < l; E++)
    for (let k = 0; k < h; k++) {
      const A = k + E * h;
      if (e.getBit(A)) {
        let T = null;
        for (let C = 0; C < s.length; C++) {
          const D = k + n[C], $ = E + a[C];
          if (D >= 0 && $ >= 0 && D < h && $ < l) {
            const P = D + $ * h;
            let z = f[P];
            z ? (s[C] = z, (!T || s[C].value < T.value) && (T = s[C])) : s[C] = null;
          }
        }
        if (!T)
          f[A] = w.add(g++);
        else {
          f[A] = T;
          for (let C = 0; C < s.length; C++)
            s[C] && s[C] !== T && w.union(T, s[C]);
        }
      }
    }
  for (let E = 0; E < l; E++)
    for (let k = 0; k < h; k++) {
      const A = k + E * h;
      e.getBit(A) && (b[A] = w.find(f[A]).value);
    }
  return new RoiMap(e, b);
}
function fromMaxima(e = {}) {
  let { allowCorner: i = !0, onlyTop: t = !1, invert: r = !1 } = e, n = this;
  n.checkProcessable("fromMaxima", { components: [1] });
  const a = 1, s = 2;
  let o = 0, h = 0, l = new Int16Array(n.size), f = new Int8Array(n.size), b = new Float32Array(n.size), w = 1048575, g = new Uint16Array(w + 1), E = new Uint16Array(w + 1), k = 0, A = 0, T = new Uint16Array(w + 1), C = new Uint16Array(w + 1), D = 0, $ = 0;
  for (P(n); k < A; ) {
    let F = g[k & w], O = E[k & w];
    B(F, O, s), k++;
  }
  return new RoiMap(n, l);
  function P({ maxima: F = !0 }) {
    for (let O = 1; O < n.height - 1; O++)
      for (let N = 1; N < n.width - 1; N++) {
        let G = N + O * n.width;
        if (f[G] === 0) {
          let V = F ? n.data[G] : -n.data[N + O * n.width];
          if (n.data[O * n.width + N - 1] > V || n.data[O * n.width + N + 1] > V || n.data[(O - 1) * n.width + N] > V || n.data[(O + 1) * n.width + N] > V || i && (n.data[(O - 1) * n.width + N - 1] > V || n.data[(O - 1) * n.width + N + 1] > V || n.data[(O + 1) * n.width + N - 1] > V || n.data[(O + 1) * n.width + N + 1] > V))
            continue;
          l[G] = F ? ++o : --h, z(N, O) || (F ? --o : ++h);
        }
      }
  }
  function z(F, O) {
    let N = A;
    D = 0, $ = 1, T[0] = F, C[0] = O;
    let G = !0;
    for (; D < $; ) {
      let V = T[D & w], J = C[D & w];
      G &= B(V, J, a), D++;
    }
    if (!G) {
      for (let V = 0; V < $; V++) {
        let J = T[V & w], W = C[V & w] * n.width + J;
        l[W] = 0;
      }
      A = N;
    }
    return G;
  }
  function B(F, O, N) {
    let G = l[O * n.width + F], V = n.data[O * n.width + F];
    for (let J = O - 1; J <= O + 1; J++)
      for (let Q = F - 1; Q <= F + 1; Q++) {
        let W = J * n.width + Q;
        if (f[W] === 0)
          switch (f[W] = 1, b[W] = n.data[W] - V, N) {
            case a:
              if (b[W] === 0) {
                if (Q === 0 || J === 0 || Q === n.width - 1 || J === n.height - 1)
                  return !1;
                l[W] = G, T[$ & w] = Q, C[$ & w] = J, $++;
              } else {
                if (b[W] > 0)
                  return !1;
                t || (l[W] = G, g[A & w] = Q, E[A & w] = J, A++);
              }
              break;
            case s:
              b[W] <= 0 && (l[W] = G, g[A & w] = Q, E[A & w] = J, A++);
              break;
            default:
              throw new Error("unreachable");
          }
      }
    return !0;
  }
}
function fromPoints(e, i = {}) {
  let t = new Shape(i), r = new Int16Array(this.size), n = 0, a = t.getPoints();
  for (let s = 0; s < e.length; s++) {
    n++;
    let o = e[s][0], h = e[s][1];
    for (let l = 0; l < a.length; l++) {
      let f = a[l][0], b = a[l][1];
      o + f >= 0 && h + b >= 0 && o + f < this.width && h + b < this.height && (r[o + f + (h + b) * this.width] = n);
    }
  }
  return new RoiMap(this, r);
}
function commonjsRequire(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var priorityQueue = { exports: {} }, hasRequiredPriorityQueue;
function requirePriorityQueue() {
  return hasRequiredPriorityQueue || (hasRequiredPriorityQueue = 1, function(e, i) {
    (function(t) {
      e.exports = t();
    })(function() {
      return function t(r, n, a) {
        function s(l, f) {
          if (!n[l]) {
            if (!r[l]) {
              var b = typeof commonjsRequire == "function" && commonjsRequire;
              if (!f && b) return b(l, !0);
              if (o) return o(l, !0);
              var w = new Error("Cannot find module '" + l + "'");
              throw w.code = "MODULE_NOT_FOUND", w;
            }
            var g = n[l] = { exports: {} };
            r[l][0].call(g.exports, function(E) {
              var k = r[l][1][E];
              return s(k || E);
            }, g, g.exports, t, r, n, a);
          }
          return n[l].exports;
        }
        for (var o = typeof commonjsRequire == "function" && commonjsRequire, h = 0; h < a.length; h++) s(a[h]);
        return s;
      }({ 1: [function(t, r, n) {
        var a, s, o, h, l, f = function(w, g) {
          for (var E in g)
            b.call(g, E) && (w[E] = g[E]);
          function k() {
            this.constructor = w;
          }
          return k.prototype = g.prototype, w.prototype = new k(), w.__super__ = g.prototype, w;
        }, b = {}.hasOwnProperty;
        a = t("./PriorityQueue/AbstractPriorityQueue"), s = t("./PriorityQueue/ArrayStrategy"), h = t("./PriorityQueue/BinaryHeapStrategy"), o = t("./PriorityQueue/BHeapStrategy"), l = function(w) {
          f(g, w);
          function g(E) {
            E || (E = {}), E.strategy || (E.strategy = h), E.comparator || (E.comparator = function(k, A) {
              return (k || 0) - (A || 0);
            }), g.__super__.constructor.call(this, E);
          }
          return g;
        }(a), l.ArrayStrategy = s, l.BinaryHeapStrategy = h, l.BHeapStrategy = o, r.exports = l;
      }, { "./PriorityQueue/AbstractPriorityQueue": 2, "./PriorityQueue/ArrayStrategy": 3, "./PriorityQueue/BHeapStrategy": 4, "./PriorityQueue/BinaryHeapStrategy": 5 }], 2: [function(t, r, n) {
        r.exports = function() {
          function a(s) {
            var o;
            if ((s != null ? s.strategy : void 0) == null)
              throw "Must pass options.strategy, a strategy";
            if ((s != null ? s.comparator : void 0) == null)
              throw "Must pass options.comparator, a comparator";
            this.priv = new s.strategy(s), this.length = (s != null && (o = s.initialValues) != null ? o.length : void 0) || 0;
          }
          return a.prototype.queue = function(s) {
            this.length++, this.priv.queue(s);
          }, a.prototype.dequeue = function(s) {
            if (!this.length)
              throw "Empty queue";
            return this.length--, this.priv.dequeue();
          }, a.prototype.peek = function(s) {
            if (!this.length)
              throw "Empty queue";
            return this.priv.peek();
          }, a.prototype.clear = function() {
            return this.length = 0, this.priv.clear();
          }, a;
        }();
      }, {}], 3: [function(t, r, n) {
        var a;
        a = function(s, o, h) {
          var l, f, b;
          for (f = 0, l = s.length; f < l; )
            b = f + l >>> 1, h(s[b], o) >= 0 ? f = b + 1 : l = b;
          return f;
        }, r.exports = function() {
          function s(o) {
            var h;
            this.options = o, this.comparator = this.options.comparator, this.data = ((h = this.options.initialValues) != null ? h.slice(0) : void 0) || [], this.data.sort(this.comparator).reverse();
          }
          return s.prototype.queue = function(o) {
            var h;
            h = a(this.data, o, this.comparator), this.data.splice(h, 0, o);
          }, s.prototype.dequeue = function() {
            return this.data.pop();
          }, s.prototype.peek = function() {
            return this.data[this.data.length - 1];
          }, s.prototype.clear = function() {
            this.data.length = 0;
          }, s;
        }();
      }, {}], 4: [function(t, r, n) {
        r.exports = function() {
          function a(s) {
            var o, h, l, f, b, w, g, E;
            for (this.comparator = (s != null ? s.comparator : void 0) || function(k, A) {
              return k - A;
            }, this.pageSize = (s != null ? s.pageSize : void 0) || 512, this.length = 0, g = 0; 1 << g < this.pageSize; )
              g += 1;
            if (1 << g !== this.pageSize)
              throw "pageSize must be a power of two";
            for (this._shift = g, this._emptyMemoryPageTemplate = o = [], h = 0, b = this.pageSize; 0 <= b ? h < b : h > b; 0 <= b ? ++h : --h)
              o.push(null);
            if (this._memory = [], this._mask = this.pageSize - 1, s.initialValues)
              for (w = s.initialValues, l = 0, f = w.length; l < f; l++)
                E = w[l], this.queue(E);
          }
          return a.prototype.queue = function(s) {
            this.length += 1, this._write(this.length, s), this._bubbleUp(this.length, s);
          }, a.prototype.dequeue = function() {
            var s, o;
            return s = this._read(1), o = this._read(this.length), this.length -= 1, this.length > 0 && (this._write(1, o), this._bubbleDown(1, o)), s;
          }, a.prototype.peek = function() {
            return this._read(1);
          }, a.prototype.clear = function() {
            this.length = 0, this._memory.length = 0;
          }, a.prototype._write = function(s, o) {
            var h;
            for (h = s >> this._shift; h >= this._memory.length; )
              this._memory.push(this._emptyMemoryPageTemplate.slice(0));
            return this._memory[h][s & this._mask] = o;
          }, a.prototype._read = function(s) {
            return this._memory[s >> this._shift][s & this._mask];
          }, a.prototype._bubbleUp = function(s, o) {
            var h, l, f, b;
            for (h = this.comparator; s > 1 && (l = s & this._mask, s < this.pageSize || l > 3 ? f = s & ~this._mask | l >> 1 : l < 2 ? (f = s - this.pageSize >> this._shift, f += f & ~(this._mask >> 1), f |= this.pageSize >> 1) : f = s - 2, b = this._read(f), !(h(b, o) < 0)); )
              this._write(f, o), this._write(s, b), s = f;
          }, a.prototype._bubbleDown = function(s, o) {
            var h, l, f, b, w;
            for (w = this.comparator; s < this.length; )
              if (s > this._mask && !(s & this._mask - 1) ? h = l = s + 2 : s & this.pageSize >> 1 ? (h = (s & ~this._mask) >> 1, h |= s & this._mask >> 1, h = h + 1 << this._shift, l = h + 1) : (h = s + (s & this._mask), l = h + 1), h !== l && l <= this.length)
                if (f = this._read(h), b = this._read(l), w(f, o) < 0 && w(f, b) <= 0)
                  this._write(h, o), this._write(s, f), s = h;
                else if (w(b, o) < 0)
                  this._write(l, o), this._write(s, b), s = l;
                else
                  break;
              else if (h <= this.length)
                if (f = this._read(h), w(f, o) < 0)
                  this._write(h, o), this._write(s, f), s = h;
                else
                  break;
              else
                break;
          }, a;
        }();
      }, {}], 5: [function(t, r, n) {
        r.exports = function() {
          function a(s) {
            var o;
            this.comparator = (s != null ? s.comparator : void 0) || function(h, l) {
              return h - l;
            }, this.length = 0, this.data = ((o = s.initialValues) != null ? o.slice(0) : void 0) || [], this._heapify();
          }
          return a.prototype._heapify = function() {
            var s, o, h;
            if (this.data.length > 0)
              for (s = o = 1, h = this.data.length; 1 <= h ? o < h : o > h; s = 1 <= h ? ++o : --o)
                this._bubbleUp(s);
          }, a.prototype.queue = function(s) {
            this.data.push(s), this._bubbleUp(this.data.length - 1);
          }, a.prototype.dequeue = function() {
            var s, o;
            return o = this.data[0], s = this.data.pop(), this.data.length > 0 && (this.data[0] = s, this._bubbleDown(0)), o;
          }, a.prototype.peek = function() {
            return this.data[0];
          }, a.prototype.clear = function() {
            this.length = 0, this.data.length = 0;
          }, a.prototype._bubbleUp = function(s) {
            for (var o, h; s > 0 && (o = s - 1 >>> 1, this.comparator(this.data[s], this.data[o]) < 0); )
              h = this.data[o], this.data[o] = this.data[s], this.data[s] = h, s = o;
          }, a.prototype._bubbleDown = function(s) {
            var o, h, l, f, b;
            for (o = this.data.length - 1; h = (s << 1) + 1, f = h + 1, l = s, h <= o && this.comparator(this.data[h], this.data[l]) < 0 && (l = h), f <= o && this.comparator(this.data[f], this.data[l]) < 0 && (l = f), l !== s; )
              b = this.data[l], this.data[l] = this.data[s], this.data[s] = b, s = l;
          }, a;
        }();
      }, {}] }, {}, [1])(1);
    });
  }(priorityQueue)), priorityQueue.exports;
}
var priorityQueueExports = requirePriorityQueue();
const PriorityQueue = /* @__PURE__ */ getDefaultExportFromCjs(priorityQueueExports), dxs = [1, 0, -1, 0, 1, 1, -1, -1], dys = [0, 1, 0, -1, 1, -1, 1, -1];
function fromWaterShed(e = {}) {
  let {
    points: i,
    mask: t,
    image: r,
    fillMaxValue: n = this.maxValue,
    invert: a = !1
  } = e, s = r || this;
  s.checkProcessable("fromWaterShed", {
    bitDepth: [8, 16],
    components: 1
  }), a = !a, i || (i = s.getLocalMaxima({
    invert: a,
    mask: t
  }));
  let o = a ? 0 : 1, h = new Int16Array(s.size), l = s.width, f = s.height, b = new PriorityQueue({
    comparator: (w, g) => w[2] - g[2],
    strategy: PriorityQueue.BinaryHeapStrategy
  });
  for (let w = 0; w < i.length; w++) {
    let g = i[w][0] + i[w][1] * l;
    h[g] = w + 1;
    let E = s.data[g];
    (a && E <= n || !a && E >= n) && b.queue([i[w][0], i[w][1], E]);
  }
  for (; b.length > 0; ) {
    let w = b.dequeue(), g = w[0] + w[1] * l;
    for (let E = 0; E < 4; E++) {
      let k = w[0] + dxs[E], A = w[1] + dys[E];
      if (k >= 0 && A >= 0 && k < l && A < f) {
        let T = k + A * l;
        if (!t || t.getBit(T) === o) {
          let C = s.data[T];
          (a && C <= n || !a && C >= n) && h[T] === 0 && (h[T] = h[g], b.queue([
            w[0] + dxs[E],
            w[1] + dys[E],
            C
          ]));
        }
      }
    }
  }
  return new RoiMap(s, h);
}
class RoiManager {
  constructor(i, t = {}) {
    this._image = i, this._options = t, this._options.label || (this._options.label = "default"), this._layers = {}, this._painted = null;
  }
  // docs is in the corresponding file
  fromMaxima(i = {}) {
    let t = Object.assign({}, this._options, i), r = fromMaxima.call(this._image, i);
    this._layers[t.label] = new RoiLayer(r, t);
  }
  // docs is in the corresponding file
  fromPoints(i, t = {}) {
    let r = Object.assign({}, this._options, t), n = fromPoints.call(this._image, i, t);
    return this._layers[r.label] = new RoiLayer(n, r), this;
  }
  /**
   * @param {number[]} map
   * @param {object} [options]
   * @return {this}
   */
  putMap(i, t = {}) {
    let r = new RoiMap(this._image, i), n = Object.assign({}, this._options, t);
    return this._layers[n.label] = new RoiLayer(r, n), this;
  }
  // docs is in the corresponding file
  fromWaterShed(i = {}) {
    let t = Object.assign({}, this._options, i), r = fromWaterShed.call(this._image, i);
    this._layers[t.label] = new RoiLayer(r, t);
  }
  // docs is in the corresponding file
  fromMask(i, t = {}) {
    let r = Object.assign({}, this._options, t), n = fromMask.call(this._image, i, t);
    return this._layers[r.label] = new RoiLayer(n, r), this;
  }
  fromMaskConnectedComponentLabelingAlgorithm(i, t = {}) {
    let r = Object.assign({}, this._options, t), n = fromMaskConnectedComponentLabelingAlgorithm.call(
      this._image,
      i,
      t
    );
    return this._layers[r.label] = new RoiLayer(n, r), this;
  }
  /**
   *
   * @param {object} [options]
   * @return {RoiMap}
   */
  getMap(i = {}) {
    let t = Object.assign({}, this._options, i);
    return this._assertLayerWithLabel(t.label), this._layers[t.label].roiMap;
  }
  /**
   * Return statistics about rows
   * @param {object} [options]
   * @return {object[]}
   */
  rowsInfo(i = {}) {
    return this.getMap(i).rowsInfo();
  }
  /**
   * Return statistics about columns
   * @param {object} [options]
   * @return {object[]}
   */
  colsInfo(i = {}) {
    return this.getMap(i).rowsInfo();
  }
  /**
   * Return the IDs of the Regions Of Interest (Roi) as an array of number
   * @param {object} [options]
   * @return {number[]}
   */
  getRoiIds(i = {}) {
    let t = this.getRois(i);
    if (t) {
      let r = new Array(t.length);
      for (let n = 0; n < t.length; n++)
        r[n] = t[n].id;
      return r;
    }
    throw new Error("ROIs not found");
  }
  /**
   * Allows to select ROI based on size, label and sign.
   * @param {object} [options={}]
   * @param {string} [options.label='default'] Label of the layer containing the ROI
   * @param {boolean} [options.positive=true] Select the positive region of interest
   * @param {boolean} [options.negative=true] Select he negative region of interest
   * @param {number} [options.minSurface=0]
   * @param {number} [options.maxSurface=Number.POSITIVE_INFINITY]
   * @param {number} [options.minWidth=0]
   * @param {number} [options.minHeight=Number.POSITIVE_INFINITY]
   * @param {number} [options.maxWidth=0]
   * @param {number} [options.maxHeight=Number.POSITIVE_INFINITY]
   * @param {number} [options.minRatio=0] Ratio width / height
   * @param {number} [options.maxRatio=Number.POSITIVE_INFINITY]
   * @return {Roi[]}
   */
  getRois(i = {}) {
    let {
      label: t = this._options.label,
      positive: r = !0,
      negative: n = !0,
      minSurface: a = 0,
      maxSurface: s = Number.POSITIVE_INFINITY,
      minWidth: o = 0,
      maxWidth: h = Number.POSITIVE_INFINITY,
      minHeight: l = 0,
      maxHeight: f = Number.POSITIVE_INFINITY,
      minRatio: b = 0,
      maxRatio: w = Number.POSITIVE_INFINITY
    } = i;
    if (!this._layers[t])
      throw new Error(`this Roi layer (${t}) does not exist`);
    const g = this._layers[t].roi, E = [];
    for (const k of g)
      (k.id < 0 && n || k.id > 0 && r) && k.surface >= a && k.surface <= s && k.width >= o && k.width <= h && k.height >= l && k.height <= f && k.ratio >= b && k.ratio <= w && E.push(k);
    return E;
  }
  /**
   * Get an ROI by its id.
   * @param {number} roiId
   * @param {object} [options={}]
   * @param {string} [options.label='default'] Label of the layer containing the ROI
   * @return {Roi}
   */
  getRoi(i, t = {}) {
    const { label: r = this._options.label } = t;
    if (!this._layers[r])
      throw new Error(`this Roi layer (${r}) does not exist`);
    const n = this._layers[r].roi.find((a) => a.id === i);
    if (!n)
      throw new Error(`found no Roi with id ${i}`);
    return n;
  }
  /**
   * Returns an array of masks
   * See {@link Roi.getMask} for the options
   * @param {object} [options]
   * @return {Image[]} Retuns an array of masks (1 bit Image)
   */
  getMasks(i = {}) {
    let t = this.getRois(i), r = new Array(t.length);
    for (let n = 0; n < t.length; n++)
      r[n] = t[n].getMask(i);
    return r;
  }
  /**
   * Returns an array of masks
   * See {@link Roi.getAnalysisMasks} for the options
   * @param {object} [options]
   * @return {Image[]} Retuns an array of masks (1 bit Image)
   */
  getAnalysisMasks(i = {}) {
    const { analysisProperty: t } = i;
    let r = `${t}Mask`, n = this.getRois(i);
    return n.length === 0 || !n[0][r] ? [] : n.map((a) => a[r]);
  }
  /**
   *
   * @param {object} [options]
   * @return {number[]}
   */
  getData(i = {}) {
    let t = Object.assign({}, this._options, i);
    return this._assertLayerWithLabel(t.label), this._layers[t.label].roiMap.data;
  }
  /**
   * Paint the ROI on a copy of the image and return this image.
   * For painting options {@link Image.paintMasks}
   * For ROI selection options, see {@link RoiManager.getMasks}
   * @param {object} [options] - all the options to select ROIs
   * @param {string} [options.labelProperty] - Paint a mask property on the image.
   *                                  May be any property of the ROI like
   *                                  for example id, surface, width, height, meanX, meanY.
   * @param {number} [options.pixelSize] Size of a pixel in SI
   * @param {string} [options.unit="pixel"] Unit in which to display the values
   * @return {Image} - The painted RGBA 8 bits image
   */
  paint(i = {}) {
    let { labelProperty: t, analysisProperty: r } = i;
    this._painted || (this._painted = this._image.rgba8());
    let n = this.getMasks(i);
    if (t) {
      const a = this.getRois(i);
      i.labels = a.map((l) => deepValue(l, t));
      const s = Math.max(...i.labels);
      let o = !1, h = !1;
      if (t.includes("surface") ? o = !0 : /(?:perimeter|min|max|external|width|height|length)/.test(t) && (h = !0), isFinite(s)) {
        let l = "";
        if (i.unit !== "pixel" && i.pixelSize && (h || o)) {
          l = o ? `${i.unit}^2` : i.unit;
          let f = o ? "m^2" : "m", b = o ? i.pixelSize ** 2 : i.pixelSize;
          const w = Qty.swiftConverter(f, l);
          i.labels = i.labels.map((g) => w(b * g));
        }
        s > 50 ? i.labels = i.labels.map(
          (f) => Math.round(f) + l
        ) : s > 10 ? i.labels = i.labels.map(
          (f) => f.toFixed(1) + l
        ) : i.labels = i.labels.map(
          (f) => f.toFixed(2) + l
        );
      }
      i.labelsPosition = a.map((l) => [l.meanX, l.meanY]);
    }
    if (this._painted.paintMasks(n, i), r) {
      let a = this.getAnalysisMasks(i);
      this._painted.paintMasks(a, {
        color: i.analysisColor,
        alpha: i.analysisAlpha
      });
    }
    return this._painted;
  }
  // return a mask corresponding to all the selected masks
  getMask(i = {}) {
    let t = new Image(this._image.width, this._image.height, {
      kind: "BINARY"
    }), r = this.getMasks(i);
    for (let n = 0; n < r.length; n++) {
      let a = r[n];
      for (let s = 0; s < a.width; s++)
        for (let o = 0; o < a.height; o++)
          a.getBitXY(s, o) && t.setBitXY(s + a.position[0], o + a.position[1]);
    }
    return t;
  }
  /**
   * Reset the changes to the current painted iamge to the image that was
   * used during the creation of the RoiManager except if a new image is
   * specified as parameter;
   * @param {object} [options]
   * @param {Image} [options.image] A new iamge that you would like to sue for painting over
   */
  resetPainted(i = {}) {
    const { image: t } = i;
    t ? this._painted = this.image.rgba8() : this._painted = this._image.rgba8();
  }
  /**
   * In place modification of the roiMap that joins regions of interest
   * @param {object} [options]
   * @param {string|function(object,number,number)} [options.algorithm='commonBorderLength'] algorithm used to decide which ROIs are merged.
   *      Current implemented algorithms are 'commonBorderLength' that use the parameters
   *      'minCommonBorderLength' and 'maxCommonBorderLength' as well as 'commonBorderRatio' that uses
   *      the parameters 'minCommonBorderRatio' and 'maxCommonBorderRatio'.
   * @param {number} [options.minCommonBorderLength=5] minimal common number of pixels for merging
   * @param {number} [options.maxCommonBorderLength=100] maximal common number of pixels for merging
   * @param {number} [options.minCommonBorderRatio=0.3] minimal common border ratio for merging
   * @param {number} [options.maxCommonBorderRatio=1] maximal common border ratio for merging
   * @return {this}
   */
  mergeRoi(i = {}) {
    const t = this.getMap(i);
    return t.mergeRoi(i), this.putMap(t.data, i), this;
  }
  /**
   * Merge multiple rois into one.
   * All rois in the provided array will be merged into the first one.
   * @param {Array<number>} roiIds - A list of Roi ids to merge
   * @param {object} [options]
   */
  mergeRois(i, t = {}) {
    if (!Array.isArray(i) || i.some((n) => !Number.isInteger(n)))
      throw new Error("Roi ids must be an array of integers");
    if (i.length < 2)
      throw new Error("Roi ids must have at least two elements");
    if (new Set(i).size !== i.length)
      throw new Error("Roi ids must be all different");
    i.forEach((n) => this.getRoi(n));
    const r = this.getMap(t);
    return r.mergeRois(i), this.putMap(r.data, t), this;
  }
  /**
   * Finds all corresponding ROIs for all ROIs in the manager
   * @param {number[]} roiMap
   * @param {object} [options]
   * @return {Array} array of objects returned in correspondingRoisInformation
   */
  findCorrespondingRoi(i, t = {}) {
    let r = this.getRois(t), n = [];
    for (let a = 0; a < r.length; a++) {
      let s = r[a], o = s.minX, h = s.minY, l = s.points, f = Math.sign(s.id), b = correspondingRoisInformation(
        o,
        h,
        l,
        i,
        f
      );
      n.push(b);
    }
    return n;
  }
  _assertLayerWithLabel(i) {
    if (!this._layers[i])
      throw new Error(`no layer with label ${i}`);
  }
}
function correspondingRoisInformation(e, i, t, r, n) {
  let a = {
    id: [],
    surface: [],
    roiSurfaceCovered: [],
    same: 0,
    opposite: 0,
    total: 0
  };
  for (let s = 0; s < t.length; s++) {
    let o = t[s], h = o[0], l = o[1], f = h + e + (l + i) * r.width, b = r.data[f];
    (b > 0 || b < 0) && (a.id.includes(b) ? a.surface[a.id.indexOf(b)] += 1 : (a.id.push(b), a.surface.push(1)));
  }
  for (let s = 0; s < a.id.length; s++)
    Math.sign(a.id[s]) === n ? a.same += a.surface[s] : a.opposite += a.surface[s], a.roiSurfaceCovered[s] = a.surface[s] / t.length;
  return a.total = a.opposite + a.same, a;
}
const objectToString = Object.prototype.toString;
class Image {
  constructor(i, t, r, n) {
    if (arguments.length === 1 ? (n = i, { width: i, height: t, data: r } = n) : r && !r.length && (n = r, { data: r } = n), i === void 0 && (i = 1), t === void 0 && (t = 1), n === void 0 && (n = {}), typeof n != "object" || n === null)
      throw new TypeError("options must be an object");
    if (!Number.isInteger(i) || i <= 0)
      throw new RangeError("width must be a positive integer");
    if (!Number.isInteger(t) || t <= 0)
      throw new RangeError("height must be a positive integer");
    const { kind: a = RGBA } = n;
    if (typeof a != "string")
      throw new TypeError("kind must be a string");
    const s = getKind(a), o = Object.assign({}, n);
    for (const k in s)
      o[k] === void 0 && (o[k] = s[k]);
    verifyKindDefinition(o);
    const { components: h, bitDepth: l, colorModel: f } = o, b = o.alpha + 0, w = i * t, g = h + b, E = l === 32 ? Number.MAX_VALUE : 2 ** l - 1;
    if (r === void 0)
      r = createPixelArray(
        w,
        h,
        b,
        g,
        l,
        E
      );
    else {
      const k = getTheoreticalPixelArraySize(
        w,
        g,
        l
      );
      if (r.length !== k)
        throw new RangeError(
          `incorrect data size: ${r.length}. Should be ${k}`
        );
    }
    this.width = i, this.height = t, this.data = r, this.size = w, this.components = h, this.alpha = b, this.bitDepth = l, this.maxValue = E, this.colorModel = f, this.channels = g, this.meta = n.meta || {}, Object.defineProperty(this, "parent", {
      enumerable: !1,
      writable: !0,
      configurable: !0,
      value: n.parent || null
    }), this.position = n.position || [0, 0], this.computed = null, this.sizes = [this.width, this.height], this.multiplierX = this.channels, this.multiplierY = this.channels * this.width, this.isClamped = this.bitDepth < 32, this.borderSizes = [0, 0];
  }
  get [Symbol.toStringTag]() {
    return "IJSImage";
  }
  static isImage(i) {
    return objectToString.call(i) === "[object IJSImage]";
  }
  /**
   * Creates an image from an HTML Canvas object
   * @param {Canvas} canvas
   * @return {Image}
   */
  static fromCanvas(i) {
    const r = i.getContext("2d").getImageData(0, 0, i.width, i.height);
    return new Image(r.width, r.height, r.data);
  }
  /**
   * Create a new Image based on the characteristics of another one.
   * @param {Image} other
   * @param {object} [options] - Override options to change some parameters
   * @return {Image}
   * @example
   * const newImage = Image.createFrom(image, { width: 100 });
   */
  static createFrom(i, t) {
    const r = getImageParameters(i);
    return Object.assign(
      r,
      {
        parent: i,
        position: [0, 0]
      },
      t
    ), new Image(r);
  }
  /**
   * Create a new manager for regions of interest based on the current image.
   * @param {object} [options]
   * @return {RoiManager}
   */
  getRoiManager(i) {
    return new RoiManager(this, i);
  }
  /**
   * Create a copy a the current image, including its data.
   * @instance
   * @return {Image}
   */
  clone() {
    const i = this.data.slice();
    return new Image(this.width, this.height, i, this);
  }
  apply(i) {
    for (let t = 0; t < this.height; t++)
      for (let r = 0; r < this.width; r++) {
        let n = (t * this.width + r) * this.channels;
        i.call(this, n);
      }
  }
}
setValueMethods(Image);
setBitMethods(Image);
setExportMethods(Image);
Image.prototype.checkProcessable = checkProcessable;
Image.prototype.getRGBAData = getRGBAData;
Image.load = load;
Image.extendMethod = extendMethod;
Image.extendProperty = extendProperty;
extend$1(Image);
var workerTemplate = {}, hasRequiredWorkerTemplate;
function requireWorkerTemplate() {
  if (hasRequiredWorkerTemplate) return workerTemplate;
  hasRequiredWorkerTemplate = 1;
  var e = function() {
    self.window = self;
    function t() {
      this._listeners = {};
    }
    t.prototype.on = function(n, a) {
      if (this._listeners[n])
        throw new RangeError("there is already a listener for " + n);
      if (typeof a != "function")
        throw new TypeError("callback argument must be a function");
      this._listeners[n] = a;
    }, t.prototype._send = function(n, a, s) {
      s === void 0 ? s = [] : Array.isArray(s) || (s = [s]), self.postMessage({
        id: n,
        data: a
      }, s);
    }, t.prototype._trigger = function(n, a) {
      if (!this._listeners[n])
        throw new Error("event " + n + " is not defined");
      this._listeners[n].apply(null, a);
    };
    var r = new t();
    self.onmessage = function(n) {
      switch (n.data.action) {
        case "exec":
          n.data.args.unshift(function(a, s) {
            r._send(n.data.id, a, s);
          }), r._trigger(n.data.event, n.data.args);
          break;
        case "ping":
          r._send(n.data.id, "pong");
          break;
        default:
          throw new Error("unexpected action: " + n.data.action);
      }
    };
  }, i = e.toString().split('"CODE";');
  return workerTemplate.newWorkerURL = function(r, n) {
    var a = new Blob(["(", i[0], "importScripts.apply(self, " + JSON.stringify(n) + `);
`, "(", r, ")();", i[1], ")();"], { type: "application/javascript" });
    return URL.createObjectURL(a);
  }, workerTemplate;
}
var src, hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src;
  hasRequiredSrc = 1;
  var e = requireWorkerTemplate(), i = navigator.hardwareConcurrency || 1;
  function t(r, n) {
    if (typeof r != "string" && typeof r != "function")
      throw new TypeError("func argument must be a function");
    if (n === void 0 && (n = {}), typeof n != "object" || n === null)
      throw new TypeError("options argument must be an object");
    this._workerCode = r.toString(), n.maxWorkers === void 0 || n.maxWorkers === "auto" ? this._numWorkers = Math.min(i - 1, 1) : n.maxWorkers > 0 ? this._numWorkers = Math.min(n.maxWorkers, i) : this._numWorkers = i, this._workers = /* @__PURE__ */ new Map(), this._timeout = n.timeout || 0, this._terminateOnError = !!n.terminateOnError;
    var a = n.deps;
    typeof a == "string" && (a = [a]), Array.isArray(a) || (a = void 0), this._id = 0, this._terminated = !1, this._working = 0, this._waiting = [], this._init(a);
  }
  return t.prototype._init = function(r) {
    for (var n = e.newWorkerURL(this._workerCode, r), a = 0; a < this._numWorkers; a++) {
      var s = new Worker(n);
      s.onmessage = this._onmessage.bind(this, s), s.onerror = this._onerror.bind(this, s), s.running = !1, s.id = a, this._workers.set(s, null);
    }
    URL.revokeObjectURL(n);
  }, t.prototype._onerror = function(r, n) {
    if (!this._terminated) {
      this._working--, r.running = !1;
      var a = this._workers.get(r);
      a && a[1](n.message), this._workers.set(r, null), this._terminateOnError ? this.terminate() : this._exec();
    }
  }, t.prototype._onmessage = function(r, n) {
    if (!this._terminated) {
      this._working--, r.running = !1;
      var a = this._workers.get(r);
      a && a[0](n.data.data), this._workers.set(r, null), this._exec();
    }
  }, t.prototype._exec = function() {
    for (var r of this._workers.keys()) {
      if (this._working === this._numWorkers || this._waiting.length === 0)
        return;
      if (!r.running)
        for (var n = 0; n < this._waiting.length; n++) {
          var a = this._waiting[n];
          if (!(typeof a[4] == "number" && a[4] !== r.id)) {
            this._waiting.splice(n, 1), r.postMessage({
              action: "exec",
              event: a[0],
              args: a[1]
            }, a[2]), r.running = !0, r.time = Date.now(), this._workers.set(r, a[3]), this._working++;
            break;
          }
        }
    }
  }, t.prototype.terminate = function() {
    if (!this._terminated) {
      for (var r of this._workers)
        r[0].terminate(), r[1] && r[1][1](new Error("Terminated"));
      this._workers.clear(), this._waiting = [], this._working = 0, this._terminated = !0;
    }
  }, t.prototype.postAll = function(r, n) {
    if (this._terminated)
      throw new Error("Cannot post (terminated)");
    var a = [];
    for (var s of this._workers.keys())
      a.push(this.post(r, n, [], s.id));
    return Promise.all(a);
  }, t.prototype.post = function(r, n, a, s) {
    n === void 0 && (n = []), a === void 0 && (a = []), Array.isArray(n) || (n = [n]), Array.isArray(a) || (a = [a]);
    var o = this;
    return new Promise(function(h, l) {
      if (o._terminated) throw new Error("Cannot post (terminated)");
      o._waiting.push([r, n, a, [h, l], s]), o._exec();
    });
  }, src = t, src;
}
var srcExports = requireSrc();
const WorkerManager = /* @__PURE__ */ getDefaultExportFromCjs(srcExports), defaultOptions = {
  regression: {
    kernelType: "polynomial",
    kernelOptions: { degree: 2, constant: 1 }
  },
  threshold: 0.02,
  roi: {
    minSurface: 100,
    positive: !1
  },
  sampling: 20,
  include: []
};
function run(e, i, t) {
  i = Object.assign({}, defaultOptions, i);
  const r = this.manager;
  return Array.isArray(e) ? Promise.all(
    e.map(function(n) {
      const a = runOnce(r, n, i);
      return typeof t == "function" && a.then(t), a;
    })
  ) : runOnce(r, e, i);
}
function runOnce(e, i, t) {
  return e.post("data", [i, t]).then(function(r) {
    for (let n in r)
      r[n] = new Image(r[n]);
    return r;
  });
}
function work() {
  worker.on("data", function(e, i, t) {
    i = new IJS(i);
    const r = {}, n = [], a = i.grey(), s = a.sobelFilter();
    g("sobel", s);
    const o = s.level().mask({ threshold: t.threshold });
    g("mask", o);
    const h = s.getRoiManager();
    h.fromMask(o);
    const l = h.getMask(t.roi);
    g("realMask", l);
    const f = a.getPixelsGrid({
      sampling: t.sampling,
      mask: l
    }), b = i.getBackground(
      f.xyS,
      f.zS,
      t.regression
    );
    g("background", b);
    const w = i.subtract(b);
    r.result = w, n.push(w.data.buffer), e(r, n);
    function g(E, k) {
      t.include.includes(E) && (r[E] = k, n.push(k.data.buffer));
    }
  });
}
const background = { run, work };
function extend(e) {
  e.extendMethod("background", background);
}
let Worker$1 = class Pt {
  constructor() {
    this._url = null, this._deps = [null];
  }
  checkUrl() {
    if (this._url === null)
      throw new Error("image worker must be initialized with an URL");
  }
  get url() {
    return this._url;
  }
  set url(i) {
    if (typeof i != "string")
      throw new TypeError("worker URL must be a string");
    this._url = i, this._deps[0] = i;
  }
  static extendMethod(i, t) {
    let r, n, a = {};
    function s(...o) {
      return r || (this.checkUrl(), n = this.url, r = new WorkerManager(t.work, { deps: n }), a.manager = r), t.run.call(a, ...o);
    }
    s.reset = function() {
      r && (r.terminate(), r = new WorkerManager(t.work, { deps: n }), a.manager = r);
    }, Pt.prototype[i] = s;
  }
};
extend(Worker$1);
var lz4$1 = {}, xxh32 = {}, util = {}, hasRequiredUtil;
function requireUtil() {
  return hasRequiredUtil || (hasRequiredUtil = 1, util.hashU32 = function(i) {
    return i = i | 0, i = i + 2127912214 + (i << 12) | 0, i = i ^ -949894596 ^ i >>> 19, i = i + 374761393 + (i << 5) | 0, i = i + -744332180 ^ i << 9, i = i + -42973499 + (i << 3) | 0, i ^ -1252372727 ^ i >>> 16 | 0;
  }, util.readU64 = function(i, t) {
    var r = 0;
    return r |= i[t++] << 0, r |= i[t++] << 8, r |= i[t++] << 16, r |= i[t++] << 24, r |= i[t++] << 32, r |= i[t++] << 40, r |= i[t++] << 48, r |= i[t++] << 56, r;
  }, util.readU32 = function(i, t) {
    var r = 0;
    return r |= i[t++] << 0, r |= i[t++] << 8, r |= i[t++] << 16, r |= i[t++] << 24, r;
  }, util.writeU32 = function(i, t, r) {
    i[t++] = r >> 0 & 255, i[t++] = r >> 8 & 255, i[t++] = r >> 16 & 255, i[t++] = r >> 24 & 255;
  }, util.imul = function(i, t) {
    var r = i >>> 16, n = i & 65535, a = t >>> 16, s = t & 65535;
    return n * s + (r * s + n * a << 16) | 0;
  }), util;
}
var hasRequiredXxh32;
function requireXxh32() {
  if (hasRequiredXxh32) return xxh32;
  hasRequiredXxh32 = 1;
  var e = requireUtil(), i = 2654435761, t = 2246822519, r = 3266489917, n = 668265263, a = 374761393;
  function s(E, k) {
    return E = E | 0, k = k | 0, E >>> (32 - k | 0) | E << k | 0;
  }
  function o(E, k, A) {
    return E = E | 0, k = k | 0, A = A | 0, e.imul(E >>> (32 - k | 0) | E << k, A) | 0;
  }
  function h(E, k) {
    return E = E | 0, k = k | 0, E >>> k ^ E | 0;
  }
  function l(E, k, A, T, C) {
    return o(e.imul(k, A) + E, T, C);
  }
  function f(E, k, A) {
    return o(E + e.imul(k[A], a), 11, i);
  }
  function b(E, k, A) {
    return l(E, e.readU32(k, A), r, 17, n);
  }
  function w(E, k, A) {
    return [
      l(E[0], e.readU32(k, A + 0), t, 13, i),
      l(E[1], e.readU32(k, A + 4), t, 13, i),
      l(E[2], e.readU32(k, A + 8), t, 13, i),
      l(E[3], e.readU32(k, A + 12), t, 13, i)
    ];
  }
  function g(E, k, A, T) {
    var C, D;
    if (D = T, T >= 16) {
      for (C = [
        E + i + t,
        E + t,
        E,
        E - i
      ]; T >= 16; )
        C = w(C, k, A), A += 16, T -= 16;
      C = s(C[0], 1) + s(C[1], 7) + s(C[2], 12) + s(C[3], 18) + D;
    } else
      C = E + a + T >>> 0;
    for (; T >= 4; )
      C = b(C, k, A), A += 4, T -= 4;
    for (; T > 0; )
      C = f(C, k, A), A++, T--;
    return C = h(e.imul(h(e.imul(h(C, 15), t), 13), r), 16), C >>> 0;
  }
  return xxh32.hash = g, xxh32;
}
var hasRequiredLz4;
function requireLz4() {
  return hasRequiredLz4 || (hasRequiredLz4 = 1, function(e) {
    var i = requireXxh32(), t = requireUtil(), r = 4, n = 13, a = 5, s = 6, o = 65536, h = 4, l = (1 << h) - 1, f = 4, b = (1 << f) - 1, w = G(5 << 20), g = O(), E = 407708164, k = 4, A = 8, T = 16, C = 64, D = 192, $ = 2147483648, P = 7, z = 4, B = 7, F = {
      4: 65536,
      5: 262144,
      6: 1048576,
      7: 4194304
    };
    function O() {
      try {
        return new Uint32Array(o);
      } catch {
        for (var J = new Array(o), Q = 0; Q < o; Q++)
          J[Q] = 0;
        return J;
      }
    }
    function N(J) {
      for (var Q = 0; Q < o; Q++)
        g[Q] = 0;
    }
    function G(J) {
      try {
        return new Uint8Array(J);
      } catch {
        for (var Q = new Array(J), W = 0; W < J; W++)
          Q[W] = 0;
        return Q;
      }
    }
    function V(J, Q, W) {
      if (typeof J.buffer !== void 0) {
        if (Uint8Array.prototype.slice)
          return J.slice(Q, W);
        var ne = J.length;
        Q = Q | 0, Q = Q < 0 ? Math.max(ne + Q, 0) : Math.min(Q, ne), W = W === void 0 ? ne : W | 0, W = W < 0 ? Math.max(ne + W, 0) : Math.min(W, ne);
        for (var pe = new Uint8Array(W - Q), be = Q, ve = 0; be < W; )
          pe[ve++] = J[be++];
        return pe;
      } else
        return J.slice(Q, W);
    }
    e.compressBound = function(Q) {
      return Q + Q / 255 + 16 | 0;
    }, e.decompressBound = function(Q) {
      var W = 0;
      if (t.readU32(Q, W) !== E)
        throw new Error("invalid magic number");
      W += 4;
      var ne = Q[W++];
      if ((ne & D) !== C)
        throw new Error("incompatible descriptor version " + (ne & D));
      var pe = (ne & T) !== 0, be = (ne & A) !== 0, ve = Q[W++] >> z & B;
      if (F[ve] === void 0)
        throw new Error("invalid block size " + ve);
      var Ee = F[ve];
      if (be)
        return t.readU64(Q, W);
      W++;
      for (var Ae = 0; ; ) {
        var _e = t.readU32(Q, W);
        if (W += 4, _e & $ ? (_e &= 2147483647, Ae += _e) : Ae += Ee, _e === 0)
          return Ae;
        pe && (W += 4), W += _e;
      }
    }, e.makeBuffer = G, e.decompressBlock = function(Q, W, ne, pe, be) {
      var ve, Ee, Ae, _e, Be;
      for (Ae = ne + pe; ne < Ae; ) {
        var Me = Q[ne++], re = Me >> 4;
        if (re > 0) {
          if (re === 15)
            for (; re += Q[ne], Q[ne++] === 255; )
              ;
          for (_e = ne + re; ne < _e; )
            W[be++] = Q[ne++];
        }
        if (ne >= Ae)
          break;
        if (ve = Me & 15, Ee = Q[ne++] | Q[ne++] << 8, ve === 15)
          for (; ve += Q[ne], Q[ne++] === 255; )
            ;
        for (ve += r, Be = be - Ee, _e = Be + ve; Be < _e; )
          W[be++] = W[Be++] | 0;
      }
      return be;
    }, e.compressBlock = function(Q, W, ne, pe, be) {
      var ve, Ee, Ae, _e, Be, Me, re, Te, Fe;
      if (re = 0, Te = pe + ne, Ee = ne, pe >= n)
        for (var Se = (1 << s) + 3; ne + r < Te - a; ) {
          var Ye = t.readU32(Q, ne), Je = t.hashU32(Ye) >>> 0;
          if (Je = (Je >> 16 ^ Je) >>> 0 & 65535, ve = be[Je] - 1, be[Je] = ne + 1, ve < 0 || ne - ve >>> 16 > 0 || t.readU32(Q, ve) !== Ye) {
            Be = Se++ >> s, ne += Be;
            continue;
          }
          for (Se = (1 << s) + 3, Me = ne - Ee, _e = ne - ve, ne += r, ve += r, Ae = ne; ne < Te - a && Q[ne] === Q[ve]; )
            ne++, ve++;
          Ae = ne - Ae;
          var et = Ae < l ? Ae : l;
          if (Me >= b) {
            for (W[re++] = (b << h) + et, Fe = Me - b; Fe >= 255; Fe -= 255)
              W[re++] = 255;
            W[re++] = Fe;
          } else
            W[re++] = (Me << h) + et;
          for (var Ve = 0; Ve < Me; Ve++)
            W[re++] = Q[Ee + Ve];
          if (W[re++] = _e, W[re++] = _e >> 8, Ae >= l) {
            for (Fe = Ae - l; Fe >= 255; Fe -= 255)
              W[re++] = 255;
            W[re++] = Fe;
          }
          Ee = ne;
        }
      if (Ee === 0)
        return 0;
      if (Me = Te - Ee, Me >= b) {
        for (W[re++] = b << h, Fe = Me - b; Fe >= 255; Fe -= 255)
          W[re++] = 255;
        W[re++] = Fe;
      } else
        W[re++] = Me << h;
      for (ne = Ee; ne < Te; )
        W[re++] = Q[ne++];
      return re;
    }, e.decompressFrame = function(Q, W) {
      var ne, pe, be, ve, Ee = 0, Ae = 0;
      if (t.readU32(Q, Ee) !== E)
        throw new Error("invalid magic number");
      if (Ee += 4, ve = Q[Ee++], (ve & D) !== C)
        throw new Error("incompatible descriptor version");
      ne = (ve & T) !== 0, pe = (ve & k) !== 0, be = (ve & A) !== 0;
      var _e = Q[Ee++] >> z & B;
      if (F[_e] === void 0)
        throw new Error("invalid block size");
      for (be && (Ee += 8), Ee++; ; ) {
        var Be;
        if (Be = t.readU32(Q, Ee), Ee += 4, Be === 0)
          break;
        if (ne && (Ee += 4), (Be & $) !== 0) {
          Be &= 2147483647;
          for (var Me = 0; Me < Be; Me++)
            W[Ae++] = Q[Ee++];
        } else
          Ae = e.decompressBlock(Q, W, Ee, Be, Ae), Ee += Be;
      }
      return pe && (Ee += 4), Ae;
    }, e.compressFrame = function(Q, W) {
      var ne = 0;
      t.writeU32(W, ne, E), ne += 4, W[ne++] = C, W[ne++] = P << z, W[ne] = i.hash(0, W, 4, ne - 4) >> 8, ne++;
      var pe = F[P], be = Q.length, ve = 0;
      for (N(); be > 0; ) {
        var Ee = 0, Ae = be > pe ? pe : be;
        if (Ee = e.compressBlock(Q, w, ve, Ae, g), Ee > Ae || Ee === 0) {
          t.writeU32(W, ne, 2147483648 | Ae), ne += 4;
          for (var _e = ve + Ae; ve < _e; )
            W[ne++] = Q[ve++];
          be -= Ae;
        } else {
          t.writeU32(W, ne, Ee), ne += 4;
          for (var Be = 0; Be < Ee; )
            W[ne++] = w[Be++];
          ve += Ae, be -= Ae;
        }
      }
      return t.writeU32(W, ne, 0), ne += 4, ne;
    }, e.decompress = function(Q, W) {
      var ne, pe;
      return W === void 0 && (W = e.decompressBound(Q)), ne = e.makeBuffer(W), pe = e.decompressFrame(Q, ne), pe !== W && (ne = V(ne, 0, pe)), ne;
    }, e.compress = function(Q, W) {
      var ne, pe;
      return W === void 0 && (W = e.compressBound(Q.length)), ne = e.makeBuffer(W), pe = e.compressFrame(Q, ne), pe !== W && (ne = V(ne, 0, pe)), ne;
    };
  }(lz4$1)), lz4$1;
}
var lz4Exports = requireLz4();
const lz4 = /* @__PURE__ */ getDefaultExportFromCjs(lz4Exports);
var __defProp = Object.defineProperty, __defNormalProp = (e, i, t) => i in e ? __defProp(e, i, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[i] = t, __export = (e, i) => {
  for (var t in i)
    __defProp(e, t, { get: i[t], enumerable: !0 });
}, __publicField = (e, i, t) => (__defNormalProp(e, typeof i != "symbol" ? i + "" : i, t), t), constants_exports = {};
__export(constants_exports, {
  bt709: () => bt709_exports
});
var bt709_exports = {};
__export(bt709_exports, {
  Y: () => Y,
  x: () => x,
  y: () => y
});
var Y = /* @__PURE__ */ ((e) => (e[e.RED = 0.2126] = "RED", e[e.GREEN = 0.7152] = "GREEN", e[e.BLUE = 0.0722] = "BLUE", e[e.WHITE = 1] = "WHITE", e))(Y || {}), x = /* @__PURE__ */ ((e) => (e[e.RED = 0.64] = "RED", e[e.GREEN = 0.3] = "GREEN", e[e.BLUE = 0.15] = "BLUE", e[e.WHITE = 0.3127] = "WHITE", e))(x || {}), y = /* @__PURE__ */ ((e) => (e[e.RED = 0.33] = "RED", e[e.GREEN = 0.6] = "GREEN", e[e.BLUE = 0.06] = "BLUE", e[e.WHITE = 0.329] = "WHITE", e))(y || {}), conversion_exports = {};
__export(conversion_exports, {
  lab2rgb: () => lab2rgb,
  lab2xyz: () => lab2xyz,
  rgb2hsl: () => rgb2hsl,
  rgb2lab: () => rgb2lab,
  rgb2xyz: () => rgb2xyz,
  xyz2lab: () => xyz2lab,
  xyz2rgb: () => xyz2rgb
});
function correctGamma(e) {
  return e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92;
}
function rgb2xyz(e, i, t) {
  return e = correctGamma(e / 255), i = correctGamma(i / 255), t = correctGamma(t / 255), {
    x: e * 0.4124 + i * 0.3576 + t * 0.1805,
    y: e * 0.2126 + i * 0.7152 + t * 0.0722,
    z: e * 0.0193 + i * 0.1192 + t * 0.9505
  };
}
var arithmetic_exports = {};
__export(arithmetic_exports, {
  degrees2radians: () => degrees2radians,
  inRange0to255: () => inRange0to255,
  inRange0to255Rounded: () => inRange0to255Rounded,
  intInRange: () => intInRange,
  max3: () => max3,
  min3: () => min3,
  stableSort: () => stableSort
});
function degrees2radians(e) {
  return e * (Math.PI / 180);
}
function max3(e, i, t) {
  let r = e;
  return r < i && (r = i), r < t && (r = t), r;
}
function min3(e, i, t) {
  let r = e;
  return r > i && (r = i), r > t && (r = t), r;
}
function intInRange(e, i, t) {
  return e > t && (e = t), e < i && (e = i), e | 0;
}
function inRange0to255Rounded(e) {
  return e = Math.round(e), e > 255 ? e = 255 : e < 0 && (e = 0), e;
}
function inRange0to255(e) {
  return e > 255 ? e = 255 : e < 0 && (e = 0), e;
}
function stableSort(e, i) {
  const t = typeof e[0];
  let r;
  if (t === "number" || t === "string") {
    const n = /* @__PURE__ */ Object.create(null);
    for (let a = 0, s = e.length; a < s; a++) {
      const o = e[a];
      n[o] || n[o] === 0 || (n[o] = a);
    }
    r = e.sort((a, s) => i(a, s) || n[a] - n[s]);
  } else {
    const n = e.slice(0);
    r = e.sort((a, s) => i(a, s) || n.indexOf(a) - n.indexOf(s));
  }
  return r;
}
function rgb2hsl(e, i, t) {
  const r = min3(e, i, t), n = max3(e, i, t), a = n - r, s = (r + n) / 510;
  let o = 0;
  s > 0 && s < 1 && (o = a / (s < 0.5 ? n + r : 510 - n - r));
  let h = 0;
  return a > 0 && (n === e ? h = (i - t) / a : n === i ? h = 2 + (t - e) / a : h = 4 + (e - i) / a, h *= 60, h < 0 && (h += 360)), { h, s: o, l: s };
}
var refX = 0.95047, refY = 1, refZ = 1.08883;
function pivot(e) {
  return e > 8856e-6 ? e ** (1 / 3) : 7.787 * e + 16 / 116;
}
function xyz2lab(e, i, t) {
  if (e = pivot(e / refX), i = pivot(i / refY), t = pivot(t / refZ), 116 * i - 16 < 0)
    throw new Error("xxx");
  return {
    L: Math.max(0, 116 * i - 16),
    a: 500 * (e - i),
    b: 200 * (i - t)
  };
}
function rgb2lab(e, i, t) {
  const r = rgb2xyz(e, i, t);
  return xyz2lab(r.x, r.y, r.z);
}
var refX2 = 0.95047, refY2 = 1, refZ2 = 1.08883;
function pivot2(e) {
  return e > 0.206893034 ? e ** 3 : (e - 16 / 116) / 7.787;
}
function lab2xyz(e, i, t) {
  const r = (e + 16) / 116, n = i / 500 + r, a = r - t / 200;
  return {
    x: refX2 * pivot2(n),
    y: refY2 * pivot2(r),
    z: refZ2 * pivot2(a)
  };
}
function correctGamma2(e) {
  return e > 31308e-7 ? 1.055 * e ** (1 / 2.4) - 0.055 : 12.92 * e;
}
function xyz2rgb(e, i, t) {
  const r = correctGamma2(e * 3.2406 + i * -1.5372 + t * -0.4986), n = correctGamma2(e * -0.9689 + i * 1.8758 + t * 0.0415), a = correctGamma2(e * 0.0557 + i * -0.204 + t * 1.057);
  return {
    r: inRange0to255Rounded(r * 255),
    g: inRange0to255Rounded(n * 255),
    b: inRange0to255Rounded(a * 255)
  };
}
function lab2rgb(e, i, t) {
  const r = lab2xyz(e, i, t);
  return xyz2rgb(r.x, r.y, r.z);
}
var distance_exports = {};
__export(distance_exports, {
  AbstractDistanceCalculator: () => AbstractDistanceCalculator,
  AbstractEuclidean: () => AbstractEuclidean,
  AbstractManhattan: () => AbstractManhattan,
  CIE94GraphicArts: () => CIE94GraphicArts,
  CIE94Textiles: () => CIE94Textiles,
  CIEDE2000: () => CIEDE2000,
  CMetric: () => CMetric,
  Euclidean: () => Euclidean,
  EuclideanBT709: () => EuclideanBT709,
  EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha,
  Manhattan: () => Manhattan,
  ManhattanBT709: () => ManhattanBT709,
  ManhattanNommyde: () => ManhattanNommyde,
  PNGQuant: () => PNGQuant
});
var AbstractDistanceCalculator = class {
  constructor() {
    __publicField(this, "_maxDistance"), __publicField(this, "_whitePoint"), this._setDefaults(), this.setWhitePoint(255, 255, 255, 255);
  }
  setWhitePoint(e, i, t, r) {
    this._whitePoint = {
      r: e > 0 ? 255 / e : 0,
      g: i > 0 ? 255 / i : 0,
      b: t > 0 ? 255 / t : 0,
      a: r > 0 ? 255 / r : 0
    }, this._maxDistance = this.calculateRaw(e, i, t, r, 0, 0, 0, 0);
  }
  calculateNormalized(e, i) {
    return this.calculateRaw(e.r, e.g, e.b, e.a, i.r, i.g, i.b, i.a) / this._maxDistance;
  }
}, AbstractCIE94 = class extends AbstractDistanceCalculator {
  calculateRaw(e, i, t, r, n, a, s, o) {
    const h = rgb2lab(inRange0to255(e * this._whitePoint.r), inRange0to255(i * this._whitePoint.g), inRange0to255(t * this._whitePoint.b)), l = rgb2lab(inRange0to255(n * this._whitePoint.r), inRange0to255(a * this._whitePoint.g), inRange0to255(s * this._whitePoint.b)), f = h.L - l.L, b = h.a - l.a, w = h.b - l.b, g = Math.sqrt(h.a * h.a + h.b * h.b), E = Math.sqrt(l.a * l.a + l.b * l.b), k = g - E;
    let A = b * b + w * w - k * k;
    A = A < 0 ? 0 : Math.sqrt(A);
    const T = (o - r) * this._whitePoint.a * this._kA;
    return Math.sqrt((f / this._Kl) ** 2 + (k / (1 + this._K1 * g)) ** 2 + (A / (1 + this._K2 * g)) ** 2 + T ** 2);
  }
}, CIE94Textiles = class extends AbstractCIE94 {
  _setDefaults() {
    this._Kl = 2, this._K1 = 0.048, this._K2 = 0.014, this._kA = 0.25 * 50 / 255;
  }
}, CIE94GraphicArts = class extends AbstractCIE94 {
  _setDefaults() {
    this._Kl = 1, this._K1 = 0.045, this._K2 = 0.015, this._kA = 0.25 * 100 / 255;
  }
}, _CIEDE2000 = class extends AbstractDistanceCalculator {
  _setDefaults() {
  }
  static _calculatehp(e, i) {
    const t = Math.atan2(e, i);
    return t >= 0 ? t : t + _CIEDE2000._deg360InRad;
  }
  static _calculateRT(e, i) {
    const t = i ** 7, r = 2 * Math.sqrt(t / (t + _CIEDE2000._pow25to7)), n = _CIEDE2000._deg30InRad * Math.exp(-(((e - _CIEDE2000._deg275InRad) / _CIEDE2000._deg25InRad) ** 2));
    return -Math.sin(2 * n) * r;
  }
  static _calculateT(e) {
    return 1 - 0.17 * Math.cos(e - _CIEDE2000._deg30InRad) + 0.24 * Math.cos(e * 2) + 0.32 * Math.cos(e * 3 + _CIEDE2000._deg6InRad) - 0.2 * Math.cos(e * 4 - _CIEDE2000._deg63InRad);
  }
  static _calculate_ahp(e, i, t, r) {
    const n = t + r;
    return e === 0 ? n : i <= _CIEDE2000._deg180InRad ? n / 2 : n < _CIEDE2000._deg360InRad ? (n + _CIEDE2000._deg360InRad) / 2 : (n - _CIEDE2000._deg360InRad) / 2;
  }
  static _calculate_dHp(e, i, t, r) {
    let n;
    return e === 0 ? n = 0 : i <= _CIEDE2000._deg180InRad ? n = t - r : t <= r ? n = t - r + _CIEDE2000._deg360InRad : n = t - r - _CIEDE2000._deg360InRad, 2 * Math.sqrt(e) * Math.sin(n / 2);
  }
  calculateRaw(e, i, t, r, n, a, s, o) {
    const h = rgb2lab(inRange0to255(e * this._whitePoint.r), inRange0to255(i * this._whitePoint.g), inRange0to255(t * this._whitePoint.b)), l = rgb2lab(inRange0to255(n * this._whitePoint.r), inRange0to255(a * this._whitePoint.g), inRange0to255(s * this._whitePoint.b)), f = (o - r) * this._whitePoint.a * _CIEDE2000._kA, b = this.calculateRawInLab(h, l);
    return Math.sqrt(b + f * f);
  }
  calculateRawInLab(e, i) {
    const t = e.L, r = e.a, n = e.b, a = i.L, s = i.a, o = i.b, h = Math.sqrt(r * r + n * n), l = Math.sqrt(s * s + o * o), f = ((h + l) / 2) ** 7, b = 0.5 * (1 - Math.sqrt(f / (f + _CIEDE2000._pow25to7))), w = (1 + b) * r, g = (1 + b) * s, E = Math.sqrt(w * w + n * n), k = Math.sqrt(g * g + o * o), A = E * k, T = _CIEDE2000._calculatehp(n, w), C = _CIEDE2000._calculatehp(o, g), D = Math.abs(T - C), $ = a - t, P = k - E, z = _CIEDE2000._calculate_dHp(A, D, C, T), B = _CIEDE2000._calculate_ahp(A, D, T, C), F = _CIEDE2000._calculateT(B), O = (E + k) / 2, N = ((t + a) / 2 - 50) ** 2, G = 1 + 0.015 * N / Math.sqrt(20 + N), V = 1 + 0.045 * O, J = 1 + 0.015 * F * O, Q = _CIEDE2000._calculateRT(B, O), W = $ / G, ne = P / V, pe = z / J;
    return W ** 2 + ne ** 2 + pe ** 2 + Q * ne * pe;
  }
}, CIEDE2000 = _CIEDE2000;
__publicField(CIEDE2000, "_kA", 0.25 * 100 / 255);
__publicField(CIEDE2000, "_pow25to7", 25 ** 7);
__publicField(CIEDE2000, "_deg360InRad", degrees2radians(360));
__publicField(CIEDE2000, "_deg180InRad", degrees2radians(180));
__publicField(CIEDE2000, "_deg30InRad", degrees2radians(30));
__publicField(CIEDE2000, "_deg6InRad", degrees2radians(6));
__publicField(CIEDE2000, "_deg63InRad", degrees2radians(63));
__publicField(CIEDE2000, "_deg275InRad", degrees2radians(275));
__publicField(CIEDE2000, "_deg25InRad", degrees2radians(25));
var CMetric = class extends AbstractDistanceCalculator {
  calculateRaw(e, i, t, r, n, a, s, o) {
    const h = (e + n) / 2 * this._whitePoint.r, l = (e - n) * this._whitePoint.r, f = (i - a) * this._whitePoint.g, b = (t - s) * this._whitePoint.b, w = ((512 + h) * l * l >> 8) + 4 * f * f + ((767 - h) * b * b >> 8), g = (o - r) * this._whitePoint.a;
    return Math.sqrt(w + g * g);
  }
  _setDefaults() {
  }
}, AbstractEuclidean = class extends AbstractDistanceCalculator {
  calculateRaw(e, i, t, r, n, a, s, o) {
    const h = n - e, l = a - i, f = s - t, b = o - r;
    return Math.sqrt(this._kR * h * h + this._kG * l * l + this._kB * f * f + this._kA * b * b);
  }
}, Euclidean = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
  }
}, EuclideanBT709 = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
  }
}, EuclideanBT709NoAlpha = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 0;
  }
}, AbstractManhattan = class extends AbstractDistanceCalculator {
  calculateRaw(e, i, t, r, n, a, s, o) {
    let h = n - e, l = a - i, f = s - t, b = o - r;
    return h < 0 && (h = 0 - h), l < 0 && (l = 0 - l), f < 0 && (f = 0 - f), b < 0 && (b = 0 - b), this._kR * h + this._kG * l + this._kB * f + this._kA * b;
  }
}, Manhattan = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
  }
}, ManhattanNommyde = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 0.4984, this._kG = 0.8625, this._kB = 0.2979, this._kA = 1;
  }
}, ManhattanBT709 = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
  }
}, PNGQuant = class extends AbstractDistanceCalculator {
  calculateRaw(e, i, t, r, n, a, s, o) {
    const h = (o - r) * this._whitePoint.a;
    return this._colordifferenceCh(e * this._whitePoint.r, n * this._whitePoint.r, h) + this._colordifferenceCh(i * this._whitePoint.g, a * this._whitePoint.g, h) + this._colordifferenceCh(t * this._whitePoint.b, s * this._whitePoint.b, h);
  }
  _colordifferenceCh(e, i, t) {
    const r = e - i, n = r + t;
    return r * r + n * n;
  }
  _setDefaults() {
  }
}, palette_exports = {};
__export(palette_exports, {
  AbstractPaletteQuantizer: () => AbstractPaletteQuantizer,
  ColorHistogram: () => ColorHistogram,
  NeuQuant: () => NeuQuant,
  NeuQuantFloat: () => NeuQuantFloat,
  RGBQuant: () => RGBQuant,
  WuColorCube: () => WuColorCube,
  WuQuant: () => WuQuant
});
var AbstractPaletteQuantizer = class {
  quantizeSync() {
    for (const e of this.quantize())
      if (e.palette)
        return e.palette;
    throw new Error("unreachable");
  }
}, Point = class {
  constructor() {
    __publicField(this, "r"), __publicField(this, "g"), __publicField(this, "b"), __publicField(this, "a"), __publicField(this, "uint32"), __publicField(this, "rgba"), this.uint32 = -1 >>> 0, this.r = this.g = this.b = this.a = 0, this.rgba = new Array(4), this.rgba[0] = 0, this.rgba[1] = 0, this.rgba[2] = 0, this.rgba[3] = 0;
  }
  static createByQuadruplet(e) {
    const i = new Point();
    return i.r = e[0] | 0, i.g = e[1] | 0, i.b = e[2] | 0, i.a = e[3] | 0, i._loadUINT32(), i._loadQuadruplet(), i;
  }
  static createByRGBA(e, i, t, r) {
    const n = new Point();
    return n.r = e | 0, n.g = i | 0, n.b = t | 0, n.a = r | 0, n._loadUINT32(), n._loadQuadruplet(), n;
  }
  static createByUint32(e) {
    const i = new Point();
    return i.uint32 = e >>> 0, i._loadRGBA(), i._loadQuadruplet(), i;
  }
  from(e) {
    this.r = e.r, this.g = e.g, this.b = e.b, this.a = e.a, this.uint32 = e.uint32, this.rgba[0] = e.r, this.rgba[1] = e.g, this.rgba[2] = e.b, this.rgba[3] = e.a;
  }
  getLuminosity(e) {
    let i = this.r, t = this.g, r = this.b;
    return e && (i = Math.min(255, 255 - this.a + this.a * i / 255), t = Math.min(255, 255 - this.a + this.a * t / 255), r = Math.min(255, 255 - this.a + this.a * r / 255)), i * 0.2126 + t * 0.7152 + r * 0.0722;
  }
  _loadUINT32() {
    this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
  }
  _loadRGBA() {
    this.r = this.uint32 & 255, this.g = this.uint32 >>> 8 & 255, this.b = this.uint32 >>> 16 & 255, this.a = this.uint32 >>> 24 & 255;
  }
  _loadQuadruplet() {
    this.rgba[0] = this.r, this.rgba[1] = this.g, this.rgba[2] = this.b, this.rgba[3] = this.a;
  }
}, PointContainer = class {
  constructor() {
    __publicField(this, "_pointArray"), __publicField(this, "_width"), __publicField(this, "_height"), this._width = 0, this._height = 0, this._pointArray = [];
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
  setWidth(e) {
    this._width = e;
  }
  setHeight(e) {
    this._height = e;
  }
  getPointArray() {
    return this._pointArray;
  }
  clone() {
    const e = new PointContainer();
    e._width = this._width, e._height = this._height;
    for (let i = 0, t = this._pointArray.length; i < t; i++)
      e._pointArray[i] = Point.createByUint32(this._pointArray[i].uint32 | 0);
    return e;
  }
  toUint32Array() {
    const e = this._pointArray.length, i = new Uint32Array(e);
    for (let t = 0; t < e; t++)
      i[t] = this._pointArray[t].uint32;
    return i;
  }
  toUint8Array() {
    return new Uint8Array(this.toUint32Array().buffer);
  }
  static fromHTMLImageElement(e) {
    const i = e.naturalWidth, t = e.naturalHeight, r = document.createElement("canvas");
    return r.width = i, r.height = t, r.getContext("2d").drawImage(e, 0, 0, i, t, 0, 0, i, t), PointContainer.fromHTMLCanvasElement(r);
  }
  static fromHTMLCanvasElement(e) {
    const i = e.width, t = e.height, n = e.getContext("2d").getImageData(0, 0, i, t);
    return PointContainer.fromImageData(n);
  }
  static fromImageData(e) {
    const i = e.width, t = e.height;
    return PointContainer.fromUint8Array(e.data, i, t);
  }
  static fromUint8Array(e, i, t) {
    switch (Object.prototype.toString.call(e)) {
      case "[object Uint8ClampedArray]":
      case "[object Uint8Array]":
        break;
      default:
        e = new Uint8Array(e);
    }
    const r = new Uint32Array(e.buffer);
    return PointContainer.fromUint32Array(r, i, t);
  }
  static fromUint32Array(e, i, t) {
    const r = new PointContainer();
    r._width = i, r._height = t;
    for (let n = 0, a = e.length; n < a; n++)
      r._pointArray[n] = Point.createByUint32(e[n] | 0);
    return r;
  }
  static fromBuffer(e, i, t) {
    const r = new Uint32Array(e.buffer, e.byteOffset, e.byteLength / Uint32Array.BYTES_PER_ELEMENT);
    return PointContainer.fromUint32Array(r, i, t);
  }
}, hueGroups = 10;
function hueGroup(e, i) {
  const r = 360 / i, n = r / 2;
  for (let a = 1, s = r - n; a < i; a++, s += r)
    if (e >= s && e < s + r)
      return a;
  return 0;
}
var Palette = class {
  constructor() {
    __publicField(this, "_pointContainer"), __publicField(this, "_pointArray", []), __publicField(this, "_i32idx", {}), this._pointContainer = new PointContainer(), this._pointContainer.setHeight(1), this._pointArray = this._pointContainer.getPointArray();
  }
  add(e) {
    this._pointArray.push(e), this._pointContainer.setWidth(this._pointArray.length);
  }
  has(e) {
    for (let i = this._pointArray.length - 1; i >= 0; i--)
      if (e.uint32 === this._pointArray[i].uint32)
        return !0;
    return !1;
  }
  getNearestColor(e, i) {
    return this._pointArray[this._getNearestIndex(e, i) | 0];
  }
  getPointContainer() {
    return this._pointContainer;
  }
  _nearestPointFromCache(e) {
    return typeof this._i32idx[e] == "number" ? this._i32idx[e] : -1;
  }
  _getNearestIndex(e, i) {
    let t = this._nearestPointFromCache("" + i.uint32);
    if (t >= 0)
      return t;
    let r = Number.MAX_VALUE;
    t = 0;
    for (let n = 0, a = this._pointArray.length; n < a; n++) {
      const s = this._pointArray[n], o = e.calculateRaw(i.r, i.g, i.b, i.a, s.r, s.g, s.b, s.a);
      o < r && (r = o, t = n);
    }
    return this._i32idx[i.uint32] = t, t;
  }
  sort() {
    this._i32idx = {}, this._pointArray.sort((e, i) => {
      const t = rgb2hsl(e.r, e.g, e.b), r = rgb2hsl(i.r, i.g, i.b), n = e.r === e.g && e.g === e.b ? 0 : 1 + hueGroup(t.h, hueGroups), s = (i.r === i.g && i.g === i.b ? 0 : 1 + hueGroup(r.h, hueGroups)) - n;
      if (s)
        return -s;
      const o = e.getLuminosity(!0), h = i.getLuminosity(!0);
      if (h - o !== 0)
        return h - o;
      const l = (r.s * 100 | 0) - (t.s * 100 | 0);
      return l ? -l : 0;
    });
  }
}, utils_exports = {};
__export(utils_exports, {
  HueStatistics: () => HueStatistics,
  Palette: () => Palette,
  Point: () => Point,
  PointContainer: () => PointContainer,
  ProgressTracker: () => ProgressTracker,
  arithmetic: () => arithmetic_exports
});
var HueGroup = class {
  constructor() {
    __publicField(this, "num", 0), __publicField(this, "cols", []);
  }
}, HueStatistics = class {
  constructor(e, i) {
    __publicField(this, "_numGroups"), __publicField(this, "_minCols"), __publicField(this, "_stats"), __publicField(this, "_groupsFull"), this._numGroups = e, this._minCols = i, this._stats = [];
    for (let t = 0; t <= e; t++)
      this._stats[t] = new HueGroup();
    this._groupsFull = 0;
  }
  check(e) {
    this._groupsFull === this._numGroups + 1 && (this.check = () => {
    });
    const i = e & 255, t = e >>> 8 & 255, r = e >>> 16 & 255, n = i === t && t === r ? 0 : 1 + hueGroup(rgb2hsl(i, t, r).h, this._numGroups), a = this._stats[n], s = this._minCols;
    a.num++, !(a.num > s) && (a.num === s && this._groupsFull++, a.num <= s && this._stats[n].cols.push(e));
  }
  injectIntoDictionary(e) {
    for (let i = 0; i <= this._numGroups; i++)
      this._stats[i].num <= this._minCols && this._stats[i].cols.forEach((t) => {
        e[t] ? e[t]++ : e[t] = 1;
      });
  }
  injectIntoArray(e) {
    for (let i = 0; i <= this._numGroups; i++)
      this._stats[i].num <= this._minCols && this._stats[i].cols.forEach((t) => {
        e.indexOf(t) === -1 && e.push(t);
      });
  }
}, _ProgressTracker = class {
  constructor(e, i) {
    __publicField(this, "progress"), __publicField(this, "_step"), __publicField(this, "_range"), __publicField(this, "_last"), __publicField(this, "_progressRange"), this._range = e, this._progressRange = i, this._step = Math.max(1, this._range / (_ProgressTracker.steps + 1) | 0), this._last = -this._step, this.progress = 0;
  }
  shouldNotify(e) {
    return e - this._last >= this._step ? (this._last = e, this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange), !0) : !1;
  }
}, ProgressTracker = _ProgressTracker;
__publicField(ProgressTracker, "steps", 100);
var networkBiasShift = 3, Neuron = class {
  constructor(e) {
    __publicField(this, "r"), __publicField(this, "g"), __publicField(this, "b"), __publicField(this, "a"), this.r = this.g = this.b = this.a = e;
  }
  toPoint() {
    return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
  }
  subtract(e, i, t, r) {
    this.r -= e | 0, this.g -= i | 0, this.b -= t | 0, this.a -= r | 0;
  }
}, _NeuQuant = class extends AbstractPaletteQuantizer {
  constructor(e, i = 256) {
    super(), __publicField(this, "_pointArray"), __publicField(this, "_networkSize"), __publicField(this, "_network"), __publicField(this, "_sampleFactor"), __publicField(this, "_radPower"), __publicField(this, "_freq"), __publicField(this, "_bias"), __publicField(this, "_distance"), this._distance = e, this._pointArray = [], this._sampleFactor = 1, this._networkSize = i, this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
  }
  sample(e) {
    this._pointArray = this._pointArray.concat(e.getPointArray());
  }
  *quantize() {
    this._init(), yield* this._learn(), yield {
      palette: this._buildPalette(),
      progress: 100
    };
  }
  _init() {
    this._freq = [], this._bias = [], this._radPower = [], this._network = [];
    for (let e = 0; e < this._networkSize; e++)
      this._network[e] = new Neuron((e << networkBiasShift + 8) / this._networkSize | 0), this._freq[e] = _NeuQuant._initialBias / this._networkSize | 0, this._bias[e] = 0;
  }
  *_learn() {
    let e = this._sampleFactor;
    const i = this._pointArray.length;
    i < _NeuQuant._minpicturebytes && (e = 1);
    const t = 30 + (e - 1) / 3 | 0, r = i / e | 0;
    let n = r / _NeuQuant._nCycles | 0, a = _NeuQuant._initAlpha, s = (this._networkSize >> 3) * _NeuQuant._radiusBias, o = s >> _NeuQuant._radiusBiasShift;
    o <= 1 && (o = 0);
    for (let f = 0; f < o; f++)
      this._radPower[f] = a * ((o * o - f * f) * _NeuQuant._radBias / (o * o)) >>> 0;
    let h;
    i < _NeuQuant._minpicturebytes ? h = 1 : i % _NeuQuant._prime1 !== 0 ? h = _NeuQuant._prime1 : i % _NeuQuant._prime2 !== 0 ? h = _NeuQuant._prime2 : i % _NeuQuant._prime3 !== 0 ? h = _NeuQuant._prime3 : h = _NeuQuant._prime4;
    const l = new ProgressTracker(r, 99);
    for (let f = 0, b = 0; f < r; ) {
      l.shouldNotify(f) && (yield {
        progress: l.progress
      });
      const w = this._pointArray[b], g = w.b << networkBiasShift, E = w.g << networkBiasShift, k = w.r << networkBiasShift, A = w.a << networkBiasShift, T = this._contest(g, E, k, A);
      if (this._alterSingle(a, T, g, E, k, A), o !== 0 && this._alterNeighbour(o, T, g, E, k, A), b += h, b >= i && (b -= i), f++, n === 0 && (n = 1), f % n === 0) {
        a -= a / t | 0, s -= s / _NeuQuant._radiusDecrease | 0, o = s >> _NeuQuant._radiusBiasShift, o <= 1 && (o = 0);
        for (let C = 0; C < o; C++)
          this._radPower[C] = a * ((o * o - C * C) * _NeuQuant._radBias / (o * o)) >>> 0;
      }
    }
  }
  _buildPalette() {
    const e = new Palette();
    return this._network.forEach((i) => {
      e.add(i.toPoint());
    }), e.sort(), e;
  }
  _alterNeighbour(e, i, t, r, n, a) {
    let s = i - e;
    s < -1 && (s = -1);
    let o = i + e;
    o > this._networkSize && (o = this._networkSize);
    let h = i + 1, l = i - 1, f = 1;
    for (; h < o || l > s; ) {
      const b = this._radPower[f++] / _NeuQuant._alphaRadBias;
      if (h < o) {
        const w = this._network[h++];
        w.subtract(b * (w.r - n), b * (w.g - r), b * (w.b - t), b * (w.a - a));
      }
      if (l > s) {
        const w = this._network[l--];
        w.subtract(b * (w.r - n), b * (w.g - r), b * (w.b - t), b * (w.a - a));
      }
    }
  }
  _alterSingle(e, i, t, r, n, a) {
    e /= _NeuQuant._initAlpha;
    const s = this._network[i];
    s.subtract(e * (s.r - n), e * (s.g - r), e * (s.b - t), e * (s.a - a));
  }
  _contest(e, i, t, r) {
    const n = 1020 << networkBiasShift;
    let a = 2147483647, s = a, o = -1, h = o;
    for (let l = 0; l < this._networkSize; l++) {
      const f = this._network[l], b = this._distance.calculateNormalized(f, { r: t, g: i, b: e, a: r }) * n | 0;
      b < a && (a = b, o = l);
      const w = b - (this._bias[l] >> _NeuQuant._initialBiasShift - networkBiasShift);
      w < s && (s = w, h = l);
      const g = this._freq[l] >> _NeuQuant._betaShift;
      this._freq[l] -= g, this._bias[l] += g << _NeuQuant._gammaShift;
    }
    return this._freq[o] += _NeuQuant._beta, this._bias[o] -= _NeuQuant._betaGamma, h;
  }
}, NeuQuant = _NeuQuant;
__publicField(NeuQuant, "_prime1", 499);
__publicField(NeuQuant, "_prime2", 491);
__publicField(NeuQuant, "_prime3", 487);
__publicField(NeuQuant, "_prime4", 503);
__publicField(NeuQuant, "_minpicturebytes", _NeuQuant._prime4);
__publicField(NeuQuant, "_nCycles", 100);
__publicField(NeuQuant, "_initialBiasShift", 16);
__publicField(NeuQuant, "_initialBias", 1 << _NeuQuant._initialBiasShift);
__publicField(NeuQuant, "_gammaShift", 10);
__publicField(NeuQuant, "_betaShift", 10);
__publicField(NeuQuant, "_beta", _NeuQuant._initialBias >> _NeuQuant._betaShift);
__publicField(NeuQuant, "_betaGamma", _NeuQuant._initialBias << _NeuQuant._gammaShift - _NeuQuant._betaShift);
__publicField(NeuQuant, "_radiusBiasShift", 6);
__publicField(NeuQuant, "_radiusBias", 1 << _NeuQuant._radiusBiasShift);
__publicField(NeuQuant, "_radiusDecrease", 30);
__publicField(NeuQuant, "_alphaBiasShift", 10);
__publicField(NeuQuant, "_initAlpha", 1 << _NeuQuant._alphaBiasShift);
__publicField(NeuQuant, "_radBiasShift", 8);
__publicField(NeuQuant, "_radBias", 1 << _NeuQuant._radBiasShift);
__publicField(NeuQuant, "_alphaRadBiasShift", _NeuQuant._alphaBiasShift + _NeuQuant._radBiasShift);
__publicField(NeuQuant, "_alphaRadBias", 1 << _NeuQuant._alphaRadBiasShift);
var networkBiasShift2 = 3, NeuronFloat = class {
  constructor(e) {
    __publicField(this, "r"), __publicField(this, "g"), __publicField(this, "b"), __publicField(this, "a"), this.r = this.g = this.b = this.a = e;
  }
  toPoint() {
    return Point.createByRGBA(this.r >> networkBiasShift2, this.g >> networkBiasShift2, this.b >> networkBiasShift2, this.a >> networkBiasShift2);
  }
  subtract(e, i, t, r) {
    this.r -= e, this.g -= i, this.b -= t, this.a -= r;
  }
}, _NeuQuantFloat = class extends AbstractPaletteQuantizer {
  constructor(e, i = 256) {
    super(), __publicField(this, "_pointArray"), __publicField(this, "_networkSize"), __publicField(this, "_network"), __publicField(this, "_sampleFactor"), __publicField(this, "_radPower"), __publicField(this, "_freq"), __publicField(this, "_bias"), __publicField(this, "_distance"), this._distance = e, this._pointArray = [], this._sampleFactor = 1, this._networkSize = i, this._distance.setWhitePoint(255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2);
  }
  sample(e) {
    this._pointArray = this._pointArray.concat(e.getPointArray());
  }
  *quantize() {
    this._init(), yield* this._learn(), yield {
      palette: this._buildPalette(),
      progress: 100
    };
  }
  _init() {
    this._freq = [], this._bias = [], this._radPower = [], this._network = [];
    for (let e = 0; e < this._networkSize; e++)
      this._network[e] = new NeuronFloat((e << networkBiasShift2 + 8) / this._networkSize), this._freq[e] = _NeuQuantFloat._initialBias / this._networkSize, this._bias[e] = 0;
  }
  *_learn() {
    let e = this._sampleFactor;
    const i = this._pointArray.length;
    i < _NeuQuantFloat._minpicturebytes && (e = 1);
    const t = 30 + (e - 1) / 3, r = i / e;
    let n = r / _NeuQuantFloat._nCycles | 0, a = _NeuQuantFloat._initAlpha, s = (this._networkSize >> 3) * _NeuQuantFloat._radiusBias, o = s >> _NeuQuantFloat._radiusBiasShift;
    o <= 1 && (o = 0);
    for (let f = 0; f < o; f++)
      this._radPower[f] = a * ((o * o - f * f) * _NeuQuantFloat._radBias / (o * o));
    let h;
    i < _NeuQuantFloat._minpicturebytes ? h = 1 : i % _NeuQuantFloat._prime1 !== 0 ? h = _NeuQuantFloat._prime1 : i % _NeuQuantFloat._prime2 !== 0 ? h = _NeuQuantFloat._prime2 : i % _NeuQuantFloat._prime3 !== 0 ? h = _NeuQuantFloat._prime3 : h = _NeuQuantFloat._prime4;
    const l = new ProgressTracker(r, 99);
    for (let f = 0, b = 0; f < r; ) {
      l.shouldNotify(f) && (yield {
        progress: l.progress
      });
      const w = this._pointArray[b], g = w.b << networkBiasShift2, E = w.g << networkBiasShift2, k = w.r << networkBiasShift2, A = w.a << networkBiasShift2, T = this._contest(g, E, k, A);
      if (this._alterSingle(a, T, g, E, k, A), o !== 0 && this._alterNeighbour(o, T, g, E, k, A), b += h, b >= i && (b -= i), f++, n === 0 && (n = 1), f % n === 0) {
        a -= a / t, s -= s / _NeuQuantFloat._radiusDecrease, o = s >> _NeuQuantFloat._radiusBiasShift, o <= 1 && (o = 0);
        for (let C = 0; C < o; C++)
          this._radPower[C] = a * ((o * o - C * C) * _NeuQuantFloat._radBias / (o * o));
      }
    }
  }
  _buildPalette() {
    const e = new Palette();
    return this._network.forEach((i) => {
      e.add(i.toPoint());
    }), e.sort(), e;
  }
  _alterNeighbour(e, i, t, r, n, a) {
    let s = i - e;
    s < -1 && (s = -1);
    let o = i + e;
    o > this._networkSize && (o = this._networkSize);
    let h = i + 1, l = i - 1, f = 1;
    for (; h < o || l > s; ) {
      const b = this._radPower[f++] / _NeuQuantFloat._alphaRadBias;
      if (h < o) {
        const w = this._network[h++];
        w.subtract(b * (w.r - n), b * (w.g - r), b * (w.b - t), b * (w.a - a));
      }
      if (l > s) {
        const w = this._network[l--];
        w.subtract(b * (w.r - n), b * (w.g - r), b * (w.b - t), b * (w.a - a));
      }
    }
  }
  _alterSingle(e, i, t, r, n, a) {
    e /= _NeuQuantFloat._initAlpha;
    const s = this._network[i];
    s.subtract(e * (s.r - n), e * (s.g - r), e * (s.b - t), e * (s.a - a));
  }
  _contest(e, i, t, r) {
    const n = 1020 << networkBiasShift2;
    let a = 2147483647, s = a, o = -1, h = o;
    for (let l = 0; l < this._networkSize; l++) {
      const f = this._network[l], b = this._distance.calculateNormalized(f, { r: t, g: i, b: e, a: r }) * n;
      b < a && (a = b, o = l);
      const w = b - (this._bias[l] >> _NeuQuantFloat._initialBiasShift - networkBiasShift2);
      w < s && (s = w, h = l);
      const g = this._freq[l] >> _NeuQuantFloat._betaShift;
      this._freq[l] -= g, this._bias[l] += g << _NeuQuantFloat._gammaShift;
    }
    return this._freq[o] += _NeuQuantFloat._beta, this._bias[o] -= _NeuQuantFloat._betaGamma, h;
  }
}, NeuQuantFloat = _NeuQuantFloat;
__publicField(NeuQuantFloat, "_prime1", 499);
__publicField(NeuQuantFloat, "_prime2", 491);
__publicField(NeuQuantFloat, "_prime3", 487);
__publicField(NeuQuantFloat, "_prime4", 503);
__publicField(NeuQuantFloat, "_minpicturebytes", _NeuQuantFloat._prime4);
__publicField(NeuQuantFloat, "_nCycles", 100);
__publicField(NeuQuantFloat, "_initialBiasShift", 16);
__publicField(NeuQuantFloat, "_initialBias", 1 << _NeuQuantFloat._initialBiasShift);
__publicField(NeuQuantFloat, "_gammaShift", 10);
__publicField(NeuQuantFloat, "_betaShift", 10);
__publicField(NeuQuantFloat, "_beta", _NeuQuantFloat._initialBias >> _NeuQuantFloat._betaShift);
__publicField(NeuQuantFloat, "_betaGamma", _NeuQuantFloat._initialBias << _NeuQuantFloat._gammaShift - _NeuQuantFloat._betaShift);
__publicField(NeuQuantFloat, "_radiusBiasShift", 6);
__publicField(NeuQuantFloat, "_radiusBias", 1 << _NeuQuantFloat._radiusBiasShift);
__publicField(NeuQuantFloat, "_radiusDecrease", 30);
__publicField(NeuQuantFloat, "_alphaBiasShift", 10);
__publicField(NeuQuantFloat, "_initAlpha", 1 << _NeuQuantFloat._alphaBiasShift);
__publicField(NeuQuantFloat, "_radBiasShift", 8);
__publicField(NeuQuantFloat, "_radBias", 1 << _NeuQuantFloat._radBiasShift);
__publicField(NeuQuantFloat, "_alphaRadBiasShift", _NeuQuantFloat._alphaBiasShift + _NeuQuantFloat._radBiasShift);
__publicField(NeuQuantFloat, "_alphaRadBias", 1 << _NeuQuantFloat._alphaRadBiasShift);
var _ColorHistogram = class {
  constructor(e, i) {
    __publicField(this, "_method"), __publicField(this, "_hueStats"), __publicField(this, "_histogram"), __publicField(this, "_initColors"), __publicField(this, "_minHueCols"), this._method = e, this._minHueCols = i << 2, this._initColors = i << 2, this._hueStats = new HueStatistics(_ColorHistogram._hueGroups, this._minHueCols), this._histogram = /* @__PURE__ */ Object.create(null);
  }
  sample(e) {
    switch (this._method) {
      case 1:
        this._colorStats1D(e);
        break;
      case 2:
        this._colorStats2D(e);
        break;
    }
  }
  getImportanceSortedColorsIDXI32() {
    const e = stableSort(Object.keys(this._histogram), (t, r) => this._histogram[r] - this._histogram[t]);
    if (e.length === 0)
      return [];
    let i;
    switch (this._method) {
      case 1:
        const t = Math.min(e.length, this._initColors), r = e[t - 1], n = this._histogram[r];
        i = e.slice(0, t);
        let a = t;
        const s = e.length;
        for (; a < s && this._histogram[e[a]] === n; )
          i.push(e[a++]);
        this._hueStats.injectIntoArray(i);
        break;
      case 2:
        i = e;
        break;
      default:
        throw new Error("Incorrect method");
    }
    return i.map((t) => +t);
  }
  _colorStats1D(e) {
    const i = this._histogram, t = e.getPointArray(), r = t.length;
    for (let n = 0; n < r; n++) {
      const a = t[n].uint32;
      this._hueStats.check(a), a in i ? i[a]++ : i[a] = 1;
    }
  }
  _colorStats2D(e) {
    const i = e.getWidth(), t = e.getHeight(), r = e.getPointArray(), n = _ColorHistogram._boxSize[0], a = _ColorHistogram._boxSize[1], s = n * a, o = this._makeBoxes(i, t, n, a), h = this._histogram;
    o.forEach((l) => {
      let f = Math.round(l.w * l.h / s) * _ColorHistogram._boxPixels;
      f < 2 && (f = 2);
      const b = {};
      this._iterateBox(l, i, (w) => {
        const g = r[w].uint32;
        this._hueStats.check(g), g in h ? h[g]++ : g in b ? ++b[g] >= f && (h[g] = b[g]) : b[g] = 1;
      });
    }), this._hueStats.injectIntoDictionary(h);
  }
  _iterateBox(e, i, t) {
    const r = e, n = r.y * i + r.x, a = (r.y + r.h - 1) * i + (r.x + r.w - 1), s = i - r.w + 1;
    let o = 0, h = n;
    do
      t.call(this, h), h += ++o % r.w === 0 ? s : 1;
    while (h <= a);
  }
  _makeBoxes(e, i, t, r) {
    const n = e % t, a = i % r, s = e - n, o = i - a, h = [];
    for (let l = 0; l < i; l += r)
      for (let f = 0; f < e; f += t)
        h.push({
          x: f,
          y: l,
          w: f === s ? n : t,
          h: l === o ? a : r
        });
    return h;
  }
}, ColorHistogram = _ColorHistogram;
__publicField(ColorHistogram, "_boxSize", [64, 64]);
__publicField(ColorHistogram, "_boxPixels", 2);
__publicField(ColorHistogram, "_hueGroups", 10);
var RemovedColor = class {
  constructor(e, i, t) {
    __publicField(this, "index"), __publicField(this, "color"), __publicField(this, "distance"), this.index = e, this.color = i, this.distance = t;
  }
}, RGBQuant = class extends AbstractPaletteQuantizer {
  constructor(e, i = 256, t = 2) {
    super(), __publicField(this, "_colors"), __publicField(this, "_initialDistance"), __publicField(this, "_distanceIncrement"), __publicField(this, "_histogram"), __publicField(this, "_distance"), this._distance = e, this._colors = i, this._histogram = new ColorHistogram(t, i), this._initialDistance = 0.01, this._distanceIncrement = 5e-3;
  }
  sample(e) {
    this._histogram.sample(e);
  }
  *quantize() {
    const e = this._histogram.getImportanceSortedColorsIDXI32();
    if (e.length === 0)
      throw new Error("No colors in image");
    yield* this._buildPalette(e);
  }
  *_buildPalette(e) {
    const i = new Palette(), t = i.getPointContainer().getPointArray(), r = new Array(e.length);
    for (let f = 0; f < e.length; f++)
      t.push(Point.createByUint32(e[f])), r[f] = 1;
    const n = t.length, a = [];
    let s = n, o = this._initialDistance;
    const h = new ProgressTracker(s - this._colors, 99);
    for (; s > this._colors; ) {
      a.length = 0;
      for (let f = 0; f < n; f++) {
        if (h.shouldNotify(n - s) && (yield {
          progress: h.progress
        }), r[f] === 0)
          continue;
        const b = t[f];
        for (let w = f + 1; w < n; w++) {
          if (r[w] === 0)
            continue;
          const g = t[w], E = this._distance.calculateNormalized(b, g);
          E < o && (a.push(new RemovedColor(w, g, E)), r[w] = 0, s--);
        }
      }
      o += s > this._colors * 3 ? this._initialDistance : this._distanceIncrement;
    }
    if (s < this._colors) {
      stableSort(a, (b, w) => w.distance - b.distance);
      let f = 0;
      for (; s < this._colors && f < a.length; ) {
        const b = a[f];
        r[b.index] = 1, s++, f++;
      }
    }
    let l = t.length;
    for (let f = l - 1; f >= 0; f--)
      r[f] === 0 && (f !== l - 1 && (t[f] = t[l - 1]), --l);
    t.length = l, i.sort(), yield {
      palette: i,
      progress: 100
    };
  }
};
function createArray1D(e) {
  const i = [];
  for (let t = 0; t < e; t++)
    i[t] = 0;
  return i;
}
function createArray4D(e, i, t, r) {
  const n = new Array(e);
  for (let a = 0; a < e; a++) {
    n[a] = new Array(i);
    for (let s = 0; s < i; s++) {
      n[a][s] = new Array(t);
      for (let o = 0; o < t; o++) {
        n[a][s][o] = new Array(r);
        for (let h = 0; h < r; h++)
          n[a][s][o][h] = 0;
      }
    }
  }
  return n;
}
function createArray3D(e, i, t) {
  const r = new Array(e);
  for (let n = 0; n < e; n++) {
    r[n] = new Array(i);
    for (let a = 0; a < i; a++) {
      r[n][a] = new Array(t);
      for (let s = 0; s < t; s++)
        r[n][a][s] = 0;
    }
  }
  return r;
}
function fillArray3D(e, i, t, r, n) {
  for (let a = 0; a < i; a++) {
    e[a] = [];
    for (let s = 0; s < t; s++) {
      e[a][s] = [];
      for (let o = 0; o < r; o++)
        e[a][s][o] = n;
    }
  }
}
function fillArray1D(e, i, t) {
  for (let r = 0; r < i; r++)
    e[r] = t;
}
var WuColorCube = class {
  constructor() {
    __publicField(this, "redMinimum"), __publicField(this, "redMaximum"), __publicField(this, "greenMinimum"), __publicField(this, "greenMaximum"), __publicField(this, "blueMinimum"), __publicField(this, "blueMaximum"), __publicField(this, "volume"), __publicField(this, "alphaMinimum"), __publicField(this, "alphaMaximum");
  }
}, _WuQuant = class extends AbstractPaletteQuantizer {
  constructor(e, i = 256, t = 5) {
    super(), __publicField(this, "_reds"), __publicField(this, "_greens"), __publicField(this, "_blues"), __publicField(this, "_alphas"), __publicField(this, "_sums"), __publicField(this, "_weights"), __publicField(this, "_momentsRed"), __publicField(this, "_momentsGreen"), __publicField(this, "_momentsBlue"), __publicField(this, "_momentsAlpha"), __publicField(this, "_moments"), __publicField(this, "_table"), __publicField(this, "_pixels"), __publicField(this, "_cubes"), __publicField(this, "_colors"), __publicField(this, "_significantBitsPerChannel"), __publicField(this, "_maxSideIndex"), __publicField(this, "_alphaMaxSideIndex"), __publicField(this, "_sideSize"), __publicField(this, "_alphaSideSize"), __publicField(this, "_distance"), this._distance = e, this._setQuality(t), this._initialize(i);
  }
  sample(e) {
    const i = e.getPointArray();
    for (let t = 0, r = i.length; t < r; t++)
      this._addColor(i[t]);
    this._pixels = this._pixels.concat(i);
  }
  *quantize() {
    yield* this._preparePalette();
    const e = new Palette();
    for (let i = 0; i < this._colors; i++)
      if (this._sums[i] > 0) {
        const t = this._sums[i], r = this._reds[i] / t, n = this._greens[i] / t, a = this._blues[i] / t, s = this._alphas[i] / t, o = Point.createByRGBA(r | 0, n | 0, a | 0, s | 0);
        e.add(o);
      }
    e.sort(), yield {
      palette: e,
      progress: 100
    };
  }
  *_preparePalette() {
    yield* this._calculateMoments();
    let e = 0;
    const i = createArray1D(this._colors);
    for (let s = 1; s < this._colors; ++s) {
      this._cut(this._cubes[e], this._cubes[s]) ? (i[e] = this._cubes[e].volume > 1 ? this._calculateVariance(this._cubes[e]) : 0, i[s] = this._cubes[s].volume > 1 ? this._calculateVariance(this._cubes[s]) : 0) : (i[e] = 0, s--), e = 0;
      let o = i[0];
      for (let h = 1; h <= s; ++h)
        i[h] > o && (o = i[h], e = h);
      if (o <= 0) {
        this._colors = s + 1;
        break;
      }
    }
    const t = [], r = [], n = [], a = [];
    for (let s = 0; s < this._colors; ++s) {
      const o = _WuQuant._volume(this._cubes[s], this._weights);
      o > 0 ? (t[s] = _WuQuant._volume(this._cubes[s], this._momentsRed) / o | 0, r[s] = _WuQuant._volume(this._cubes[s], this._momentsGreen) / o | 0, n[s] = _WuQuant._volume(this._cubes[s], this._momentsBlue) / o | 0, a[s] = _WuQuant._volume(this._cubes[s], this._momentsAlpha) / o | 0) : (t[s] = 0, r[s] = 0, n[s] = 0, a[s] = 0);
    }
    this._reds = createArray1D(this._colors + 1), this._greens = createArray1D(this._colors + 1), this._blues = createArray1D(this._colors + 1), this._alphas = createArray1D(this._colors + 1), this._sums = createArray1D(this._colors + 1);
    for (let s = 0, o = this._pixels.length; s < o; s++) {
      const h = this._pixels[s];
      let f = -1, b = Number.MAX_VALUE;
      for (let w = 0; w < this._colors; w++) {
        const g = t[w], E = r[w], k = n[w], A = a[w], T = this._distance.calculateRaw(g, E, k, A, h.r, h.g, h.b, h.a);
        T < b && (b = T, f = w);
      }
      this._reds[f] += h.r, this._greens[f] += h.g, this._blues[f] += h.b, this._alphas[f] += h.a, this._sums[f]++;
    }
  }
  _addColor(e) {
    const i = 8 - this._significantBitsPerChannel, t = (e.r >> i) + 1, r = (e.g >> i) + 1, n = (e.b >> i) + 1, a = (e.a >> i) + 1;
    this._weights[a][t][r][n]++, this._momentsRed[a][t][r][n] += e.r, this._momentsGreen[a][t][r][n] += e.g, this._momentsBlue[a][t][r][n] += e.b, this._momentsAlpha[a][t][r][n] += e.a, this._moments[a][t][r][n] += this._table[e.r] + this._table[e.g] + this._table[e.b] + this._table[e.a];
  }
  *_calculateMoments() {
    const e = [], i = [], t = [], r = [], n = [], a = [], s = createArray3D(this._sideSize, this._sideSize, this._sideSize), o = createArray3D(this._sideSize, this._sideSize, this._sideSize), h = createArray3D(this._sideSize, this._sideSize, this._sideSize), l = createArray3D(this._sideSize, this._sideSize, this._sideSize), f = createArray3D(this._sideSize, this._sideSize, this._sideSize), b = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    let w = 0;
    const g = new ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);
    for (let E = 1; E <= this._alphaMaxSideIndex; ++E) {
      fillArray3D(s, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(o, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(h, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(l, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(f, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(b, this._sideSize, this._sideSize, this._sideSize, 0);
      for (let k = 1; k <= this._maxSideIndex; ++k, ++w) {
        g.shouldNotify(w) && (yield {
          progress: g.progress
        }), fillArray1D(e, this._sideSize, 0), fillArray1D(i, this._sideSize, 0), fillArray1D(t, this._sideSize, 0), fillArray1D(r, this._sideSize, 0), fillArray1D(n, this._sideSize, 0), fillArray1D(a, this._sideSize, 0);
        for (let A = 1; A <= this._maxSideIndex; ++A) {
          let T = 0, C = 0, D = 0, $ = 0, P = 0, z = 0;
          for (let B = 1; B <= this._maxSideIndex; ++B)
            T += this._weights[E][k][A][B], C += this._momentsRed[E][k][A][B], D += this._momentsGreen[E][k][A][B], $ += this._momentsBlue[E][k][A][B], P += this._momentsAlpha[E][k][A][B], z += this._moments[E][k][A][B], e[B] += T, i[B] += C, t[B] += D, r[B] += $, n[B] += P, a[B] += z, s[k][A][B] = s[k - 1][A][B] + e[B], o[k][A][B] = o[k - 1][A][B] + i[B], h[k][A][B] = h[k - 1][A][B] + t[B], l[k][A][B] = l[k - 1][A][B] + r[B], f[k][A][B] = f[k - 1][A][B] + n[B], b[k][A][B] = b[k - 1][A][B] + a[B], this._weights[E][k][A][B] = this._weights[E - 1][k][A][B] + s[k][A][B], this._momentsRed[E][k][A][B] = this._momentsRed[E - 1][k][A][B] + o[k][A][B], this._momentsGreen[E][k][A][B] = this._momentsGreen[E - 1][k][A][B] + h[k][A][B], this._momentsBlue[E][k][A][B] = this._momentsBlue[E - 1][k][A][B] + l[k][A][B], this._momentsAlpha[E][k][A][B] = this._momentsAlpha[E - 1][k][A][B] + f[k][A][B], this._moments[E][k][A][B] = this._moments[E - 1][k][A][B] + b[k][A][B];
        }
      }
    }
  }
  static _volumeFloat(e, i) {
    return i[e.alphaMaximum][e.redMaximum][e.greenMaximum][e.blueMaximum] - i[e.alphaMaximum][e.redMaximum][e.greenMinimum][e.blueMaximum] - i[e.alphaMaximum][e.redMinimum][e.greenMaximum][e.blueMaximum] + i[e.alphaMaximum][e.redMinimum][e.greenMinimum][e.blueMaximum] - i[e.alphaMinimum][e.redMaximum][e.greenMaximum][e.blueMaximum] + i[e.alphaMinimum][e.redMaximum][e.greenMinimum][e.blueMaximum] + i[e.alphaMinimum][e.redMinimum][e.greenMaximum][e.blueMaximum] - i[e.alphaMinimum][e.redMinimum][e.greenMinimum][e.blueMaximum] - (i[e.alphaMaximum][e.redMaximum][e.greenMaximum][e.blueMinimum] - i[e.alphaMinimum][e.redMaximum][e.greenMaximum][e.blueMinimum] - i[e.alphaMaximum][e.redMaximum][e.greenMinimum][e.blueMinimum] + i[e.alphaMinimum][e.redMaximum][e.greenMinimum][e.blueMinimum] - i[e.alphaMaximum][e.redMinimum][e.greenMaximum][e.blueMinimum] + i[e.alphaMinimum][e.redMinimum][e.greenMaximum][e.blueMinimum] + i[e.alphaMaximum][e.redMinimum][e.greenMinimum][e.blueMinimum] - i[e.alphaMinimum][e.redMinimum][e.greenMinimum][e.blueMinimum]);
  }
  static _volume(e, i) {
    return _WuQuant._volumeFloat(e, i) | 0;
  }
  static _top(e, i, t, r) {
    let n;
    switch (i) {
      case _WuQuant._alpha:
        n = r[t][e.redMaximum][e.greenMaximum][e.blueMaximum] - r[t][e.redMaximum][e.greenMinimum][e.blueMaximum] - r[t][e.redMinimum][e.greenMaximum][e.blueMaximum] + r[t][e.redMinimum][e.greenMinimum][e.blueMaximum] - (r[t][e.redMaximum][e.greenMaximum][e.blueMinimum] - r[t][e.redMaximum][e.greenMinimum][e.blueMinimum] - r[t][e.redMinimum][e.greenMaximum][e.blueMinimum] + r[t][e.redMinimum][e.greenMinimum][e.blueMinimum]);
        break;
      case _WuQuant._red:
        n = r[e.alphaMaximum][t][e.greenMaximum][e.blueMaximum] - r[e.alphaMaximum][t][e.greenMinimum][e.blueMaximum] - r[e.alphaMinimum][t][e.greenMaximum][e.blueMaximum] + r[e.alphaMinimum][t][e.greenMinimum][e.blueMaximum] - (r[e.alphaMaximum][t][e.greenMaximum][e.blueMinimum] - r[e.alphaMaximum][t][e.greenMinimum][e.blueMinimum] - r[e.alphaMinimum][t][e.greenMaximum][e.blueMinimum] + r[e.alphaMinimum][t][e.greenMinimum][e.blueMinimum]);
        break;
      case _WuQuant._green:
        n = r[e.alphaMaximum][e.redMaximum][t][e.blueMaximum] - r[e.alphaMaximum][e.redMinimum][t][e.blueMaximum] - r[e.alphaMinimum][e.redMaximum][t][e.blueMaximum] + r[e.alphaMinimum][e.redMinimum][t][e.blueMaximum] - (r[e.alphaMaximum][e.redMaximum][t][e.blueMinimum] - r[e.alphaMaximum][e.redMinimum][t][e.blueMinimum] - r[e.alphaMinimum][e.redMaximum][t][e.blueMinimum] + r[e.alphaMinimum][e.redMinimum][t][e.blueMinimum]);
        break;
      case _WuQuant._blue:
        n = r[e.alphaMaximum][e.redMaximum][e.greenMaximum][t] - r[e.alphaMaximum][e.redMaximum][e.greenMinimum][t] - r[e.alphaMaximum][e.redMinimum][e.greenMaximum][t] + r[e.alphaMaximum][e.redMinimum][e.greenMinimum][t] - (r[e.alphaMinimum][e.redMaximum][e.greenMaximum][t] - r[e.alphaMinimum][e.redMaximum][e.greenMinimum][t] - r[e.alphaMinimum][e.redMinimum][e.greenMaximum][t] + r[e.alphaMinimum][e.redMinimum][e.greenMinimum][t]);
        break;
      default:
        throw new Error("impossible");
    }
    return n | 0;
  }
  static _bottom(e, i, t) {
    switch (i) {
      case _WuQuant._alpha:
        return -t[e.alphaMinimum][e.redMaximum][e.greenMaximum][e.blueMaximum] + t[e.alphaMinimum][e.redMaximum][e.greenMinimum][e.blueMaximum] + t[e.alphaMinimum][e.redMinimum][e.greenMaximum][e.blueMaximum] - t[e.alphaMinimum][e.redMinimum][e.greenMinimum][e.blueMaximum] - (-t[e.alphaMinimum][e.redMaximum][e.greenMaximum][e.blueMinimum] + t[e.alphaMinimum][e.redMaximum][e.greenMinimum][e.blueMinimum] + t[e.alphaMinimum][e.redMinimum][e.greenMaximum][e.blueMinimum] - t[e.alphaMinimum][e.redMinimum][e.greenMinimum][e.blueMinimum]);
      case _WuQuant._red:
        return -t[e.alphaMaximum][e.redMinimum][e.greenMaximum][e.blueMaximum] + t[e.alphaMaximum][e.redMinimum][e.greenMinimum][e.blueMaximum] + t[e.alphaMinimum][e.redMinimum][e.greenMaximum][e.blueMaximum] - t[e.alphaMinimum][e.redMinimum][e.greenMinimum][e.blueMaximum] - (-t[e.alphaMaximum][e.redMinimum][e.greenMaximum][e.blueMinimum] + t[e.alphaMaximum][e.redMinimum][e.greenMinimum][e.blueMinimum] + t[e.alphaMinimum][e.redMinimum][e.greenMaximum][e.blueMinimum] - t[e.alphaMinimum][e.redMinimum][e.greenMinimum][e.blueMinimum]);
      case _WuQuant._green:
        return -t[e.alphaMaximum][e.redMaximum][e.greenMinimum][e.blueMaximum] + t[e.alphaMaximum][e.redMinimum][e.greenMinimum][e.blueMaximum] + t[e.alphaMinimum][e.redMaximum][e.greenMinimum][e.blueMaximum] - t[e.alphaMinimum][e.redMinimum][e.greenMinimum][e.blueMaximum] - (-t[e.alphaMaximum][e.redMaximum][e.greenMinimum][e.blueMinimum] + t[e.alphaMaximum][e.redMinimum][e.greenMinimum][e.blueMinimum] + t[e.alphaMinimum][e.redMaximum][e.greenMinimum][e.blueMinimum] - t[e.alphaMinimum][e.redMinimum][e.greenMinimum][e.blueMinimum]);
      case _WuQuant._blue:
        return -t[e.alphaMaximum][e.redMaximum][e.greenMaximum][e.blueMinimum] + t[e.alphaMaximum][e.redMaximum][e.greenMinimum][e.blueMinimum] + t[e.alphaMaximum][e.redMinimum][e.greenMaximum][e.blueMinimum] - t[e.alphaMaximum][e.redMinimum][e.greenMinimum][e.blueMinimum] - (-t[e.alphaMinimum][e.redMaximum][e.greenMaximum][e.blueMinimum] + t[e.alphaMinimum][e.redMaximum][e.greenMinimum][e.blueMinimum] + t[e.alphaMinimum][e.redMinimum][e.greenMaximum][e.blueMinimum] - t[e.alphaMinimum][e.redMinimum][e.greenMinimum][e.blueMinimum]);
      default:
        return 0;
    }
  }
  _calculateVariance(e) {
    const i = _WuQuant._volume(e, this._momentsRed), t = _WuQuant._volume(e, this._momentsGreen), r = _WuQuant._volume(e, this._momentsBlue), n = _WuQuant._volume(e, this._momentsAlpha), a = _WuQuant._volumeFloat(e, this._moments), s = _WuQuant._volume(e, this._weights), o = i * i + t * t + r * r + n * n;
    return a - o / s;
  }
  _maximize(e, i, t, r, n, a, s, o, h) {
    const l = _WuQuant._bottom(e, i, this._momentsRed) | 0, f = _WuQuant._bottom(e, i, this._momentsGreen) | 0, b = _WuQuant._bottom(e, i, this._momentsBlue) | 0, w = _WuQuant._bottom(e, i, this._momentsAlpha) | 0, g = _WuQuant._bottom(e, i, this._weights) | 0;
    let E = 0, k = -1;
    for (let A = t; A < r; ++A) {
      let T = l + _WuQuant._top(e, i, A, this._momentsRed), C = f + _WuQuant._top(e, i, A, this._momentsGreen), D = b + _WuQuant._top(e, i, A, this._momentsBlue), $ = w + _WuQuant._top(e, i, A, this._momentsAlpha), P = g + _WuQuant._top(e, i, A, this._weights);
      if (P !== 0) {
        let z = T * T + C * C + D * D + $ * $, B = z / P;
        T = n - T, C = a - C, D = s - D, $ = o - $, P = h - P, P !== 0 && (z = T * T + C * C + D * D + $ * $, B += z / P, B > E && (E = B, k = A));
      }
    }
    return { max: E, position: k };
  }
  _cut(e, i) {
    let t;
    const r = _WuQuant._volume(e, this._momentsRed), n = _WuQuant._volume(e, this._momentsGreen), a = _WuQuant._volume(e, this._momentsBlue), s = _WuQuant._volume(e, this._momentsAlpha), o = _WuQuant._volume(e, this._weights), h = this._maximize(e, _WuQuant._red, e.redMinimum + 1, e.redMaximum, r, n, a, s, o), l = this._maximize(e, _WuQuant._green, e.greenMinimum + 1, e.greenMaximum, r, n, a, s, o), f = this._maximize(e, _WuQuant._blue, e.blueMinimum + 1, e.blueMaximum, r, n, a, s, o), b = this._maximize(e, _WuQuant._alpha, e.alphaMinimum + 1, e.alphaMaximum, r, n, a, s, o);
    if (b.max >= h.max && b.max >= l.max && b.max >= f.max) {
      if (t = _WuQuant._alpha, b.position < 0)
        return !1;
    } else h.max >= b.max && h.max >= l.max && h.max >= f.max ? t = _WuQuant._red : l.max >= b.max && l.max >= h.max && l.max >= f.max ? t = _WuQuant._green : t = _WuQuant._blue;
    switch (i.redMaximum = e.redMaximum, i.greenMaximum = e.greenMaximum, i.blueMaximum = e.blueMaximum, i.alphaMaximum = e.alphaMaximum, t) {
      case _WuQuant._red:
        i.redMinimum = e.redMaximum = h.position, i.greenMinimum = e.greenMinimum, i.blueMinimum = e.blueMinimum, i.alphaMinimum = e.alphaMinimum;
        break;
      case _WuQuant._green:
        i.greenMinimum = e.greenMaximum = l.position, i.redMinimum = e.redMinimum, i.blueMinimum = e.blueMinimum, i.alphaMinimum = e.alphaMinimum;
        break;
      case _WuQuant._blue:
        i.blueMinimum = e.blueMaximum = f.position, i.redMinimum = e.redMinimum, i.greenMinimum = e.greenMinimum, i.alphaMinimum = e.alphaMinimum;
        break;
      case _WuQuant._alpha:
        i.alphaMinimum = e.alphaMaximum = b.position, i.blueMinimum = e.blueMinimum, i.redMinimum = e.redMinimum, i.greenMinimum = e.greenMinimum;
        break;
    }
    return e.volume = (e.redMaximum - e.redMinimum) * (e.greenMaximum - e.greenMinimum) * (e.blueMaximum - e.blueMinimum) * (e.alphaMaximum - e.alphaMinimum), i.volume = (i.redMaximum - i.redMinimum) * (i.greenMaximum - i.greenMinimum) * (i.blueMaximum - i.blueMinimum) * (i.alphaMaximum - i.alphaMinimum), !0;
  }
  _initialize(e) {
    this._colors = e, this._cubes = [];
    for (let i = 0; i < e; i++)
      this._cubes[i] = new WuColorCube();
    this._cubes[0].redMinimum = 0, this._cubes[0].greenMinimum = 0, this._cubes[0].blueMinimum = 0, this._cubes[0].alphaMinimum = 0, this._cubes[0].redMaximum = this._maxSideIndex, this._cubes[0].greenMaximum = this._maxSideIndex, this._cubes[0].blueMaximum = this._maxSideIndex, this._cubes[0].alphaMaximum = this._alphaMaxSideIndex, this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._table = [];
    for (let i = 0; i < 256; ++i)
      this._table[i] = i * i;
    this._pixels = [];
  }
  _setQuality(e = 5) {
    this._significantBitsPerChannel = e, this._maxSideIndex = 1 << this._significantBitsPerChannel, this._alphaMaxSideIndex = this._maxSideIndex, this._sideSize = this._maxSideIndex + 1, this._alphaSideSize = this._alphaMaxSideIndex + 1;
  }
}, WuQuant = _WuQuant;
__publicField(WuQuant, "_alpha", 3);
__publicField(WuQuant, "_red", 2);
__publicField(WuQuant, "_green", 1);
__publicField(WuQuant, "_blue", 0);
var image_exports = {};
__export(image_exports, {
  AbstractImageQuantizer: () => AbstractImageQuantizer,
  ErrorDiffusionArray: () => ErrorDiffusionArray,
  ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel,
  ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma,
  NearestColor: () => NearestColor
});
var AbstractImageQuantizer = class {
  quantizeSync(e, i) {
    for (const t of this.quantize(e, i))
      if (t.pointContainer)
        return t.pointContainer;
    throw new Error("unreachable");
  }
}, NearestColor = class extends AbstractImageQuantizer {
  constructor(e) {
    super(), __publicField(this, "_distance"), this._distance = e;
  }
  *quantize(e, i) {
    const t = e.getPointArray(), r = e.getWidth(), n = e.getHeight(), a = new ProgressTracker(n, 99);
    for (let s = 0; s < n; s++) {
      a.shouldNotify(s) && (yield {
        progress: a.progress
      });
      for (let o = 0, h = s * r; o < r; o++, h++) {
        const l = t[h];
        l.from(i.getNearestColor(this._distance, l));
      }
    }
    yield {
      pointContainer: e,
      progress: 100
    };
  }
}, ErrorDiffusionArrayKernel = /* @__PURE__ */ ((e) => (e[e.FloydSteinberg = 0] = "FloydSteinberg", e[e.FalseFloydSteinberg = 1] = "FalseFloydSteinberg", e[e.Stucki = 2] = "Stucki", e[e.Atkinson = 3] = "Atkinson", e[e.Jarvis = 4] = "Jarvis", e[e.Burkes = 5] = "Burkes", e[e.Sierra = 6] = "Sierra", e[e.TwoSierra = 7] = "TwoSierra", e[e.SierraLite = 8] = "SierraLite", e))(ErrorDiffusionArrayKernel || {}), ErrorDiffusionArray = class extends AbstractImageQuantizer {
  constructor(e, i, t = !0, r = 0, n = !1) {
    super(), __publicField(this, "_minColorDistance"), __publicField(this, "_serpentine"), __publicField(this, "_kernel"), __publicField(this, "_calculateErrorLikeGIMP"), __publicField(this, "_distance"), this._setKernel(i), this._distance = e, this._minColorDistance = r, this._serpentine = t, this._calculateErrorLikeGIMP = n;
  }
  *quantize(e, i) {
    const t = e.getPointArray(), r = new Point(), n = e.getWidth(), a = e.getHeight(), s = [];
    let o = 1, h = 1;
    for (const f of this._kernel) {
      const b = f[2] + 1;
      h < b && (h = b);
    }
    for (let f = 0; f < h; f++)
      this._fillErrorLine(s[f] = [], n);
    const l = new ProgressTracker(a, 99);
    for (let f = 0; f < a; f++) {
      l.shouldNotify(f) && (yield {
        progress: l.progress
      }), this._serpentine && (o *= -1);
      const b = f * n, w = o === 1 ? 0 : n - 1, g = o === 1 ? n : -1;
      this._fillErrorLine(s[0], n), s.push(s.shift());
      const E = s[0];
      for (let k = w, A = b + w; k !== g; k += o, A += o) {
        const T = t[A], C = E[k];
        r.from(T);
        const D = Point.createByRGBA(inRange0to255Rounded(T.r + C[0]), inRange0to255Rounded(T.g + C[1]), inRange0to255Rounded(T.b + C[2]), inRange0to255Rounded(T.a + C[3])), $ = i.getNearestColor(this._distance, D);
        if (T.from($), this._minColorDistance && this._distance.calculateNormalized(r, $) < this._minColorDistance)
          continue;
        let P, z, B, F;
        this._calculateErrorLikeGIMP ? (P = D.r - $.r, z = D.g - $.g, B = D.b - $.b, F = D.a - $.a) : (P = r.r - $.r, z = r.g - $.g, B = r.b - $.b, F = r.a - $.a);
        const O = o === 1 ? 0 : this._kernel.length - 1, N = o === 1 ? this._kernel.length : -1;
        for (let G = O; G !== N; G += o) {
          const V = this._kernel[G][1] * o, J = this._kernel[G][2];
          if (V + k >= 0 && V + k < n && J + f >= 0 && J + f < a) {
            const Q = this._kernel[G][0], W = s[J][V + k];
            W[0] += P * Q, W[1] += z * Q, W[2] += B * Q, W[3] += F * Q;
          }
        }
      }
    }
    yield {
      pointContainer: e,
      progress: 100
    };
  }
  _fillErrorLine(e, i) {
    e.length > i && (e.length = i);
    const t = e.length;
    for (let r = 0; r < t; r++) {
      const n = e[r];
      n[0] = n[1] = n[2] = n[3] = 0;
    }
    for (let r = t; r < i; r++)
      e[r] = [0, 0, 0, 0];
  }
  _setKernel(e) {
    switch (e) {
      case 0:
        this._kernel = [
          [7 / 16, 1, 0],
          [3 / 16, -1, 1],
          [5 / 16, 0, 1],
          [1 / 16, 1, 1]
        ];
        break;
      case 1:
        this._kernel = [
          [3 / 8, 1, 0],
          [3 / 8, 0, 1],
          [2 / 8, 1, 1]
        ];
        break;
      case 2:
        this._kernel = [
          [8 / 42, 1, 0],
          [4 / 42, 2, 0],
          [2 / 42, -2, 1],
          [4 / 42, -1, 1],
          [8 / 42, 0, 1],
          [4 / 42, 1, 1],
          [2 / 42, 2, 1],
          [1 / 42, -2, 2],
          [2 / 42, -1, 2],
          [4 / 42, 0, 2],
          [2 / 42, 1, 2],
          [1 / 42, 2, 2]
        ];
        break;
      case 3:
        this._kernel = [
          [1 / 8, 1, 0],
          [1 / 8, 2, 0],
          [1 / 8, -1, 1],
          [1 / 8, 0, 1],
          [1 / 8, 1, 1],
          [1 / 8, 0, 2]
        ];
        break;
      case 4:
        this._kernel = [
          [7 / 48, 1, 0],
          [5 / 48, 2, 0],
          [3 / 48, -2, 1],
          [5 / 48, -1, 1],
          [7 / 48, 0, 1],
          [5 / 48, 1, 1],
          [3 / 48, 2, 1],
          [1 / 48, -2, 2],
          [3 / 48, -1, 2],
          [5 / 48, 0, 2],
          [3 / 48, 1, 2],
          [1 / 48, 2, 2]
        ];
        break;
      case 5:
        this._kernel = [
          [8 / 32, 1, 0],
          [4 / 32, 2, 0],
          [2 / 32, -2, 1],
          [4 / 32, -1, 1],
          [8 / 32, 0, 1],
          [4 / 32, 1, 1],
          [2 / 32, 2, 1]
        ];
        break;
      case 6:
        this._kernel = [
          [5 / 32, 1, 0],
          [3 / 32, 2, 0],
          [2 / 32, -2, 1],
          [4 / 32, -1, 1],
          [5 / 32, 0, 1],
          [4 / 32, 1, 1],
          [2 / 32, 2, 1],
          [2 / 32, -1, 2],
          [3 / 32, 0, 2],
          [2 / 32, 1, 2]
        ];
        break;
      case 7:
        this._kernel = [
          [4 / 16, 1, 0],
          [3 / 16, 2, 0],
          [1 / 16, -2, 1],
          [2 / 16, -1, 1],
          [3 / 16, 0, 1],
          [2 / 16, 1, 1],
          [1 / 16, 2, 1]
        ];
        break;
      case 8:
        this._kernel = [
          [2 / 4, 1, 0],
          [1 / 4, -1, 1],
          [1 / 4, 0, 1]
        ];
        break;
      default:
        throw new Error(`ErrorDiffusionArray: unknown kernel = ${e}`);
    }
  }
};
function* hilbertCurve(e, i, t) {
  const r = Math.max(e, i), n = Math.floor(Math.log(r) / Math.log(2) + 1), a = new ProgressTracker(e * i, 99), s = {
    width: e,
    height: i,
    level: n,
    callback: t,
    tracker: a,
    index: 0,
    x: 0,
    y: 0
  };
  yield* walkHilbert(
    s,
    1
    /* UP */
  ), visit(
    s,
    0
    /* NONE */
  );
}
function* walkHilbert(e, i) {
  if (!(e.level < 1)) {
    switch (e.tracker.shouldNotify(e.index) && (yield { progress: e.tracker.progress }), e.level--, i) {
      case 2:
        yield* walkHilbert(
          e,
          1
          /* UP */
        ), visit(
          e,
          3
          /* RIGHT */
        ), yield* walkHilbert(
          e,
          2
          /* LEFT */
        ), visit(
          e,
          4
          /* DOWN */
        ), yield* walkHilbert(
          e,
          2
          /* LEFT */
        ), visit(
          e,
          2
          /* LEFT */
        ), yield* walkHilbert(
          e,
          4
          /* DOWN */
        );
        break;
      case 3:
        yield* walkHilbert(
          e,
          4
          /* DOWN */
        ), visit(
          e,
          2
          /* LEFT */
        ), yield* walkHilbert(
          e,
          3
          /* RIGHT */
        ), visit(
          e,
          1
          /* UP */
        ), yield* walkHilbert(
          e,
          3
          /* RIGHT */
        ), visit(
          e,
          3
          /* RIGHT */
        ), yield* walkHilbert(
          e,
          1
          /* UP */
        );
        break;
      case 1:
        yield* walkHilbert(
          e,
          2
          /* LEFT */
        ), visit(
          e,
          4
          /* DOWN */
        ), yield* walkHilbert(
          e,
          1
          /* UP */
        ), visit(
          e,
          3
          /* RIGHT */
        ), yield* walkHilbert(
          e,
          1
          /* UP */
        ), visit(
          e,
          1
          /* UP */
        ), yield* walkHilbert(
          e,
          3
          /* RIGHT */
        );
        break;
      case 4:
        yield* walkHilbert(
          e,
          3
          /* RIGHT */
        ), visit(
          e,
          1
          /* UP */
        ), yield* walkHilbert(
          e,
          4
          /* DOWN */
        ), visit(
          e,
          2
          /* LEFT */
        ), yield* walkHilbert(
          e,
          4
          /* DOWN */
        ), visit(
          e,
          4
          /* DOWN */
        ), yield* walkHilbert(
          e,
          2
          /* LEFT */
        );
        break;
    }
    e.level++;
  }
}
function visit(e, i) {
  switch (e.x >= 0 && e.x < e.width && e.y >= 0 && e.y < e.height && (e.callback(e.x, e.y), e.index++), i) {
    case 2:
      e.x--;
      break;
    case 3:
      e.x++;
      break;
    case 1:
      e.y--;
      break;
    case 4:
      e.y++;
      break;
  }
}
var ErrorDiffusionRiemersma = class extends AbstractImageQuantizer {
  constructor(e, i = 16, t = 1) {
    super(), __publicField(this, "_distance"), __publicField(this, "_weights"), __publicField(this, "_errorQueueSize"), this._distance = e, this._errorQueueSize = i, this._weights = ErrorDiffusionRiemersma._createWeights(t, i);
  }
  *quantize(e, i) {
    const t = e.getPointArray(), r = e.getWidth(), n = e.getHeight(), a = [];
    let s = 0;
    for (let o = 0; o < this._errorQueueSize; o++)
      a[o] = { r: 0, g: 0, b: 0, a: 0 };
    yield* hilbertCurve(r, n, (o, h) => {
      const l = t[o + h * r];
      let { r: f, g: b, b: w, a: g } = l;
      for (let T = 0; T < this._errorQueueSize; T++) {
        const C = this._weights[T], D = a[(T + s) % this._errorQueueSize];
        f += D.r * C, b += D.g * C, w += D.b * C, g += D.a * C;
      }
      const E = Point.createByRGBA(inRange0to255Rounded(f), inRange0to255Rounded(b), inRange0to255Rounded(w), inRange0to255Rounded(g)), k = i.getNearestColor(this._distance, E);
      s = (s + 1) % this._errorQueueSize;
      const A = (s + this._errorQueueSize - 1) % this._errorQueueSize;
      a[A].r = l.r - k.r, a[A].g = l.g - k.g, a[A].b = l.b - k.b, a[A].a = l.a - k.a, l.from(k);
    }), yield {
      pointContainer: e,
      progress: 100
    };
  }
  static _createWeights(e, i) {
    const t = [], r = Math.exp(Math.log(i) / (i - 1));
    for (let n = 0, a = 1; n < i; n++)
      t[n] = (a + 0.5 | 0) / i * e, a *= r;
    return t;
  }
}, quality_exports = {};
__export(quality_exports, {
  ssim: () => ssim
});
var K1 = 0.01, K2 = 0.03;
function ssim(e, i) {
  if (e.getHeight() !== i.getHeight() || e.getWidth() !== i.getWidth())
    throw new Error("Images have different sizes!");
  const r = (1 << 8) - 1, n = (K1 * r) ** 2, a = (K2 * r) ** 2;
  let s = 0, o = 0;
  return iterate(e, i, (h, l, f, b) => {
    let w = 0, g = 0, E = 0;
    for (let D = 0; D < h.length; D++)
      g += (h[D] - f) ** 2, E += (l[D] - b) ** 2, w += (h[D] - f) * (l[D] - b);
    const k = h.length - 1;
    g /= k, E /= k, w /= k;
    const A = (2 * f * b + n) * (2 * w + a), T = (f ** 2 + b ** 2 + n) * (g + E + a), C = A / T;
    o += C, s++;
  }), o / s;
}
function iterate(e, i, t) {
  const n = e.getWidth(), a = e.getHeight();
  for (let s = 0; s < a; s += 8)
    for (let o = 0; o < n; o += 8) {
      const h = Math.min(8, n - o), l = Math.min(8, a - s), f = calculateLumaValuesForWindow(e, o, s, h, l), b = calculateLumaValuesForWindow(i, o, s, h, l), w = calculateAverageLuma(f), g = calculateAverageLuma(b);
      t(f, b, w, g);
    }
}
function calculateLumaValuesForWindow(e, i, t, r, n) {
  const a = e.getPointArray(), s = [];
  let o = 0;
  for (let h = t; h < t + n; h++) {
    const l = h * e.getWidth();
    for (let f = i; f < i + r; f++) {
      const b = a[l + f];
      s[o] = b.r * 0.2126 + b.g * 0.7152 + b.b * 0.0722, o++;
    }
  }
  return s;
}
function calculateAverageLuma(e) {
  let i = 0;
  for (const t of e)
    i += t;
  return i / e.length;
}
typeof setImmediate == "function" ? setImmediate : typeof process < "u" && (process == null || process.nextTick);
function buildPaletteSync(e, {
  colorDistanceFormula: i,
  paletteQuantization: t,
  colors: r
} = {}) {
  const n = colorDistanceFormulaToColorDistance(i), a = paletteQuantizationToPaletteQuantizer(n, t, r);
  return e.forEach((s) => a.sample(s)), a.quantizeSync();
}
function applyPaletteSync(e, i, { colorDistanceFormula: t, imageQuantization: r } = {}) {
  const n = colorDistanceFormulaToColorDistance(t);
  return imageQuantizationToImageQuantizer(n, r).quantizeSync(e, i);
}
function colorDistanceFormulaToColorDistance(e = "euclidean-bt709") {
  switch (e) {
    case "cie94-graphic-arts":
      return new CIE94GraphicArts();
    case "cie94-textiles":
      return new CIE94Textiles();
    case "ciede2000":
      return new CIEDE2000();
    case "color-metric":
      return new CMetric();
    case "euclidean":
      return new Euclidean();
    case "euclidean-bt709":
      return new EuclideanBT709();
    case "euclidean-bt709-noalpha":
      return new EuclideanBT709NoAlpha();
    case "manhattan":
      return new Manhattan();
    case "manhattan-bt709":
      return new ManhattanBT709();
    case "manhattan-nommyde":
      return new ManhattanNommyde();
    case "pngquant":
      return new PNGQuant();
    default:
      throw new Error(`Unknown colorDistanceFormula ${e}`);
  }
}
function imageQuantizationToImageQuantizer(e, i = "floyd-steinberg") {
  switch (i) {
    case "nearest":
      return new NearestColor(e);
    case "riemersma":
      return new ErrorDiffusionRiemersma(e);
    case "floyd-steinberg":
      return new ErrorDiffusionArray(
        e,
        0
        /* FloydSteinberg */
      );
    case "false-floyd-steinberg":
      return new ErrorDiffusionArray(
        e,
        1
        /* FalseFloydSteinberg */
      );
    case "stucki":
      return new ErrorDiffusionArray(
        e,
        2
        /* Stucki */
      );
    case "atkinson":
      return new ErrorDiffusionArray(
        e,
        3
        /* Atkinson */
      );
    case "jarvis":
      return new ErrorDiffusionArray(
        e,
        4
        /* Jarvis */
      );
    case "burkes":
      return new ErrorDiffusionArray(
        e,
        5
        /* Burkes */
      );
    case "sierra":
      return new ErrorDiffusionArray(
        e,
        6
        /* Sierra */
      );
    case "two-sierra":
      return new ErrorDiffusionArray(
        e,
        7
        /* TwoSierra */
      );
    case "sierra-lite":
      return new ErrorDiffusionArray(
        e,
        8
        /* SierraLite */
      );
    default:
      throw new Error(`Unknown imageQuantization ${i}`);
  }
}
function paletteQuantizationToPaletteQuantizer(e, i = "wuquant", t = 256) {
  switch (i) {
    case "neuquant":
      return new NeuQuant(e, t);
    case "rgbquant":
      return new RGBQuant(e, t);
    case "wuquant":
      return new WuQuant(e, t);
    case "neuquant-float":
      return new NeuQuantFloat(e, t);
    default:
      throw new Error(`Unknown paletteQuantization ${i}`);
  }
}
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * cie94.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ciede2000.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * cmetric.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * common.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * constants.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ditherErrorDiffusionArray.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * euclidean.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * helper.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * hueStatistics.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * lab2rgb.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * lab2xyz.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * manhattanNeuQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * nearestColor.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * palette.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * pngQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * point.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * pointContainer.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2hsl.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2lab.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2xyz.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ssim.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * wuQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * xyz2lab.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * xyz2rgb.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * MIT License
 *
 * Copyright 2015-2018 Igor Bezkrovnyi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * riemersma.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * colorHistogram.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * neuquant.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgbquant.ts - part of Image Quantization Library
 */
var common = {}, hasRequiredCommon;
function requireCommon() {
  return hasRequiredCommon || (hasRequiredCommon = 1, function(e) {
    var i = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
    function t(a, s) {
      return Object.prototype.hasOwnProperty.call(a, s);
    }
    e.assign = function(a) {
      for (var s = Array.prototype.slice.call(arguments, 1); s.length; ) {
        var o = s.shift();
        if (o) {
          if (typeof o != "object")
            throw new TypeError(o + "must be non-object");
          for (var h in o)
            t(o, h) && (a[h] = o[h]);
        }
      }
      return a;
    }, e.shrinkBuf = function(a, s) {
      return a.length === s ? a : a.subarray ? a.subarray(0, s) : (a.length = s, a);
    };
    var r = {
      arraySet: function(a, s, o, h, l) {
        if (s.subarray && a.subarray) {
          a.set(s.subarray(o, o + h), l);
          return;
        }
        for (var f = 0; f < h; f++)
          a[l + f] = s[o + f];
      },
      // Join array of chunks to single array.
      flattenChunks: function(a) {
        var s, o, h, l, f, b;
        for (h = 0, s = 0, o = a.length; s < o; s++)
          h += a[s].length;
        for (b = new Uint8Array(h), l = 0, s = 0, o = a.length; s < o; s++)
          f = a[s], b.set(f, l), l += f.length;
        return b;
      }
    }, n = {
      arraySet: function(a, s, o, h, l) {
        for (var f = 0; f < h; f++)
          a[l + f] = s[o + f];
      },
      // Join array of chunks to single array.
      flattenChunks: function(a) {
        return [].concat.apply([], a);
      }
    };
    e.setTyped = function(a) {
      a ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, r)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, n));
    }, e.setTyped(i);
  }(common)), common;
}
var deflate$1 = {}, deflate = {}, trees = {}, hasRequiredTrees;
function requireTrees() {
  if (hasRequiredTrees) return trees;
  hasRequiredTrees = 1;
  var e = requireCommon(), i = 4, t = 0, r = 1, n = 2;
  function a(Z) {
    for (var ue = Z.length; --ue >= 0; )
      Z[ue] = 0;
  }
  var s = 0, o = 1, h = 2, l = 3, f = 258, b = 29, w = 256, g = w + 1 + b, E = 30, k = 19, A = 2 * g + 1, T = 15, C = 16, D = 7, $ = 256, P = 16, z = 17, B = 18, F = (
    /* extra bits for each length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
  ), O = (
    /* extra bits for each distance code */
    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
  ), N = (
    /* extra bits for each bit length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
  ), G = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], V = 512, J = new Array((g + 2) * 2);
  a(J);
  var Q = new Array(E * 2);
  a(Q);
  var W = new Array(V);
  a(W);
  var ne = new Array(f - l + 1);
  a(ne);
  var pe = new Array(b);
  a(pe);
  var be = new Array(E);
  a(be);
  function ve(Z, ue, xe, ke, te) {
    this.static_tree = Z, this.extra_bits = ue, this.extra_base = xe, this.elems = ke, this.max_length = te, this.has_stree = Z && Z.length;
  }
  var Ee, Ae, _e;
  function Be(Z, ue) {
    this.dyn_tree = Z, this.max_code = 0, this.stat_desc = ue;
  }
  function Me(Z) {
    return Z < 256 ? W[Z] : W[256 + (Z >>> 7)];
  }
  function re(Z, ue) {
    Z.pending_buf[Z.pending++] = ue & 255, Z.pending_buf[Z.pending++] = ue >>> 8 & 255;
  }
  function Te(Z, ue, xe) {
    Z.bi_valid > C - xe ? (Z.bi_buf |= ue << Z.bi_valid & 65535, re(Z, Z.bi_buf), Z.bi_buf = ue >> C - Z.bi_valid, Z.bi_valid += xe - C) : (Z.bi_buf |= ue << Z.bi_valid & 65535, Z.bi_valid += xe);
  }
  function Fe(Z, ue, xe) {
    Te(
      Z,
      xe[ue * 2],
      xe[ue * 2 + 1]
      /*.Len*/
    );
  }
  function Se(Z, ue) {
    var xe = 0;
    do
      xe |= Z & 1, Z >>>= 1, xe <<= 1;
    while (--ue > 0);
    return xe >>> 1;
  }
  function Ye(Z) {
    Z.bi_valid === 16 ? (re(Z, Z.bi_buf), Z.bi_buf = 0, Z.bi_valid = 0) : Z.bi_valid >= 8 && (Z.pending_buf[Z.pending++] = Z.bi_buf & 255, Z.bi_buf >>= 8, Z.bi_valid -= 8);
  }
  function Je(Z, ue) {
    var xe = ue.dyn_tree, ke = ue.max_code, te = ue.stat_desc.static_tree, me = ue.stat_desc.has_stree, U = ue.stat_desc.extra_bits, ye = ue.stat_desc.extra_base, it = ue.stat_desc.max_length, I, fe, de, H, ee, oe, We = 0;
    for (H = 0; H <= T; H++)
      Z.bl_count[H] = 0;
    for (xe[Z.heap[Z.heap_max] * 2 + 1] = 0, I = Z.heap_max + 1; I < A; I++)
      fe = Z.heap[I], H = xe[xe[fe * 2 + 1] * 2 + 1] + 1, H > it && (H = it, We++), xe[fe * 2 + 1] = H, !(fe > ke) && (Z.bl_count[H]++, ee = 0, fe >= ye && (ee = U[fe - ye]), oe = xe[fe * 2], Z.opt_len += oe * (H + ee), me && (Z.static_len += oe * (te[fe * 2 + 1] + ee)));
    if (We !== 0) {
      do {
        for (H = it - 1; Z.bl_count[H] === 0; )
          H--;
        Z.bl_count[H]--, Z.bl_count[H + 1] += 2, Z.bl_count[it]--, We -= 2;
      } while (We > 0);
      for (H = it; H !== 0; H--)
        for (fe = Z.bl_count[H]; fe !== 0; )
          de = Z.heap[--I], !(de > ke) && (xe[de * 2 + 1] !== H && (Z.opt_len += (H - xe[de * 2 + 1]) * xe[de * 2], xe[de * 2 + 1] = H), fe--);
    }
  }
  function et(Z, ue, xe) {
    var ke = new Array(T + 1), te = 0, me, U;
    for (me = 1; me <= T; me++)
      ke[me] = te = te + xe[me - 1] << 1;
    for (U = 0; U <= ue; U++) {
      var ye = Z[U * 2 + 1];
      ye !== 0 && (Z[U * 2] = Se(ke[ye]++, ye));
    }
  }
  function Ve() {
    var Z, ue, xe, ke, te, me = new Array(T + 1);
    for (xe = 0, ke = 0; ke < b - 1; ke++)
      for (pe[ke] = xe, Z = 0; Z < 1 << F[ke]; Z++)
        ne[xe++] = ke;
    for (ne[xe - 1] = ke, te = 0, ke = 0; ke < 16; ke++)
      for (be[ke] = te, Z = 0; Z < 1 << O[ke]; Z++)
        W[te++] = ke;
    for (te >>= 7; ke < E; ke++)
      for (be[ke] = te << 7, Z = 0; Z < 1 << O[ke] - 7; Z++)
        W[256 + te++] = ke;
    for (ue = 0; ue <= T; ue++)
      me[ue] = 0;
    for (Z = 0; Z <= 143; )
      J[Z * 2 + 1] = 8, Z++, me[8]++;
    for (; Z <= 255; )
      J[Z * 2 + 1] = 9, Z++, me[9]++;
    for (; Z <= 279; )
      J[Z * 2 + 1] = 7, Z++, me[7]++;
    for (; Z <= 287; )
      J[Z * 2 + 1] = 8, Z++, me[8]++;
    for (et(J, g + 1, me), Z = 0; Z < E; Z++)
      Q[Z * 2 + 1] = 5, Q[Z * 2] = Se(Z, 5);
    Ee = new ve(J, F, w + 1, g, T), Ae = new ve(Q, O, 0, E, T), _e = new ve(new Array(0), N, 0, k, D);
  }
  function tt(Z) {
    var ue;
    for (ue = 0; ue < g; ue++)
      Z.dyn_ltree[ue * 2] = 0;
    for (ue = 0; ue < E; ue++)
      Z.dyn_dtree[ue * 2] = 0;
    for (ue = 0; ue < k; ue++)
      Z.bl_tree[ue * 2] = 0;
    Z.dyn_ltree[$ * 2] = 1, Z.opt_len = Z.static_len = 0, Z.last_lit = Z.matches = 0;
  }
  function qe(Z) {
    Z.bi_valid > 8 ? re(Z, Z.bi_buf) : Z.bi_valid > 0 && (Z.pending_buf[Z.pending++] = Z.bi_buf), Z.bi_buf = 0, Z.bi_valid = 0;
  }
  function Re(Z, ue, xe, ke) {
    qe(Z), re(Z, xe), re(Z, ~xe), e.arraySet(Z.pending_buf, Z.window, ue, xe, Z.pending), Z.pending += xe;
  }
  function nt(Z, ue, xe, ke) {
    var te = ue * 2, me = xe * 2;
    return Z[te] < Z[me] || Z[te] === Z[me] && ke[ue] <= ke[xe];
  }
  function Ge(Z, ue, xe) {
    for (var ke = Z.heap[xe], te = xe << 1; te <= Z.heap_len && (te < Z.heap_len && nt(ue, Z.heap[te + 1], Z.heap[te], Z.depth) && te++, !nt(ue, ke, Z.heap[te], Z.depth)); )
      Z.heap[xe] = Z.heap[te], xe = te, te <<= 1;
    Z.heap[xe] = ke;
  }
  function Ne(Z, ue, xe) {
    var ke, te, me = 0, U, ye;
    if (Z.last_lit !== 0)
      do
        ke = Z.pending_buf[Z.d_buf + me * 2] << 8 | Z.pending_buf[Z.d_buf + me * 2 + 1], te = Z.pending_buf[Z.l_buf + me], me++, ke === 0 ? Fe(Z, te, ue) : (U = ne[te], Fe(Z, U + w + 1, ue), ye = F[U], ye !== 0 && (te -= pe[U], Te(Z, te, ye)), ke--, U = Me(ke), Fe(Z, U, xe), ye = O[U], ye !== 0 && (ke -= be[U], Te(Z, ke, ye)));
      while (me < Z.last_lit);
    Fe(Z, $, ue);
  }
  function he(Z, ue) {
    var xe = ue.dyn_tree, ke = ue.stat_desc.static_tree, te = ue.stat_desc.has_stree, me = ue.stat_desc.elems, U, ye, it = -1, I;
    for (Z.heap_len = 0, Z.heap_max = A, U = 0; U < me; U++)
      xe[U * 2] !== 0 ? (Z.heap[++Z.heap_len] = it = U, Z.depth[U] = 0) : xe[U * 2 + 1] = 0;
    for (; Z.heap_len < 2; )
      I = Z.heap[++Z.heap_len] = it < 2 ? ++it : 0, xe[I * 2] = 1, Z.depth[I] = 0, Z.opt_len--, te && (Z.static_len -= ke[I * 2 + 1]);
    for (ue.max_code = it, U = Z.heap_len >> 1; U >= 1; U--)
      Ge(Z, xe, U);
    I = me;
    do
      U = Z.heap[
        1
        /*SMALLEST*/
      ], Z.heap[
        1
        /*SMALLEST*/
      ] = Z.heap[Z.heap_len--], Ge(
        Z,
        xe,
        1
        /*SMALLEST*/
      ), ye = Z.heap[
        1
        /*SMALLEST*/
      ], Z.heap[--Z.heap_max] = U, Z.heap[--Z.heap_max] = ye, xe[I * 2] = xe[U * 2] + xe[ye * 2], Z.depth[I] = (Z.depth[U] >= Z.depth[ye] ? Z.depth[U] : Z.depth[ye]) + 1, xe[U * 2 + 1] = xe[ye * 2 + 1] = I, Z.heap[
        1
        /*SMALLEST*/
      ] = I++, Ge(
        Z,
        xe,
        1
        /*SMALLEST*/
      );
    while (Z.heap_len >= 2);
    Z.heap[--Z.heap_max] = Z.heap[
      1
      /*SMALLEST*/
    ], Je(Z, ue), et(xe, it, Z.bl_count);
  }
  function Qe(Z, ue, xe) {
    var ke, te = -1, me, U = ue[0 * 2 + 1], ye = 0, it = 7, I = 4;
    for (U === 0 && (it = 138, I = 3), ue[(xe + 1) * 2 + 1] = 65535, ke = 0; ke <= xe; ke++)
      me = U, U = ue[(ke + 1) * 2 + 1], !(++ye < it && me === U) && (ye < I ? Z.bl_tree[me * 2] += ye : me !== 0 ? (me !== te && Z.bl_tree[me * 2]++, Z.bl_tree[P * 2]++) : ye <= 10 ? Z.bl_tree[z * 2]++ : Z.bl_tree[B * 2]++, ye = 0, te = me, U === 0 ? (it = 138, I = 3) : me === U ? (it = 6, I = 3) : (it = 7, I = 4));
  }
  function Ze(Z, ue, xe) {
    var ke, te = -1, me, U = ue[0 * 2 + 1], ye = 0, it = 7, I = 4;
    for (U === 0 && (it = 138, I = 3), ke = 0; ke <= xe; ke++)
      if (me = U, U = ue[(ke + 1) * 2 + 1], !(++ye < it && me === U)) {
        if (ye < I)
          do
            Fe(Z, me, Z.bl_tree);
          while (--ye !== 0);
        else me !== 0 ? (me !== te && (Fe(Z, me, Z.bl_tree), ye--), Fe(Z, P, Z.bl_tree), Te(Z, ye - 3, 2)) : ye <= 10 ? (Fe(Z, z, Z.bl_tree), Te(Z, ye - 3, 3)) : (Fe(Z, B, Z.bl_tree), Te(Z, ye - 11, 7));
        ye = 0, te = me, U === 0 ? (it = 138, I = 3) : me === U ? (it = 6, I = 3) : (it = 7, I = 4);
      }
  }
  function He(Z) {
    var ue;
    for (Qe(Z, Z.dyn_ltree, Z.l_desc.max_code), Qe(Z, Z.dyn_dtree, Z.d_desc.max_code), he(Z, Z.bl_desc), ue = k - 1; ue >= 3 && Z.bl_tree[G[ue] * 2 + 1] === 0; ue--)
      ;
    return Z.opt_len += 3 * (ue + 1) + 5 + 5 + 4, ue;
  }
  function De(Z, ue, xe, ke) {
    var te;
    for (Te(Z, ue - 257, 5), Te(Z, xe - 1, 5), Te(Z, ke - 4, 4), te = 0; te < ke; te++)
      Te(Z, Z.bl_tree[G[te] * 2 + 1], 3);
    Ze(Z, Z.dyn_ltree, ue - 1), Ze(Z, Z.dyn_dtree, xe - 1);
  }
  function lt(Z) {
    var ue = 4093624447, xe;
    for (xe = 0; xe <= 31; xe++, ue >>>= 1)
      if (ue & 1 && Z.dyn_ltree[xe * 2] !== 0)
        return t;
    if (Z.dyn_ltree[9 * 2] !== 0 || Z.dyn_ltree[10 * 2] !== 0 || Z.dyn_ltree[13 * 2] !== 0)
      return r;
    for (xe = 32; xe < w; xe++)
      if (Z.dyn_ltree[xe * 2] !== 0)
        return r;
    return t;
  }
  var ot = !1;
  function Le(Z) {
    ot || (Ve(), ot = !0), Z.l_desc = new Be(Z.dyn_ltree, Ee), Z.d_desc = new Be(Z.dyn_dtree, Ae), Z.bl_desc = new Be(Z.bl_tree, _e), Z.bi_buf = 0, Z.bi_valid = 0, tt(Z);
  }
  function ze(Z, ue, xe, ke) {
    Te(Z, (s << 1) + (ke ? 1 : 0), 3), Re(Z, ue, xe);
  }
  function je(Z) {
    Te(Z, o << 1, 3), Fe(Z, $, J), Ye(Z);
  }
  function Oe(Z, ue, xe, ke) {
    var te, me, U = 0;
    Z.level > 0 ? (Z.strm.data_type === n && (Z.strm.data_type = lt(Z)), he(Z, Z.l_desc), he(Z, Z.d_desc), U = He(Z), te = Z.opt_len + 3 + 7 >>> 3, me = Z.static_len + 3 + 7 >>> 3, me <= te && (te = me)) : te = me = xe + 5, xe + 4 <= te && ue !== -1 ? ze(Z, ue, xe, ke) : Z.strategy === i || me === te ? (Te(Z, (o << 1) + (ke ? 1 : 0), 3), Ne(Z, J, Q)) : (Te(Z, (h << 1) + (ke ? 1 : 0), 3), De(Z, Z.l_desc.max_code + 1, Z.d_desc.max_code + 1, U + 1), Ne(Z, Z.dyn_ltree, Z.dyn_dtree)), tt(Z), ke && qe(Z);
  }
  function st(Z, ue, xe) {
    return Z.pending_buf[Z.d_buf + Z.last_lit * 2] = ue >>> 8 & 255, Z.pending_buf[Z.d_buf + Z.last_lit * 2 + 1] = ue & 255, Z.pending_buf[Z.l_buf + Z.last_lit] = xe & 255, Z.last_lit++, ue === 0 ? Z.dyn_ltree[xe * 2]++ : (Z.matches++, ue--, Z.dyn_ltree[(ne[xe] + w + 1) * 2]++, Z.dyn_dtree[Me(ue) * 2]++), Z.last_lit === Z.lit_bufsize - 1;
  }
  return trees._tr_init = Le, trees._tr_stored_block = ze, trees._tr_flush_block = Oe, trees._tr_tally = st, trees._tr_align = je, trees;
}
var adler32_1, hasRequiredAdler32;
function requireAdler32() {
  if (hasRequiredAdler32) return adler32_1;
  hasRequiredAdler32 = 1;
  function e(i, t, r, n) {
    for (var a = i & 65535 | 0, s = i >>> 16 & 65535 | 0, o = 0; r !== 0; ) {
      o = r > 2e3 ? 2e3 : r, r -= o;
      do
        a = a + t[n++] | 0, s = s + a | 0;
      while (--o);
      a %= 65521, s %= 65521;
    }
    return a | s << 16 | 0;
  }
  return adler32_1 = e, adler32_1;
}
var crc32_1, hasRequiredCrc32;
function requireCrc32() {
  if (hasRequiredCrc32) return crc32_1;
  hasRequiredCrc32 = 1;
  function e() {
    for (var r, n = [], a = 0; a < 256; a++) {
      r = a;
      for (var s = 0; s < 8; s++)
        r = r & 1 ? 3988292384 ^ r >>> 1 : r >>> 1;
      n[a] = r;
    }
    return n;
  }
  var i = e();
  function t(r, n, a, s) {
    var o = i, h = s + a;
    r ^= -1;
    for (var l = s; l < h; l++)
      r = r >>> 8 ^ o[(r ^ n[l]) & 255];
    return r ^ -1;
  }
  return crc32_1 = t, crc32_1;
}
var messages, hasRequiredMessages;
function requireMessages() {
  return hasRequiredMessages || (hasRequiredMessages = 1, messages = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  }), messages;
}
var hasRequiredDeflate$1;
function requireDeflate$1() {
  if (hasRequiredDeflate$1) return deflate;
  hasRequiredDeflate$1 = 1;
  var e = requireCommon(), i = requireTrees(), t = requireAdler32(), r = requireCrc32(), n = requireMessages(), a = 0, s = 1, o = 3, h = 4, l = 5, f = 0, b = 1, w = -2, g = -3, E = -5, k = -1, A = 1, T = 2, C = 3, D = 4, $ = 0, P = 2, z = 8, B = 9, F = 15, O = 8, N = 29, G = 256, V = G + 1 + N, J = 30, Q = 19, W = 2 * V + 1, ne = 15, pe = 3, be = 258, ve = be + pe + 1, Ee = 32, Ae = 42, _e = 69, Be = 73, Me = 91, re = 103, Te = 113, Fe = 666, Se = 1, Ye = 2, Je = 3, et = 4, Ve = 3;
  function tt(I, fe) {
    return I.msg = n[fe], fe;
  }
  function qe(I) {
    return (I << 1) - (I > 4 ? 9 : 0);
  }
  function Re(I) {
    for (var fe = I.length; --fe >= 0; )
      I[fe] = 0;
  }
  function nt(I) {
    var fe = I.state, de = fe.pending;
    de > I.avail_out && (de = I.avail_out), de !== 0 && (e.arraySet(I.output, fe.pending_buf, fe.pending_out, de, I.next_out), I.next_out += de, fe.pending_out += de, I.total_out += de, I.avail_out -= de, fe.pending -= de, fe.pending === 0 && (fe.pending_out = 0));
  }
  function Ge(I, fe) {
    i._tr_flush_block(I, I.block_start >= 0 ? I.block_start : -1, I.strstart - I.block_start, fe), I.block_start = I.strstart, nt(I.strm);
  }
  function Ne(I, fe) {
    I.pending_buf[I.pending++] = fe;
  }
  function he(I, fe) {
    I.pending_buf[I.pending++] = fe >>> 8 & 255, I.pending_buf[I.pending++] = fe & 255;
  }
  function Qe(I, fe, de, H) {
    var ee = I.avail_in;
    return ee > H && (ee = H), ee === 0 ? 0 : (I.avail_in -= ee, e.arraySet(fe, I.input, I.next_in, ee, de), I.state.wrap === 1 ? I.adler = t(I.adler, fe, ee, de) : I.state.wrap === 2 && (I.adler = r(I.adler, fe, ee, de)), I.next_in += ee, I.total_in += ee, ee);
  }
  function Ze(I, fe) {
    var de = I.max_chain_length, H = I.strstart, ee, oe, We = I.prev_length, M = I.nice_match, _ = I.strstart > I.w_size - ve ? I.strstart - (I.w_size - ve) : 0, d = I.window, u = I.w_mask, v = I.prev, S = I.strstart + be, L = d[H + We - 1], q = d[H + We];
    I.prev_length >= I.good_match && (de >>= 2), M > I.lookahead && (M = I.lookahead);
    do
      if (ee = fe, !(d[ee + We] !== q || d[ee + We - 1] !== L || d[ee] !== d[H] || d[++ee] !== d[H + 1])) {
        H += 2, ee++;
        do
          ;
        while (d[++H] === d[++ee] && d[++H] === d[++ee] && d[++H] === d[++ee] && d[++H] === d[++ee] && d[++H] === d[++ee] && d[++H] === d[++ee] && d[++H] === d[++ee] && d[++H] === d[++ee] && H < S);
        if (oe = be - (S - H), H = S - be, oe > We) {
          if (I.match_start = fe, We = oe, oe >= M)
            break;
          L = d[H + We - 1], q = d[H + We];
        }
      }
    while ((fe = v[fe & u]) > _ && --de !== 0);
    return We <= I.lookahead ? We : I.lookahead;
  }
  function He(I) {
    var fe = I.w_size, de, H, ee, oe, We;
    do {
      if (oe = I.window_size - I.lookahead - I.strstart, I.strstart >= fe + (fe - ve)) {
        e.arraySet(I.window, I.window, fe, fe, 0), I.match_start -= fe, I.strstart -= fe, I.block_start -= fe, H = I.hash_size, de = H;
        do
          ee = I.head[--de], I.head[de] = ee >= fe ? ee - fe : 0;
        while (--H);
        H = fe, de = H;
        do
          ee = I.prev[--de], I.prev[de] = ee >= fe ? ee - fe : 0;
        while (--H);
        oe += fe;
      }
      if (I.strm.avail_in === 0)
        break;
      if (H = Qe(I.strm, I.window, I.strstart + I.lookahead, oe), I.lookahead += H, I.lookahead + I.insert >= pe)
        for (We = I.strstart - I.insert, I.ins_h = I.window[We], I.ins_h = (I.ins_h << I.hash_shift ^ I.window[We + 1]) & I.hash_mask; I.insert && (I.ins_h = (I.ins_h << I.hash_shift ^ I.window[We + pe - 1]) & I.hash_mask, I.prev[We & I.w_mask] = I.head[I.ins_h], I.head[I.ins_h] = We, We++, I.insert--, !(I.lookahead + I.insert < pe)); )
          ;
    } while (I.lookahead < ve && I.strm.avail_in !== 0);
  }
  function De(I, fe) {
    var de = 65535;
    for (de > I.pending_buf_size - 5 && (de = I.pending_buf_size - 5); ; ) {
      if (I.lookahead <= 1) {
        if (He(I), I.lookahead === 0 && fe === a)
          return Se;
        if (I.lookahead === 0)
          break;
      }
      I.strstart += I.lookahead, I.lookahead = 0;
      var H = I.block_start + de;
      if ((I.strstart === 0 || I.strstart >= H) && (I.lookahead = I.strstart - H, I.strstart = H, Ge(I, !1), I.strm.avail_out === 0) || I.strstart - I.block_start >= I.w_size - ve && (Ge(I, !1), I.strm.avail_out === 0))
        return Se;
    }
    return I.insert = 0, fe === h ? (Ge(I, !0), I.strm.avail_out === 0 ? Je : et) : (I.strstart > I.block_start && (Ge(I, !1), I.strm.avail_out === 0), Se);
  }
  function lt(I, fe) {
    for (var de, H; ; ) {
      if (I.lookahead < ve) {
        if (He(I), I.lookahead < ve && fe === a)
          return Se;
        if (I.lookahead === 0)
          break;
      }
      if (de = 0, I.lookahead >= pe && (I.ins_h = (I.ins_h << I.hash_shift ^ I.window[I.strstart + pe - 1]) & I.hash_mask, de = I.prev[I.strstart & I.w_mask] = I.head[I.ins_h], I.head[I.ins_h] = I.strstart), de !== 0 && I.strstart - de <= I.w_size - ve && (I.match_length = Ze(I, de)), I.match_length >= pe)
        if (H = i._tr_tally(I, I.strstart - I.match_start, I.match_length - pe), I.lookahead -= I.match_length, I.match_length <= I.max_lazy_match && I.lookahead >= pe) {
          I.match_length--;
          do
            I.strstart++, I.ins_h = (I.ins_h << I.hash_shift ^ I.window[I.strstart + pe - 1]) & I.hash_mask, de = I.prev[I.strstart & I.w_mask] = I.head[I.ins_h], I.head[I.ins_h] = I.strstart;
          while (--I.match_length !== 0);
          I.strstart++;
        } else
          I.strstart += I.match_length, I.match_length = 0, I.ins_h = I.window[I.strstart], I.ins_h = (I.ins_h << I.hash_shift ^ I.window[I.strstart + 1]) & I.hash_mask;
      else
        H = i._tr_tally(I, 0, I.window[I.strstart]), I.lookahead--, I.strstart++;
      if (H && (Ge(I, !1), I.strm.avail_out === 0))
        return Se;
    }
    return I.insert = I.strstart < pe - 1 ? I.strstart : pe - 1, fe === h ? (Ge(I, !0), I.strm.avail_out === 0 ? Je : et) : I.last_lit && (Ge(I, !1), I.strm.avail_out === 0) ? Se : Ye;
  }
  function ot(I, fe) {
    for (var de, H, ee; ; ) {
      if (I.lookahead < ve) {
        if (He(I), I.lookahead < ve && fe === a)
          return Se;
        if (I.lookahead === 0)
          break;
      }
      if (de = 0, I.lookahead >= pe && (I.ins_h = (I.ins_h << I.hash_shift ^ I.window[I.strstart + pe - 1]) & I.hash_mask, de = I.prev[I.strstart & I.w_mask] = I.head[I.ins_h], I.head[I.ins_h] = I.strstart), I.prev_length = I.match_length, I.prev_match = I.match_start, I.match_length = pe - 1, de !== 0 && I.prev_length < I.max_lazy_match && I.strstart - de <= I.w_size - ve && (I.match_length = Ze(I, de), I.match_length <= 5 && (I.strategy === A || I.match_length === pe && I.strstart - I.match_start > 4096) && (I.match_length = pe - 1)), I.prev_length >= pe && I.match_length <= I.prev_length) {
        ee = I.strstart + I.lookahead - pe, H = i._tr_tally(I, I.strstart - 1 - I.prev_match, I.prev_length - pe), I.lookahead -= I.prev_length - 1, I.prev_length -= 2;
        do
          ++I.strstart <= ee && (I.ins_h = (I.ins_h << I.hash_shift ^ I.window[I.strstart + pe - 1]) & I.hash_mask, de = I.prev[I.strstart & I.w_mask] = I.head[I.ins_h], I.head[I.ins_h] = I.strstart);
        while (--I.prev_length !== 0);
        if (I.match_available = 0, I.match_length = pe - 1, I.strstart++, H && (Ge(I, !1), I.strm.avail_out === 0))
          return Se;
      } else if (I.match_available) {
        if (H = i._tr_tally(I, 0, I.window[I.strstart - 1]), H && Ge(I, !1), I.strstart++, I.lookahead--, I.strm.avail_out === 0)
          return Se;
      } else
        I.match_available = 1, I.strstart++, I.lookahead--;
    }
    return I.match_available && (H = i._tr_tally(I, 0, I.window[I.strstart - 1]), I.match_available = 0), I.insert = I.strstart < pe - 1 ? I.strstart : pe - 1, fe === h ? (Ge(I, !0), I.strm.avail_out === 0 ? Je : et) : I.last_lit && (Ge(I, !1), I.strm.avail_out === 0) ? Se : Ye;
  }
  function Le(I, fe) {
    for (var de, H, ee, oe, We = I.window; ; ) {
      if (I.lookahead <= be) {
        if (He(I), I.lookahead <= be && fe === a)
          return Se;
        if (I.lookahead === 0)
          break;
      }
      if (I.match_length = 0, I.lookahead >= pe && I.strstart > 0 && (ee = I.strstart - 1, H = We[ee], H === We[++ee] && H === We[++ee] && H === We[++ee])) {
        oe = I.strstart + be;
        do
          ;
        while (H === We[++ee] && H === We[++ee] && H === We[++ee] && H === We[++ee] && H === We[++ee] && H === We[++ee] && H === We[++ee] && H === We[++ee] && ee < oe);
        I.match_length = be - (oe - ee), I.match_length > I.lookahead && (I.match_length = I.lookahead);
      }
      if (I.match_length >= pe ? (de = i._tr_tally(I, 1, I.match_length - pe), I.lookahead -= I.match_length, I.strstart += I.match_length, I.match_length = 0) : (de = i._tr_tally(I, 0, I.window[I.strstart]), I.lookahead--, I.strstart++), de && (Ge(I, !1), I.strm.avail_out === 0))
        return Se;
    }
    return I.insert = 0, fe === h ? (Ge(I, !0), I.strm.avail_out === 0 ? Je : et) : I.last_lit && (Ge(I, !1), I.strm.avail_out === 0) ? Se : Ye;
  }
  function ze(I, fe) {
    for (var de; ; ) {
      if (I.lookahead === 0 && (He(I), I.lookahead === 0)) {
        if (fe === a)
          return Se;
        break;
      }
      if (I.match_length = 0, de = i._tr_tally(I, 0, I.window[I.strstart]), I.lookahead--, I.strstart++, de && (Ge(I, !1), I.strm.avail_out === 0))
        return Se;
    }
    return I.insert = 0, fe === h ? (Ge(I, !0), I.strm.avail_out === 0 ? Je : et) : I.last_lit && (Ge(I, !1), I.strm.avail_out === 0) ? Se : Ye;
  }
  function je(I, fe, de, H, ee) {
    this.good_length = I, this.max_lazy = fe, this.nice_length = de, this.max_chain = H, this.func = ee;
  }
  var Oe;
  Oe = [
    /*      good lazy nice chain */
    new je(0, 0, 0, 0, De),
    /* 0 store only */
    new je(4, 4, 8, 4, lt),
    /* 1 max speed, no lazy matches */
    new je(4, 5, 16, 8, lt),
    /* 2 */
    new je(4, 6, 32, 32, lt),
    /* 3 */
    new je(4, 4, 16, 16, ot),
    /* 4 lazy matches */
    new je(8, 16, 32, 32, ot),
    /* 5 */
    new je(8, 16, 128, 128, ot),
    /* 6 */
    new je(8, 32, 128, 256, ot),
    /* 7 */
    new je(32, 128, 258, 1024, ot),
    /* 8 */
    new je(32, 258, 258, 4096, ot)
    /* 9 max compression */
  ];
  function st(I) {
    I.window_size = 2 * I.w_size, Re(I.head), I.max_lazy_match = Oe[I.level].max_lazy, I.good_match = Oe[I.level].good_length, I.nice_match = Oe[I.level].nice_length, I.max_chain_length = Oe[I.level].max_chain, I.strstart = 0, I.block_start = 0, I.lookahead = 0, I.insert = 0, I.match_length = I.prev_length = pe - 1, I.match_available = 0, I.ins_h = 0;
  }
  function Z() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = z, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new e.Buf16(W * 2), this.dyn_dtree = new e.Buf16((2 * J + 1) * 2), this.bl_tree = new e.Buf16((2 * Q + 1) * 2), Re(this.dyn_ltree), Re(this.dyn_dtree), Re(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new e.Buf16(ne + 1), this.heap = new e.Buf16(2 * V + 1), Re(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new e.Buf16(2 * V + 1), Re(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
  }
  function ue(I) {
    var fe;
    return !I || !I.state ? tt(I, w) : (I.total_in = I.total_out = 0, I.data_type = P, fe = I.state, fe.pending = 0, fe.pending_out = 0, fe.wrap < 0 && (fe.wrap = -fe.wrap), fe.status = fe.wrap ? Ae : Te, I.adler = fe.wrap === 2 ? 0 : 1, fe.last_flush = a, i._tr_init(fe), f);
  }
  function xe(I) {
    var fe = ue(I);
    return fe === f && st(I.state), fe;
  }
  function ke(I, fe) {
    return !I || !I.state || I.state.wrap !== 2 ? w : (I.state.gzhead = fe, f);
  }
  function te(I, fe, de, H, ee, oe) {
    if (!I)
      return w;
    var We = 1;
    if (fe === k && (fe = 6), H < 0 ? (We = 0, H = -H) : H > 15 && (We = 2, H -= 16), ee < 1 || ee > B || de !== z || H < 8 || H > 15 || fe < 0 || fe > 9 || oe < 0 || oe > D)
      return tt(I, w);
    H === 8 && (H = 9);
    var M = new Z();
    return I.state = M, M.strm = I, M.wrap = We, M.gzhead = null, M.w_bits = H, M.w_size = 1 << M.w_bits, M.w_mask = M.w_size - 1, M.hash_bits = ee + 7, M.hash_size = 1 << M.hash_bits, M.hash_mask = M.hash_size - 1, M.hash_shift = ~~((M.hash_bits + pe - 1) / pe), M.window = new e.Buf8(M.w_size * 2), M.head = new e.Buf16(M.hash_size), M.prev = new e.Buf16(M.w_size), M.lit_bufsize = 1 << ee + 6, M.pending_buf_size = M.lit_bufsize * 4, M.pending_buf = new e.Buf8(M.pending_buf_size), M.d_buf = 1 * M.lit_bufsize, M.l_buf = 3 * M.lit_bufsize, M.level = fe, M.strategy = oe, M.method = de, xe(I);
  }
  function me(I, fe) {
    return te(I, fe, z, F, O, $);
  }
  function U(I, fe) {
    var de, H, ee, oe;
    if (!I || !I.state || fe > l || fe < 0)
      return I ? tt(I, w) : w;
    if (H = I.state, !I.output || !I.input && I.avail_in !== 0 || H.status === Fe && fe !== h)
      return tt(I, I.avail_out === 0 ? E : w);
    if (H.strm = I, de = H.last_flush, H.last_flush = fe, H.status === Ae)
      if (H.wrap === 2)
        I.adler = 0, Ne(H, 31), Ne(H, 139), Ne(H, 8), H.gzhead ? (Ne(
          H,
          (H.gzhead.text ? 1 : 0) + (H.gzhead.hcrc ? 2 : 0) + (H.gzhead.extra ? 4 : 0) + (H.gzhead.name ? 8 : 0) + (H.gzhead.comment ? 16 : 0)
        ), Ne(H, H.gzhead.time & 255), Ne(H, H.gzhead.time >> 8 & 255), Ne(H, H.gzhead.time >> 16 & 255), Ne(H, H.gzhead.time >> 24 & 255), Ne(H, H.level === 9 ? 2 : H.strategy >= T || H.level < 2 ? 4 : 0), Ne(H, H.gzhead.os & 255), H.gzhead.extra && H.gzhead.extra.length && (Ne(H, H.gzhead.extra.length & 255), Ne(H, H.gzhead.extra.length >> 8 & 255)), H.gzhead.hcrc && (I.adler = r(I.adler, H.pending_buf, H.pending, 0)), H.gzindex = 0, H.status = _e) : (Ne(H, 0), Ne(H, 0), Ne(H, 0), Ne(H, 0), Ne(H, 0), Ne(H, H.level === 9 ? 2 : H.strategy >= T || H.level < 2 ? 4 : 0), Ne(H, Ve), H.status = Te);
      else {
        var We = z + (H.w_bits - 8 << 4) << 8, M = -1;
        H.strategy >= T || H.level < 2 ? M = 0 : H.level < 6 ? M = 1 : H.level === 6 ? M = 2 : M = 3, We |= M << 6, H.strstart !== 0 && (We |= Ee), We += 31 - We % 31, H.status = Te, he(H, We), H.strstart !== 0 && (he(H, I.adler >>> 16), he(H, I.adler & 65535)), I.adler = 1;
      }
    if (H.status === _e)
      if (H.gzhead.extra) {
        for (ee = H.pending; H.gzindex < (H.gzhead.extra.length & 65535) && !(H.pending === H.pending_buf_size && (H.gzhead.hcrc && H.pending > ee && (I.adler = r(I.adler, H.pending_buf, H.pending - ee, ee)), nt(I), ee = H.pending, H.pending === H.pending_buf_size)); )
          Ne(H, H.gzhead.extra[H.gzindex] & 255), H.gzindex++;
        H.gzhead.hcrc && H.pending > ee && (I.adler = r(I.adler, H.pending_buf, H.pending - ee, ee)), H.gzindex === H.gzhead.extra.length && (H.gzindex = 0, H.status = Be);
      } else
        H.status = Be;
    if (H.status === Be)
      if (H.gzhead.name) {
        ee = H.pending;
        do {
          if (H.pending === H.pending_buf_size && (H.gzhead.hcrc && H.pending > ee && (I.adler = r(I.adler, H.pending_buf, H.pending - ee, ee)), nt(I), ee = H.pending, H.pending === H.pending_buf_size)) {
            oe = 1;
            break;
          }
          H.gzindex < H.gzhead.name.length ? oe = H.gzhead.name.charCodeAt(H.gzindex++) & 255 : oe = 0, Ne(H, oe);
        } while (oe !== 0);
        H.gzhead.hcrc && H.pending > ee && (I.adler = r(I.adler, H.pending_buf, H.pending - ee, ee)), oe === 0 && (H.gzindex = 0, H.status = Me);
      } else
        H.status = Me;
    if (H.status === Me)
      if (H.gzhead.comment) {
        ee = H.pending;
        do {
          if (H.pending === H.pending_buf_size && (H.gzhead.hcrc && H.pending > ee && (I.adler = r(I.adler, H.pending_buf, H.pending - ee, ee)), nt(I), ee = H.pending, H.pending === H.pending_buf_size)) {
            oe = 1;
            break;
          }
          H.gzindex < H.gzhead.comment.length ? oe = H.gzhead.comment.charCodeAt(H.gzindex++) & 255 : oe = 0, Ne(H, oe);
        } while (oe !== 0);
        H.gzhead.hcrc && H.pending > ee && (I.adler = r(I.adler, H.pending_buf, H.pending - ee, ee)), oe === 0 && (H.status = re);
      } else
        H.status = re;
    if (H.status === re && (H.gzhead.hcrc ? (H.pending + 2 > H.pending_buf_size && nt(I), H.pending + 2 <= H.pending_buf_size && (Ne(H, I.adler & 255), Ne(H, I.adler >> 8 & 255), I.adler = 0, H.status = Te)) : H.status = Te), H.pending !== 0) {
      if (nt(I), I.avail_out === 0)
        return H.last_flush = -1, f;
    } else if (I.avail_in === 0 && qe(fe) <= qe(de) && fe !== h)
      return tt(I, E);
    if (H.status === Fe && I.avail_in !== 0)
      return tt(I, E);
    if (I.avail_in !== 0 || H.lookahead !== 0 || fe !== a && H.status !== Fe) {
      var _ = H.strategy === T ? ze(H, fe) : H.strategy === C ? Le(H, fe) : Oe[H.level].func(H, fe);
      if ((_ === Je || _ === et) && (H.status = Fe), _ === Se || _ === Je)
        return I.avail_out === 0 && (H.last_flush = -1), f;
      if (_ === Ye && (fe === s ? i._tr_align(H) : fe !== l && (i._tr_stored_block(H, 0, 0, !1), fe === o && (Re(H.head), H.lookahead === 0 && (H.strstart = 0, H.block_start = 0, H.insert = 0))), nt(I), I.avail_out === 0))
        return H.last_flush = -1, f;
    }
    return fe !== h ? f : H.wrap <= 0 ? b : (H.wrap === 2 ? (Ne(H, I.adler & 255), Ne(H, I.adler >> 8 & 255), Ne(H, I.adler >> 16 & 255), Ne(H, I.adler >> 24 & 255), Ne(H, I.total_in & 255), Ne(H, I.total_in >> 8 & 255), Ne(H, I.total_in >> 16 & 255), Ne(H, I.total_in >> 24 & 255)) : (he(H, I.adler >>> 16), he(H, I.adler & 65535)), nt(I), H.wrap > 0 && (H.wrap = -H.wrap), H.pending !== 0 ? f : b);
  }
  function ye(I) {
    var fe;
    return !I || !I.state ? w : (fe = I.state.status, fe !== Ae && fe !== _e && fe !== Be && fe !== Me && fe !== re && fe !== Te && fe !== Fe ? tt(I, w) : (I.state = null, fe === Te ? tt(I, g) : f));
  }
  function it(I, fe) {
    var de = fe.length, H, ee, oe, We, M, _, d, u;
    if (!I || !I.state || (H = I.state, We = H.wrap, We === 2 || We === 1 && H.status !== Ae || H.lookahead))
      return w;
    for (We === 1 && (I.adler = t(I.adler, fe, de, 0)), H.wrap = 0, de >= H.w_size && (We === 0 && (Re(H.head), H.strstart = 0, H.block_start = 0, H.insert = 0), u = new e.Buf8(H.w_size), e.arraySet(u, fe, de - H.w_size, H.w_size, 0), fe = u, de = H.w_size), M = I.avail_in, _ = I.next_in, d = I.input, I.avail_in = de, I.next_in = 0, I.input = fe, He(H); H.lookahead >= pe; ) {
      ee = H.strstart, oe = H.lookahead - (pe - 1);
      do
        H.ins_h = (H.ins_h << H.hash_shift ^ H.window[ee + pe - 1]) & H.hash_mask, H.prev[ee & H.w_mask] = H.head[H.ins_h], H.head[H.ins_h] = ee, ee++;
      while (--oe);
      H.strstart = ee, H.lookahead = pe - 1, He(H);
    }
    return H.strstart += H.lookahead, H.block_start = H.strstart, H.insert = H.lookahead, H.lookahead = 0, H.match_length = H.prev_length = pe - 1, H.match_available = 0, I.next_in = _, I.input = d, I.avail_in = M, H.wrap = We, f;
  }
  return deflate.deflateInit = me, deflate.deflateInit2 = te, deflate.deflateReset = xe, deflate.deflateResetKeep = ue, deflate.deflateSetHeader = ke, deflate.deflate = U, deflate.deflateEnd = ye, deflate.deflateSetDictionary = it, deflate.deflateInfo = "pako deflate (from Nodeca project)", deflate;
}
var strings = {}, hasRequiredStrings;
function requireStrings() {
  if (hasRequiredStrings) return strings;
  hasRequiredStrings = 1;
  var e = requireCommon(), i = !0, t = !0;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch {
    i = !1;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch {
    t = !1;
  }
  for (var r = new e.Buf8(256), n = 0; n < 256; n++)
    r[n] = n >= 252 ? 6 : n >= 248 ? 5 : n >= 240 ? 4 : n >= 224 ? 3 : n >= 192 ? 2 : 1;
  r[254] = r[254] = 1, strings.string2buf = function(s) {
    var o, h, l, f, b, w = s.length, g = 0;
    for (f = 0; f < w; f++)
      h = s.charCodeAt(f), (h & 64512) === 55296 && f + 1 < w && (l = s.charCodeAt(f + 1), (l & 64512) === 56320 && (h = 65536 + (h - 55296 << 10) + (l - 56320), f++)), g += h < 128 ? 1 : h < 2048 ? 2 : h < 65536 ? 3 : 4;
    for (o = new e.Buf8(g), b = 0, f = 0; b < g; f++)
      h = s.charCodeAt(f), (h & 64512) === 55296 && f + 1 < w && (l = s.charCodeAt(f + 1), (l & 64512) === 56320 && (h = 65536 + (h - 55296 << 10) + (l - 56320), f++)), h < 128 ? o[b++] = h : h < 2048 ? (o[b++] = 192 | h >>> 6, o[b++] = 128 | h & 63) : h < 65536 ? (o[b++] = 224 | h >>> 12, o[b++] = 128 | h >>> 6 & 63, o[b++] = 128 | h & 63) : (o[b++] = 240 | h >>> 18, o[b++] = 128 | h >>> 12 & 63, o[b++] = 128 | h >>> 6 & 63, o[b++] = 128 | h & 63);
    return o;
  };
  function a(s, o) {
    if (o < 65534 && (s.subarray && t || !s.subarray && i))
      return String.fromCharCode.apply(null, e.shrinkBuf(s, o));
    for (var h = "", l = 0; l < o; l++)
      h += String.fromCharCode(s[l]);
    return h;
  }
  return strings.buf2binstring = function(s) {
    return a(s, s.length);
  }, strings.binstring2buf = function(s) {
    for (var o = new e.Buf8(s.length), h = 0, l = o.length; h < l; h++)
      o[h] = s.charCodeAt(h);
    return o;
  }, strings.buf2string = function(s, o) {
    var h, l, f, b, w = o || s.length, g = new Array(w * 2);
    for (l = 0, h = 0; h < w; ) {
      if (f = s[h++], f < 128) {
        g[l++] = f;
        continue;
      }
      if (b = r[f], b > 4) {
        g[l++] = 65533, h += b - 1;
        continue;
      }
      for (f &= b === 2 ? 31 : b === 3 ? 15 : 7; b > 1 && h < w; )
        f = f << 6 | s[h++] & 63, b--;
      if (b > 1) {
        g[l++] = 65533;
        continue;
      }
      f < 65536 ? g[l++] = f : (f -= 65536, g[l++] = 55296 | f >> 10 & 1023, g[l++] = 56320 | f & 1023);
    }
    return a(g, l);
  }, strings.utf8border = function(s, o) {
    var h;
    for (o = o || s.length, o > s.length && (o = s.length), h = o - 1; h >= 0 && (s[h] & 192) === 128; )
      h--;
    return h < 0 || h === 0 ? o : h + r[s[h]] > o ? h : o;
  }, strings;
}
var zstream, hasRequiredZstream;
function requireZstream() {
  if (hasRequiredZstream) return zstream;
  hasRequiredZstream = 1;
  function e() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
  }
  return zstream = e, zstream;
}
var hasRequiredDeflate;
function requireDeflate() {
  if (hasRequiredDeflate) return deflate$1;
  hasRequiredDeflate = 1;
  var e = requireDeflate$1(), i = requireCommon(), t = requireStrings(), r = requireMessages(), n = requireZstream(), a = Object.prototype.toString, s = 0, o = 4, h = 0, l = 1, f = 2, b = -1, w = 0, g = 8;
  function E(C) {
    if (!(this instanceof E)) return new E(C);
    this.options = i.assign({
      level: b,
      method: g,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: w,
      to: ""
    }, C || {});
    var D = this.options;
    D.raw && D.windowBits > 0 ? D.windowBits = -D.windowBits : D.gzip && D.windowBits > 0 && D.windowBits < 16 && (D.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new n(), this.strm.avail_out = 0;
    var $ = e.deflateInit2(
      this.strm,
      D.level,
      D.method,
      D.windowBits,
      D.memLevel,
      D.strategy
    );
    if ($ !== h)
      throw new Error(r[$]);
    if (D.header && e.deflateSetHeader(this.strm, D.header), D.dictionary) {
      var P;
      if (typeof D.dictionary == "string" ? P = t.string2buf(D.dictionary) : a.call(D.dictionary) === "[object ArrayBuffer]" ? P = new Uint8Array(D.dictionary) : P = D.dictionary, $ = e.deflateSetDictionary(this.strm, P), $ !== h)
        throw new Error(r[$]);
      this._dict_set = !0;
    }
  }
  E.prototype.push = function(C, D) {
    var $ = this.strm, P = this.options.chunkSize, z, B;
    if (this.ended)
      return !1;
    B = D === ~~D ? D : D === !0 ? o : s, typeof C == "string" ? $.input = t.string2buf(C) : a.call(C) === "[object ArrayBuffer]" ? $.input = new Uint8Array(C) : $.input = C, $.next_in = 0, $.avail_in = $.input.length;
    do {
      if ($.avail_out === 0 && ($.output = new i.Buf8(P), $.next_out = 0, $.avail_out = P), z = e.deflate($, B), z !== l && z !== h)
        return this.onEnd(z), this.ended = !0, !1;
      ($.avail_out === 0 || $.avail_in === 0 && (B === o || B === f)) && (this.options.to === "string" ? this.onData(t.buf2binstring(i.shrinkBuf($.output, $.next_out))) : this.onData(i.shrinkBuf($.output, $.next_out)));
    } while (($.avail_in > 0 || $.avail_out === 0) && z !== l);
    return B === o ? (z = e.deflateEnd(this.strm), this.onEnd(z), this.ended = !0, z === h) : (B === f && (this.onEnd(h), $.avail_out = 0), !0);
  }, E.prototype.onData = function(C) {
    this.chunks.push(C);
  }, E.prototype.onEnd = function(C) {
    C === h && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = C, this.msg = this.strm.msg;
  };
  function k(C, D) {
    var $ = new E(D);
    if ($.push(C, !0), $.err)
      throw $.msg || r[$.err];
    return $.result;
  }
  function A(C, D) {
    return D = D || {}, D.raw = !0, k(C, D);
  }
  function T(C, D) {
    return D = D || {}, D.gzip = !0, k(C, D);
  }
  return deflate$1.Deflate = E, deflate$1.deflate = k, deflate$1.deflateRaw = A, deflate$1.gzip = T, deflate$1;
}
var inflate$1 = {}, inflate = {}, inffast, hasRequiredInffast;
function requireInffast() {
  if (hasRequiredInffast) return inffast;
  hasRequiredInffast = 1;
  var e = 30, i = 12;
  return inffast = function(r, n) {
    var a, s, o, h, l, f, b, w, g, E, k, A, T, C, D, $, P, z, B, F, O, N, G, V, J;
    a = r.state, s = r.next_in, V = r.input, o = s + (r.avail_in - 5), h = r.next_out, J = r.output, l = h - (n - r.avail_out), f = h + (r.avail_out - 257), b = a.dmax, w = a.wsize, g = a.whave, E = a.wnext, k = a.window, A = a.hold, T = a.bits, C = a.lencode, D = a.distcode, $ = (1 << a.lenbits) - 1, P = (1 << a.distbits) - 1;
    e:
      do {
        T < 15 && (A += V[s++] << T, T += 8, A += V[s++] << T, T += 8), z = C[A & $];
        t:
          for (; ; ) {
            if (B = z >>> 24, A >>>= B, T -= B, B = z >>> 16 & 255, B === 0)
              J[h++] = z & 65535;
            else if (B & 16) {
              F = z & 65535, B &= 15, B && (T < B && (A += V[s++] << T, T += 8), F += A & (1 << B) - 1, A >>>= B, T -= B), T < 15 && (A += V[s++] << T, T += 8, A += V[s++] << T, T += 8), z = D[A & P];
              i:
                for (; ; ) {
                  if (B = z >>> 24, A >>>= B, T -= B, B = z >>> 16 & 255, B & 16) {
                    if (O = z & 65535, B &= 15, T < B && (A += V[s++] << T, T += 8, T < B && (A += V[s++] << T, T += 8)), O += A & (1 << B) - 1, O > b) {
                      r.msg = "invalid distance too far back", a.mode = e;
                      break e;
                    }
                    if (A >>>= B, T -= B, B = h - l, O > B) {
                      if (B = O - B, B > g && a.sane) {
                        r.msg = "invalid distance too far back", a.mode = e;
                        break e;
                      }
                      if (N = 0, G = k, E === 0) {
                        if (N += w - B, B < F) {
                          F -= B;
                          do
                            J[h++] = k[N++];
                          while (--B);
                          N = h - O, G = J;
                        }
                      } else if (E < B) {
                        if (N += w + E - B, B -= E, B < F) {
                          F -= B;
                          do
                            J[h++] = k[N++];
                          while (--B);
                          if (N = 0, E < F) {
                            B = E, F -= B;
                            do
                              J[h++] = k[N++];
                            while (--B);
                            N = h - O, G = J;
                          }
                        }
                      } else if (N += E - B, B < F) {
                        F -= B;
                        do
                          J[h++] = k[N++];
                        while (--B);
                        N = h - O, G = J;
                      }
                      for (; F > 2; )
                        J[h++] = G[N++], J[h++] = G[N++], J[h++] = G[N++], F -= 3;
                      F && (J[h++] = G[N++], F > 1 && (J[h++] = G[N++]));
                    } else {
                      N = h - O;
                      do
                        J[h++] = J[N++], J[h++] = J[N++], J[h++] = J[N++], F -= 3;
                      while (F > 2);
                      F && (J[h++] = J[N++], F > 1 && (J[h++] = J[N++]));
                    }
                  } else if ((B & 64) === 0) {
                    z = D[(z & 65535) + (A & (1 << B) - 1)];
                    continue i;
                  } else {
                    r.msg = "invalid distance code", a.mode = e;
                    break e;
                  }
                  break;
                }
            } else if ((B & 64) === 0) {
              z = C[(z & 65535) + (A & (1 << B) - 1)];
              continue t;
            } else if (B & 32) {
              a.mode = i;
              break e;
            } else {
              r.msg = "invalid literal/length code", a.mode = e;
              break e;
            }
            break;
          }
      } while (s < o && h < f);
    F = T >> 3, s -= F, T -= F << 3, A &= (1 << T) - 1, r.next_in = s, r.next_out = h, r.avail_in = s < o ? 5 + (o - s) : 5 - (s - o), r.avail_out = h < f ? 257 + (f - h) : 257 - (h - f), a.hold = A, a.bits = T;
  }, inffast;
}
var inftrees, hasRequiredInftrees;
function requireInftrees() {
  if (hasRequiredInftrees) return inftrees;
  hasRequiredInftrees = 1;
  var e = requireCommon(), i = 15, t = 852, r = 592, n = 0, a = 1, s = 2, o = [
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ], h = [
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ], l = [
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ], f = [
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  return inftrees = function(w, g, E, k, A, T, C, D) {
    var $ = D.bits, P = 0, z = 0, B = 0, F = 0, O = 0, N = 0, G = 0, V = 0, J = 0, Q = 0, W, ne, pe, be, ve, Ee = null, Ae = 0, _e, Be = new e.Buf16(i + 1), Me = new e.Buf16(i + 1), re = null, Te = 0, Fe, Se, Ye;
    for (P = 0; P <= i; P++)
      Be[P] = 0;
    for (z = 0; z < k; z++)
      Be[g[E + z]]++;
    for (O = $, F = i; F >= 1 && Be[F] === 0; F--)
      ;
    if (O > F && (O = F), F === 0)
      return A[T++] = 1 << 24 | 64 << 16 | 0, A[T++] = 1 << 24 | 64 << 16 | 0, D.bits = 1, 0;
    for (B = 1; B < F && Be[B] === 0; B++)
      ;
    for (O < B && (O = B), V = 1, P = 1; P <= i; P++)
      if (V <<= 1, V -= Be[P], V < 0)
        return -1;
    if (V > 0 && (w === n || F !== 1))
      return -1;
    for (Me[1] = 0, P = 1; P < i; P++)
      Me[P + 1] = Me[P] + Be[P];
    for (z = 0; z < k; z++)
      g[E + z] !== 0 && (C[Me[g[E + z]]++] = z);
    if (w === n ? (Ee = re = C, _e = 19) : w === a ? (Ee = o, Ae -= 257, re = h, Te -= 257, _e = 256) : (Ee = l, re = f, _e = -1), Q = 0, z = 0, P = B, ve = T, N = O, G = 0, pe = -1, J = 1 << O, be = J - 1, w === a && J > t || w === s && J > r)
      return 1;
    for (; ; ) {
      Fe = P - G, C[z] < _e ? (Se = 0, Ye = C[z]) : C[z] > _e ? (Se = re[Te + C[z]], Ye = Ee[Ae + C[z]]) : (Se = 96, Ye = 0), W = 1 << P - G, ne = 1 << N, B = ne;
      do
        ne -= W, A[ve + (Q >> G) + ne] = Fe << 24 | Se << 16 | Ye | 0;
      while (ne !== 0);
      for (W = 1 << P - 1; Q & W; )
        W >>= 1;
      if (W !== 0 ? (Q &= W - 1, Q += W) : Q = 0, z++, --Be[P] === 0) {
        if (P === F)
          break;
        P = g[E + C[z]];
      }
      if (P > O && (Q & be) !== pe) {
        for (G === 0 && (G = O), ve += B, N = P - G, V = 1 << N; N + G < F && (V -= Be[N + G], !(V <= 0)); )
          N++, V <<= 1;
        if (J += 1 << N, w === a && J > t || w === s && J > r)
          return 1;
        pe = Q & be, A[pe] = O << 24 | N << 16 | ve - T | 0;
      }
    }
    return Q !== 0 && (A[ve + Q] = P - G << 24 | 64 << 16 | 0), D.bits = O, 0;
  }, inftrees;
}
var hasRequiredInflate$1;
function requireInflate$1() {
  if (hasRequiredInflate$1) return inflate;
  hasRequiredInflate$1 = 1;
  var e = requireCommon(), i = requireAdler32(), t = requireCrc32(), r = requireInffast(), n = requireInftrees(), a = 0, s = 1, o = 2, h = 4, l = 5, f = 6, b = 0, w = 1, g = 2, E = -2, k = -3, A = -4, T = -5, C = 8, D = 1, $ = 2, P = 3, z = 4, B = 5, F = 6, O = 7, N = 8, G = 9, V = 10, J = 11, Q = 12, W = 13, ne = 14, pe = 15, be = 16, ve = 17, Ee = 18, Ae = 19, _e = 20, Be = 21, Me = 22, re = 23, Te = 24, Fe = 25, Se = 26, Ye = 27, Je = 28, et = 29, Ve = 30, tt = 31, qe = 32, Re = 852, nt = 592, Ge = 15, Ne = Ge;
  function he(te) {
    return (te >>> 24 & 255) + (te >>> 8 & 65280) + ((te & 65280) << 8) + ((te & 255) << 24);
  }
  function Qe() {
    this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new e.Buf16(320), this.work = new e.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
  }
  function Ze(te) {
    var me;
    return !te || !te.state ? E : (me = te.state, te.total_in = te.total_out = me.total = 0, te.msg = "", me.wrap && (te.adler = me.wrap & 1), me.mode = D, me.last = 0, me.havedict = 0, me.dmax = 32768, me.head = null, me.hold = 0, me.bits = 0, me.lencode = me.lendyn = new e.Buf32(Re), me.distcode = me.distdyn = new e.Buf32(nt), me.sane = 1, me.back = -1, b);
  }
  function He(te) {
    var me;
    return !te || !te.state ? E : (me = te.state, me.wsize = 0, me.whave = 0, me.wnext = 0, Ze(te));
  }
  function De(te, me) {
    var U, ye;
    return !te || !te.state || (ye = te.state, me < 0 ? (U = 0, me = -me) : (U = (me >> 4) + 1, me < 48 && (me &= 15)), me && (me < 8 || me > 15)) ? E : (ye.window !== null && ye.wbits !== me && (ye.window = null), ye.wrap = U, ye.wbits = me, He(te));
  }
  function lt(te, me) {
    var U, ye;
    return te ? (ye = new Qe(), te.state = ye, ye.window = null, U = De(te, me), U !== b && (te.state = null), U) : E;
  }
  function ot(te) {
    return lt(te, Ne);
  }
  var Le = !0, ze, je;
  function Oe(te) {
    if (Le) {
      var me;
      for (ze = new e.Buf32(512), je = new e.Buf32(32), me = 0; me < 144; )
        te.lens[me++] = 8;
      for (; me < 256; )
        te.lens[me++] = 9;
      for (; me < 280; )
        te.lens[me++] = 7;
      for (; me < 288; )
        te.lens[me++] = 8;
      for (n(s, te.lens, 0, 288, ze, 0, te.work, { bits: 9 }), me = 0; me < 32; )
        te.lens[me++] = 5;
      n(o, te.lens, 0, 32, je, 0, te.work, { bits: 5 }), Le = !1;
    }
    te.lencode = ze, te.lenbits = 9, te.distcode = je, te.distbits = 5;
  }
  function st(te, me, U, ye) {
    var it, I = te.state;
    return I.window === null && (I.wsize = 1 << I.wbits, I.wnext = 0, I.whave = 0, I.window = new e.Buf8(I.wsize)), ye >= I.wsize ? (e.arraySet(I.window, me, U - I.wsize, I.wsize, 0), I.wnext = 0, I.whave = I.wsize) : (it = I.wsize - I.wnext, it > ye && (it = ye), e.arraySet(I.window, me, U - ye, it, I.wnext), ye -= it, ye ? (e.arraySet(I.window, me, U - ye, ye, 0), I.wnext = ye, I.whave = I.wsize) : (I.wnext += it, I.wnext === I.wsize && (I.wnext = 0), I.whave < I.wsize && (I.whave += it))), 0;
  }
  function Z(te, me) {
    var U, ye, it, I, fe, de, H, ee, oe, We, M, _, d, u, v = 0, S, L, q, X, j, ae, K, ce, we = new e.Buf8(4), le, ge, Ue = (
      /* permutation of code lengths */
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    );
    if (!te || !te.state || !te.output || !te.input && te.avail_in !== 0)
      return E;
    U = te.state, U.mode === Q && (U.mode = W), fe = te.next_out, it = te.output, H = te.avail_out, I = te.next_in, ye = te.input, de = te.avail_in, ee = U.hold, oe = U.bits, We = de, M = H, ce = b;
    e:
      for (; ; )
        switch (U.mode) {
          case D:
            if (U.wrap === 0) {
              U.mode = W;
              break;
            }
            for (; oe < 16; ) {
              if (de === 0)
                break e;
              de--, ee += ye[I++] << oe, oe += 8;
            }
            if (U.wrap & 2 && ee === 35615) {
              U.check = 0, we[0] = ee & 255, we[1] = ee >>> 8 & 255, U.check = t(U.check, we, 2, 0), ee = 0, oe = 0, U.mode = $;
              break;
            }
            if (U.flags = 0, U.head && (U.head.done = !1), !(U.wrap & 1) || /* check if zlib header allowed */
            (((ee & 255) << 8) + (ee >> 8)) % 31) {
              te.msg = "incorrect header check", U.mode = Ve;
              break;
            }
            if ((ee & 15) !== C) {
              te.msg = "unknown compression method", U.mode = Ve;
              break;
            }
            if (ee >>>= 4, oe -= 4, K = (ee & 15) + 8, U.wbits === 0)
              U.wbits = K;
            else if (K > U.wbits) {
              te.msg = "invalid window size", U.mode = Ve;
              break;
            }
            U.dmax = 1 << K, te.adler = U.check = 1, U.mode = ee & 512 ? V : Q, ee = 0, oe = 0;
            break;
          case $:
            for (; oe < 16; ) {
              if (de === 0)
                break e;
              de--, ee += ye[I++] << oe, oe += 8;
            }
            if (U.flags = ee, (U.flags & 255) !== C) {
              te.msg = "unknown compression method", U.mode = Ve;
              break;
            }
            if (U.flags & 57344) {
              te.msg = "unknown header flags set", U.mode = Ve;
              break;
            }
            U.head && (U.head.text = ee >> 8 & 1), U.flags & 512 && (we[0] = ee & 255, we[1] = ee >>> 8 & 255, U.check = t(U.check, we, 2, 0)), ee = 0, oe = 0, U.mode = P;
          /* falls through */
          case P:
            for (; oe < 32; ) {
              if (de === 0)
                break e;
              de--, ee += ye[I++] << oe, oe += 8;
            }
            U.head && (U.head.time = ee), U.flags & 512 && (we[0] = ee & 255, we[1] = ee >>> 8 & 255, we[2] = ee >>> 16 & 255, we[3] = ee >>> 24 & 255, U.check = t(U.check, we, 4, 0)), ee = 0, oe = 0, U.mode = z;
          /* falls through */
          case z:
            for (; oe < 16; ) {
              if (de === 0)
                break e;
              de--, ee += ye[I++] << oe, oe += 8;
            }
            U.head && (U.head.xflags = ee & 255, U.head.os = ee >> 8), U.flags & 512 && (we[0] = ee & 255, we[1] = ee >>> 8 & 255, U.check = t(U.check, we, 2, 0)), ee = 0, oe = 0, U.mode = B;
          /* falls through */
          case B:
            if (U.flags & 1024) {
              for (; oe < 16; ) {
                if (de === 0)
                  break e;
                de--, ee += ye[I++] << oe, oe += 8;
              }
              U.length = ee, U.head && (U.head.extra_len = ee), U.flags & 512 && (we[0] = ee & 255, we[1] = ee >>> 8 & 255, U.check = t(U.check, we, 2, 0)), ee = 0, oe = 0;
            } else U.head && (U.head.extra = null);
            U.mode = F;
          /* falls through */
          case F:
            if (U.flags & 1024 && (_ = U.length, _ > de && (_ = de), _ && (U.head && (K = U.head.extra_len - U.length, U.head.extra || (U.head.extra = new Array(U.head.extra_len)), e.arraySet(
              U.head.extra,
              ye,
              I,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              _,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              K
            )), U.flags & 512 && (U.check = t(U.check, ye, _, I)), de -= _, I += _, U.length -= _), U.length))
              break e;
            U.length = 0, U.mode = O;
          /* falls through */
          case O:
            if (U.flags & 2048) {
              if (de === 0)
                break e;
              _ = 0;
              do
                K = ye[I + _++], U.head && K && U.length < 65536 && (U.head.name += String.fromCharCode(K));
              while (K && _ < de);
              if (U.flags & 512 && (U.check = t(U.check, ye, _, I)), de -= _, I += _, K)
                break e;
            } else U.head && (U.head.name = null);
            U.length = 0, U.mode = N;
          /* falls through */
          case N:
            if (U.flags & 4096) {
              if (de === 0)
                break e;
              _ = 0;
              do
                K = ye[I + _++], U.head && K && U.length < 65536 && (U.head.comment += String.fromCharCode(K));
              while (K && _ < de);
              if (U.flags & 512 && (U.check = t(U.check, ye, _, I)), de -= _, I += _, K)
                break e;
            } else U.head && (U.head.comment = null);
            U.mode = G;
          /* falls through */
          case G:
            if (U.flags & 512) {
              for (; oe < 16; ) {
                if (de === 0)
                  break e;
                de--, ee += ye[I++] << oe, oe += 8;
              }
              if (ee !== (U.check & 65535)) {
                te.msg = "header crc mismatch", U.mode = Ve;
                break;
              }
              ee = 0, oe = 0;
            }
            U.head && (U.head.hcrc = U.flags >> 9 & 1, U.head.done = !0), te.adler = U.check = 0, U.mode = Q;
            break;
          case V:
            for (; oe < 32; ) {
              if (de === 0)
                break e;
              de--, ee += ye[I++] << oe, oe += 8;
            }
            te.adler = U.check = he(ee), ee = 0, oe = 0, U.mode = J;
          /* falls through */
          case J:
            if (U.havedict === 0)
              return te.next_out = fe, te.avail_out = H, te.next_in = I, te.avail_in = de, U.hold = ee, U.bits = oe, g;
            te.adler = U.check = 1, U.mode = Q;
          /* falls through */
          case Q:
            if (me === l || me === f)
              break e;
          /* falls through */
          case W:
            if (U.last) {
              ee >>>= oe & 7, oe -= oe & 7, U.mode = Ye;
              break;
            }
            for (; oe < 3; ) {
              if (de === 0)
                break e;
              de--, ee += ye[I++] << oe, oe += 8;
            }
            switch (U.last = ee & 1, ee >>>= 1, oe -= 1, ee & 3) {
              case 0:
                U.mode = ne;
                break;
              case 1:
                if (Oe(U), U.mode = _e, me === f) {
                  ee >>>= 2, oe -= 2;
                  break e;
                }
                break;
              case 2:
                U.mode = ve;
                break;
              case 3:
                te.msg = "invalid block type", U.mode = Ve;
            }
            ee >>>= 2, oe -= 2;
            break;
          case ne:
            for (ee >>>= oe & 7, oe -= oe & 7; oe < 32; ) {
              if (de === 0)
                break e;
              de--, ee += ye[I++] << oe, oe += 8;
            }
            if ((ee & 65535) !== (ee >>> 16 ^ 65535)) {
              te.msg = "invalid stored block lengths", U.mode = Ve;
              break;
            }
            if (U.length = ee & 65535, ee = 0, oe = 0, U.mode = pe, me === f)
              break e;
          /* falls through */
          case pe:
            U.mode = be;
          /* falls through */
          case be:
            if (_ = U.length, _) {
              if (_ > de && (_ = de), _ > H && (_ = H), _ === 0)
                break e;
              e.arraySet(it, ye, I, _, fe), de -= _, I += _, H -= _, fe += _, U.length -= _;
              break;
            }
            U.mode = Q;
            break;
          case ve:
            for (; oe < 14; ) {
              if (de === 0)
                break e;
              de--, ee += ye[I++] << oe, oe += 8;
            }
            if (U.nlen = (ee & 31) + 257, ee >>>= 5, oe -= 5, U.ndist = (ee & 31) + 1, ee >>>= 5, oe -= 5, U.ncode = (ee & 15) + 4, ee >>>= 4, oe -= 4, U.nlen > 286 || U.ndist > 30) {
              te.msg = "too many length or distance symbols", U.mode = Ve;
              break;
            }
            U.have = 0, U.mode = Ee;
          /* falls through */
          case Ee:
            for (; U.have < U.ncode; ) {
              for (; oe < 3; ) {
                if (de === 0)
                  break e;
                de--, ee += ye[I++] << oe, oe += 8;
              }
              U.lens[Ue[U.have++]] = ee & 7, ee >>>= 3, oe -= 3;
            }
            for (; U.have < 19; )
              U.lens[Ue[U.have++]] = 0;
            if (U.lencode = U.lendyn, U.lenbits = 7, le = { bits: U.lenbits }, ce = n(a, U.lens, 0, 19, U.lencode, 0, U.work, le), U.lenbits = le.bits, ce) {
              te.msg = "invalid code lengths set", U.mode = Ve;
              break;
            }
            U.have = 0, U.mode = Ae;
          /* falls through */
          case Ae:
            for (; U.have < U.nlen + U.ndist; ) {
              for (; v = U.lencode[ee & (1 << U.lenbits) - 1], S = v >>> 24, L = v >>> 16 & 255, q = v & 65535, !(S <= oe); ) {
                if (de === 0)
                  break e;
                de--, ee += ye[I++] << oe, oe += 8;
              }
              if (q < 16)
                ee >>>= S, oe -= S, U.lens[U.have++] = q;
              else {
                if (q === 16) {
                  for (ge = S + 2; oe < ge; ) {
                    if (de === 0)
                      break e;
                    de--, ee += ye[I++] << oe, oe += 8;
                  }
                  if (ee >>>= S, oe -= S, U.have === 0) {
                    te.msg = "invalid bit length repeat", U.mode = Ve;
                    break;
                  }
                  K = U.lens[U.have - 1], _ = 3 + (ee & 3), ee >>>= 2, oe -= 2;
                } else if (q === 17) {
                  for (ge = S + 3; oe < ge; ) {
                    if (de === 0)
                      break e;
                    de--, ee += ye[I++] << oe, oe += 8;
                  }
                  ee >>>= S, oe -= S, K = 0, _ = 3 + (ee & 7), ee >>>= 3, oe -= 3;
                } else {
                  for (ge = S + 7; oe < ge; ) {
                    if (de === 0)
                      break e;
                    de--, ee += ye[I++] << oe, oe += 8;
                  }
                  ee >>>= S, oe -= S, K = 0, _ = 11 + (ee & 127), ee >>>= 7, oe -= 7;
                }
                if (U.have + _ > U.nlen + U.ndist) {
                  te.msg = "invalid bit length repeat", U.mode = Ve;
                  break;
                }
                for (; _--; )
                  U.lens[U.have++] = K;
              }
            }
            if (U.mode === Ve)
              break;
            if (U.lens[256] === 0) {
              te.msg = "invalid code -- missing end-of-block", U.mode = Ve;
              break;
            }
            if (U.lenbits = 9, le = { bits: U.lenbits }, ce = n(s, U.lens, 0, U.nlen, U.lencode, 0, U.work, le), U.lenbits = le.bits, ce) {
              te.msg = "invalid literal/lengths set", U.mode = Ve;
              break;
            }
            if (U.distbits = 6, U.distcode = U.distdyn, le = { bits: U.distbits }, ce = n(o, U.lens, U.nlen, U.ndist, U.distcode, 0, U.work, le), U.distbits = le.bits, ce) {
              te.msg = "invalid distances set", U.mode = Ve;
              break;
            }
            if (U.mode = _e, me === f)
              break e;
          /* falls through */
          case _e:
            U.mode = Be;
          /* falls through */
          case Be:
            if (de >= 6 && H >= 258) {
              te.next_out = fe, te.avail_out = H, te.next_in = I, te.avail_in = de, U.hold = ee, U.bits = oe, r(te, M), fe = te.next_out, it = te.output, H = te.avail_out, I = te.next_in, ye = te.input, de = te.avail_in, ee = U.hold, oe = U.bits, U.mode === Q && (U.back = -1);
              break;
            }
            for (U.back = 0; v = U.lencode[ee & (1 << U.lenbits) - 1], S = v >>> 24, L = v >>> 16 & 255, q = v & 65535, !(S <= oe); ) {
              if (de === 0)
                break e;
              de--, ee += ye[I++] << oe, oe += 8;
            }
            if (L && (L & 240) === 0) {
              for (X = S, j = L, ae = q; v = U.lencode[ae + ((ee & (1 << X + j) - 1) >> X)], S = v >>> 24, L = v >>> 16 & 255, q = v & 65535, !(X + S <= oe); ) {
                if (de === 0)
                  break e;
                de--, ee += ye[I++] << oe, oe += 8;
              }
              ee >>>= X, oe -= X, U.back += X;
            }
            if (ee >>>= S, oe -= S, U.back += S, U.length = q, L === 0) {
              U.mode = Se;
              break;
            }
            if (L & 32) {
              U.back = -1, U.mode = Q;
              break;
            }
            if (L & 64) {
              te.msg = "invalid literal/length code", U.mode = Ve;
              break;
            }
            U.extra = L & 15, U.mode = Me;
          /* falls through */
          case Me:
            if (U.extra) {
              for (ge = U.extra; oe < ge; ) {
                if (de === 0)
                  break e;
                de--, ee += ye[I++] << oe, oe += 8;
              }
              U.length += ee & (1 << U.extra) - 1, ee >>>= U.extra, oe -= U.extra, U.back += U.extra;
            }
            U.was = U.length, U.mode = re;
          /* falls through */
          case re:
            for (; v = U.distcode[ee & (1 << U.distbits) - 1], S = v >>> 24, L = v >>> 16 & 255, q = v & 65535, !(S <= oe); ) {
              if (de === 0)
                break e;
              de--, ee += ye[I++] << oe, oe += 8;
            }
            if ((L & 240) === 0) {
              for (X = S, j = L, ae = q; v = U.distcode[ae + ((ee & (1 << X + j) - 1) >> X)], S = v >>> 24, L = v >>> 16 & 255, q = v & 65535, !(X + S <= oe); ) {
                if (de === 0)
                  break e;
                de--, ee += ye[I++] << oe, oe += 8;
              }
              ee >>>= X, oe -= X, U.back += X;
            }
            if (ee >>>= S, oe -= S, U.back += S, L & 64) {
              te.msg = "invalid distance code", U.mode = Ve;
              break;
            }
            U.offset = q, U.extra = L & 15, U.mode = Te;
          /* falls through */
          case Te:
            if (U.extra) {
              for (ge = U.extra; oe < ge; ) {
                if (de === 0)
                  break e;
                de--, ee += ye[I++] << oe, oe += 8;
              }
              U.offset += ee & (1 << U.extra) - 1, ee >>>= U.extra, oe -= U.extra, U.back += U.extra;
            }
            if (U.offset > U.dmax) {
              te.msg = "invalid distance too far back", U.mode = Ve;
              break;
            }
            U.mode = Fe;
          /* falls through */
          case Fe:
            if (H === 0)
              break e;
            if (_ = M - H, U.offset > _) {
              if (_ = U.offset - _, _ > U.whave && U.sane) {
                te.msg = "invalid distance too far back", U.mode = Ve;
                break;
              }
              _ > U.wnext ? (_ -= U.wnext, d = U.wsize - _) : d = U.wnext - _, _ > U.length && (_ = U.length), u = U.window;
            } else
              u = it, d = fe - U.offset, _ = U.length;
            _ > H && (_ = H), H -= _, U.length -= _;
            do
              it[fe++] = u[d++];
            while (--_);
            U.length === 0 && (U.mode = Be);
            break;
          case Se:
            if (H === 0)
              break e;
            it[fe++] = U.length, H--, U.mode = Be;
            break;
          case Ye:
            if (U.wrap) {
              for (; oe < 32; ) {
                if (de === 0)
                  break e;
                de--, ee |= ye[I++] << oe, oe += 8;
              }
              if (M -= H, te.total_out += M, U.total += M, M && (te.adler = U.check = /*UPDATE(state.check, put - _out, _out);*/
              U.flags ? t(U.check, it, M, fe - M) : i(U.check, it, M, fe - M)), M = H, (U.flags ? ee : he(ee)) !== U.check) {
                te.msg = "incorrect data check", U.mode = Ve;
                break;
              }
              ee = 0, oe = 0;
            }
            U.mode = Je;
          /* falls through */
          case Je:
            if (U.wrap && U.flags) {
              for (; oe < 32; ) {
                if (de === 0)
                  break e;
                de--, ee += ye[I++] << oe, oe += 8;
              }
              if (ee !== (U.total & 4294967295)) {
                te.msg = "incorrect length check", U.mode = Ve;
                break;
              }
              ee = 0, oe = 0;
            }
            U.mode = et;
          /* falls through */
          case et:
            ce = w;
            break e;
          case Ve:
            ce = k;
            break e;
          case tt:
            return A;
          case qe:
          /* falls through */
          default:
            return E;
        }
    return te.next_out = fe, te.avail_out = H, te.next_in = I, te.avail_in = de, U.hold = ee, U.bits = oe, (U.wsize || M !== te.avail_out && U.mode < Ve && (U.mode < Ye || me !== h)) && st(te, te.output, te.next_out, M - te.avail_out), We -= te.avail_in, M -= te.avail_out, te.total_in += We, te.total_out += M, U.total += M, U.wrap && M && (te.adler = U.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    U.flags ? t(U.check, it, M, te.next_out - M) : i(U.check, it, M, te.next_out - M)), te.data_type = U.bits + (U.last ? 64 : 0) + (U.mode === Q ? 128 : 0) + (U.mode === _e || U.mode === pe ? 256 : 0), (We === 0 && M === 0 || me === h) && ce === b && (ce = T), ce;
  }
  function ue(te) {
    if (!te || !te.state)
      return E;
    var me = te.state;
    return me.window && (me.window = null), te.state = null, b;
  }
  function xe(te, me) {
    var U;
    return !te || !te.state || (U = te.state, (U.wrap & 2) === 0) ? E : (U.head = me, me.done = !1, b);
  }
  function ke(te, me) {
    var U = me.length, ye, it, I;
    return !te || !te.state || (ye = te.state, ye.wrap !== 0 && ye.mode !== J) ? E : ye.mode === J && (it = 1, it = i(it, me, U, 0), it !== ye.check) ? k : (I = st(te, me, U, U), I ? (ye.mode = tt, A) : (ye.havedict = 1, b));
  }
  return inflate.inflateReset = He, inflate.inflateReset2 = De, inflate.inflateResetKeep = Ze, inflate.inflateInit = ot, inflate.inflateInit2 = lt, inflate.inflate = Z, inflate.inflateEnd = ue, inflate.inflateGetHeader = xe, inflate.inflateSetDictionary = ke, inflate.inflateInfo = "pako inflate (from Nodeca project)", inflate;
}
var constants, hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, constants = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  }), constants;
}
var gzheader, hasRequiredGzheader;
function requireGzheader() {
  if (hasRequiredGzheader) return gzheader;
  hasRequiredGzheader = 1;
  function e() {
    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
  }
  return gzheader = e, gzheader;
}
var hasRequiredInflate;
function requireInflate() {
  if (hasRequiredInflate) return inflate$1;
  hasRequiredInflate = 1;
  var e = requireInflate$1(), i = requireCommon(), t = requireStrings(), r = requireConstants(), n = requireMessages(), a = requireZstream(), s = requireGzheader(), o = Object.prototype.toString;
  function h(b) {
    if (!(this instanceof h)) return new h(b);
    this.options = i.assign({
      chunkSize: 16384,
      windowBits: 0,
      to: ""
    }, b || {});
    var w = this.options;
    w.raw && w.windowBits >= 0 && w.windowBits < 16 && (w.windowBits = -w.windowBits, w.windowBits === 0 && (w.windowBits = -15)), w.windowBits >= 0 && w.windowBits < 16 && !(b && b.windowBits) && (w.windowBits += 32), w.windowBits > 15 && w.windowBits < 48 && (w.windowBits & 15) === 0 && (w.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new a(), this.strm.avail_out = 0;
    var g = e.inflateInit2(
      this.strm,
      w.windowBits
    );
    if (g !== r.Z_OK)
      throw new Error(n[g]);
    if (this.header = new s(), e.inflateGetHeader(this.strm, this.header), w.dictionary && (typeof w.dictionary == "string" ? w.dictionary = t.string2buf(w.dictionary) : o.call(w.dictionary) === "[object ArrayBuffer]" && (w.dictionary = new Uint8Array(w.dictionary)), w.raw && (g = e.inflateSetDictionary(this.strm, w.dictionary), g !== r.Z_OK)))
      throw new Error(n[g]);
  }
  h.prototype.push = function(b, w) {
    var g = this.strm, E = this.options.chunkSize, k = this.options.dictionary, A, T, C, D, $, P = !1;
    if (this.ended)
      return !1;
    T = w === ~~w ? w : w === !0 ? r.Z_FINISH : r.Z_NO_FLUSH, typeof b == "string" ? g.input = t.binstring2buf(b) : o.call(b) === "[object ArrayBuffer]" ? g.input = new Uint8Array(b) : g.input = b, g.next_in = 0, g.avail_in = g.input.length;
    do {
      if (g.avail_out === 0 && (g.output = new i.Buf8(E), g.next_out = 0, g.avail_out = E), A = e.inflate(g, r.Z_NO_FLUSH), A === r.Z_NEED_DICT && k && (A = e.inflateSetDictionary(this.strm, k)), A === r.Z_BUF_ERROR && P === !0 && (A = r.Z_OK, P = !1), A !== r.Z_STREAM_END && A !== r.Z_OK)
        return this.onEnd(A), this.ended = !0, !1;
      g.next_out && (g.avail_out === 0 || A === r.Z_STREAM_END || g.avail_in === 0 && (T === r.Z_FINISH || T === r.Z_SYNC_FLUSH)) && (this.options.to === "string" ? (C = t.utf8border(g.output, g.next_out), D = g.next_out - C, $ = t.buf2string(g.output, C), g.next_out = D, g.avail_out = E - D, D && i.arraySet(g.output, g.output, C, D, 0), this.onData($)) : this.onData(i.shrinkBuf(g.output, g.next_out))), g.avail_in === 0 && g.avail_out === 0 && (P = !0);
    } while ((g.avail_in > 0 || g.avail_out === 0) && A !== r.Z_STREAM_END);
    return A === r.Z_STREAM_END && (T = r.Z_FINISH), T === r.Z_FINISH ? (A = e.inflateEnd(this.strm), this.onEnd(A), this.ended = !0, A === r.Z_OK) : (T === r.Z_SYNC_FLUSH && (this.onEnd(r.Z_OK), g.avail_out = 0), !0);
  }, h.prototype.onData = function(b) {
    this.chunks.push(b);
  }, h.prototype.onEnd = function(b) {
    b === r.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = b, this.msg = this.strm.msg;
  };
  function l(b, w) {
    var g = new h(w);
    if (g.push(b, !0), g.err)
      throw g.msg || n[g.err];
    return g.result;
  }
  function f(b, w) {
    return w = w || {}, w.raw = !0, l(b, w);
  }
  return inflate$1.Inflate = h, inflate$1.inflate = l, inflate$1.inflateRaw = f, inflate$1.ungzip = l, inflate$1;
}
var pako_1, hasRequiredPako;
function requirePako() {
  if (hasRequiredPako) return pako_1;
  hasRequiredPako = 1;
  var e = requireCommon().assign, i = requireDeflate(), t = requireInflate(), r = requireConstants(), n = {};
  return e(n, i, t, r), pako_1 = n, pako_1;
}
var pakoExports = requirePako();
const pako = /* @__PURE__ */ getDefaultExportFromCjs(pakoExports);
var UPNG = {};
UPNG.toRGBA8 = function(e) {
  var i = e.width, t = e.height;
  if (e.tabs.acTL == null) return [UPNG.toRGBA8.decodeImage(e.data, i, t, e).buffer];
  var r = [];
  e.frames[0].data == null && (e.frames[0].data = e.data);
  for (var n = i * t * 4, a = new Uint8Array(n), s = new Uint8Array(n), o = new Uint8Array(n), h = 0; h < e.frames.length; h++) {
    var l = e.frames[h], f = l.rect.x, b = l.rect.y, w = l.rect.width, g = l.rect.height, E = UPNG.toRGBA8.decodeImage(l.data, w, g, e);
    if (h != 0) for (var k = 0; k < n; k++) o[k] = a[k];
    if (l.blend == 0 ? UPNG._copyTile(E, w, g, a, i, t, f, b, 0) : l.blend == 1 && UPNG._copyTile(E, w, g, a, i, t, f, b, 1), r.push(a.buffer.slice(0)), l.dispose != 0) {
      if (l.dispose == 1) UPNG._copyTile(s, w, g, a, i, t, f, b, 0);
      else if (l.dispose == 2) for (var k = 0; k < n; k++) a[k] = o[k];
    }
  }
  return r;
};
UPNG.toRGBA8.decodeImage = function(e, i, t, r) {
  var n = i * t, a = UPNG.decode._getBPP(r), s = Math.ceil(i * a / 8), o = new Uint8Array(n * 4), h = new Uint32Array(o.buffer), l = r.ctype, f = r.depth, b = UPNG._bin.readUshort;
  if (l == 6) {
    var w = n << 2;
    if (f == 8) for (var g = 0; g < w; g += 4)
      o[g] = e[g], o[g + 1] = e[g + 1], o[g + 2] = e[g + 2], o[g + 3] = e[g + 3];
    if (f == 16) for (var g = 0; g < w; g++)
      o[g] = e[g << 1];
  } else if (l == 2) {
    var E = r.tabs.tRNS;
    if (E == null) {
      if (f == 8) for (var g = 0; g < n; g++) {
        var k = g * 3;
        h[g] = 255 << 24 | e[k + 2] << 16 | e[k + 1] << 8 | e[k];
      }
      if (f == 16) for (var g = 0; g < n; g++) {
        var k = g * 6;
        h[g] = 255 << 24 | e[k + 4] << 16 | e[k + 2] << 8 | e[k];
      }
    } else {
      var A = E[0], T = E[1], C = E[2];
      if (f == 8) for (var g = 0; g < n; g++) {
        var D = g << 2, k = g * 3;
        h[g] = 255 << 24 | e[k + 2] << 16 | e[k + 1] << 8 | e[k], e[k] == A && e[k + 1] == T && e[k + 2] == C && (o[D + 3] = 0);
      }
      if (f == 16) for (var g = 0; g < n; g++) {
        var D = g << 2, k = g * 6;
        h[g] = 255 << 24 | e[k + 4] << 16 | e[k + 2] << 8 | e[k], b(e, k) == A && b(e, k + 2) == T && b(e, k + 4) == C && (o[D + 3] = 0);
      }
    }
  } else if (l == 3) {
    var $ = r.tabs.PLTE, P = r.tabs.tRNS, z = P ? P.length : 0;
    if (f == 1) for (var B = 0; B < t; B++)
      for (var F = B * s, O = B * i, g = 0; g < i; g++) {
        var D = O + g << 2, N = e[F + (g >> 3)] >> 7 - ((g & 7) << 0) & 1, G = 3 * N;
        o[D] = $[G], o[D + 1] = $[G + 1], o[D + 2] = $[G + 2], o[D + 3] = N < z ? P[N] : 255;
      }
    if (f == 2) for (var B = 0; B < t; B++)
      for (var F = B * s, O = B * i, g = 0; g < i; g++) {
        var D = O + g << 2, N = e[F + (g >> 2)] >> 6 - ((g & 3) << 1) & 3, G = 3 * N;
        o[D] = $[G], o[D + 1] = $[G + 1], o[D + 2] = $[G + 2], o[D + 3] = N < z ? P[N] : 255;
      }
    if (f == 4) for (var B = 0; B < t; B++)
      for (var F = B * s, O = B * i, g = 0; g < i; g++) {
        var D = O + g << 2, N = e[F + (g >> 1)] >> 4 - ((g & 1) << 2) & 15, G = 3 * N;
        o[D] = $[G], o[D + 1] = $[G + 1], o[D + 2] = $[G + 2], o[D + 3] = N < z ? P[N] : 255;
      }
    if (f == 8) for (var g = 0; g < n; g++) {
      var D = g << 2, N = e[g], G = 3 * N;
      o[D] = $[G], o[D + 1] = $[G + 1], o[D + 2] = $[G + 2], o[D + 3] = N < z ? P[N] : 255;
    }
  } else if (l == 4) {
    if (f == 8) for (var g = 0; g < n; g++) {
      var D = g << 2, V = g << 1, J = e[V];
      o[D] = J, o[D + 1] = J, o[D + 2] = J, o[D + 3] = e[V + 1];
    }
    if (f == 16) for (var g = 0; g < n; g++) {
      var D = g << 2, V = g << 2, J = e[V];
      o[D] = J, o[D + 1] = J, o[D + 2] = J, o[D + 3] = e[V + 2];
    }
  } else if (l == 0)
    for (var A = r.tabs.tRNS ? r.tabs.tRNS : -1, B = 0; B < t; B++) {
      var Q = B * s, W = B * i;
      if (f == 1) for (var ne = 0; ne < i; ne++) {
        var J = 255 * (e[Q + (ne >>> 3)] >>> 7 - (ne & 7) & 1), pe = J == A * 255 ? 0 : 255;
        h[W + ne] = pe << 24 | J << 16 | J << 8 | J;
      }
      else if (f == 2) for (var ne = 0; ne < i; ne++) {
        var J = 85 * (e[Q + (ne >>> 2)] >>> 6 - ((ne & 3) << 1) & 3), pe = J == A * 85 ? 0 : 255;
        h[W + ne] = pe << 24 | J << 16 | J << 8 | J;
      }
      else if (f == 4) for (var ne = 0; ne < i; ne++) {
        var J = 17 * (e[Q + (ne >>> 1)] >>> 4 - ((ne & 1) << 2) & 15), pe = J == A * 17 ? 0 : 255;
        h[W + ne] = pe << 24 | J << 16 | J << 8 | J;
      }
      else if (f == 8) for (var ne = 0; ne < i; ne++) {
        var J = e[Q + ne], pe = J == A ? 0 : 255;
        h[W + ne] = pe << 24 | J << 16 | J << 8 | J;
      }
      else if (f == 16) for (var ne = 0; ne < i; ne++) {
        var J = e[Q + (ne << 1)], pe = b(e, Q + (ne << g)) == A ? 0 : 255;
        h[W + ne] = pe << 24 | J << 16 | J << 8 | J;
      }
    }
  return o;
};
UPNG.decode = function(e) {
  for (var i = new Uint8Array(e), t = 8, r = UPNG._bin, n = r.readUshort, a = r.readUint, s = { tabs: {}, frames: [] }, o = new Uint8Array(i.length), h = 0, l, f = 0, b = [137, 80, 78, 71, 13, 10, 26, 10], w = 0; w < 8; w++) if (i[w] != b[w]) throw "The input is not a PNG file!";
  for (; t < i.length; ) {
    var g = r.readUint(i, t);
    t += 4;
    var E = r.readASCII(i, t, 4);
    if (t += 4, E == "IHDR")
      UPNG.decode._IHDR(i, t, s);
    else if (E == "IDAT") {
      for (var w = 0; w < g; w++) o[h + w] = i[t + w];
      h += g;
    } else if (E == "acTL")
      s.tabs[E] = { num_frames: a(i, t), num_plays: a(i, t + 4) }, l = new Uint8Array(i.length);
    else if (E == "fcTL") {
      if (f != 0) {
        var k = s.frames[s.frames.length - 1];
        k.data = UPNG.decode._decompress(s, l.slice(0, f), k.rect.width, k.rect.height), f = 0;
      }
      var A = { x: a(i, t + 12), y: a(i, t + 16), width: a(i, t + 4), height: a(i, t + 8) }, T = n(i, t + 22);
      T = n(i, t + 20) / (T == 0 ? 100 : T);
      var C = { rect: A, delay: Math.round(T * 1e3), dispose: i[t + 24], blend: i[t + 25] };
      s.frames.push(C);
    } else if (E == "fdAT") {
      for (var w = 0; w < g - 4; w++) l[f + w] = i[t + w + 4];
      f += g - 4;
    } else if (E == "pHYs")
      s.tabs[E] = [r.readUint(i, t), r.readUint(i, t + 4), i[t + 8]];
    else if (E == "cHRM") {
      s.tabs[E] = [];
      for (var w = 0; w < 8; w++) s.tabs[E].push(r.readUint(i, t + w * 4));
    } else if (E == "tEXt") {
      s.tabs[E] == null && (s.tabs[E] = {});
      var D = r.nextZero(i, t), $ = r.readASCII(i, t, D - t), P = r.readASCII(i, D + 1, t + g - D - 1);
      s.tabs[E][$] = P;
    } else if (E == "iTXt") {
      s.tabs[E] == null && (s.tabs[E] = {});
      var D = 0, z = t;
      D = r.nextZero(i, z);
      var $ = r.readASCII(i, z, D - z);
      z = D + 1, i[z], i[z + 1], z += 2, D = r.nextZero(i, z), r.readASCII(i, z, D - z), z = D + 1, D = r.nextZero(i, z), r.readUTF8(i, z, D - z), z = D + 1;
      var P = r.readUTF8(i, z, g - (z - t));
      s.tabs[E][$] = P;
    } else if (E == "PLTE")
      s.tabs[E] = r.readBytes(i, t, g);
    else if (E == "hIST") {
      var B = s.tabs.PLTE.length / 3;
      s.tabs[E] = [];
      for (var w = 0; w < B; w++) s.tabs[E].push(n(i, t + w * 2));
    } else if (E == "tRNS")
      s.ctype == 3 ? s.tabs[E] = r.readBytes(i, t, g) : s.ctype == 0 ? s.tabs[E] = n(i, t) : s.ctype == 2 && (s.tabs[E] = [n(i, t), n(i, t + 2), n(i, t + 4)]);
    else if (E == "gAMA") s.tabs[E] = r.readUint(i, t) / 1e5;
    else if (E == "sRGB") s.tabs[E] = i[t];
    else if (E == "bKGD")
      s.ctype == 0 || s.ctype == 4 ? s.tabs[E] = [n(i, t)] : s.ctype == 2 || s.ctype == 6 ? s.tabs[E] = [n(i, t), n(i, t + 2), n(i, t + 4)] : s.ctype == 3 && (s.tabs[E] = i[t]);
    else if (E == "IEND")
      break;
    t += g, r.readUint(i, t), t += 4;
  }
  if (f != 0) {
    var k = s.frames[s.frames.length - 1];
    k.data = UPNG.decode._decompress(s, l.slice(0, f), k.rect.width, k.rect.height), f = 0;
  }
  return s.data = UPNG.decode._decompress(s, o, s.width, s.height), delete s.compress, delete s.interlace, delete s.filter, s;
};
UPNG.decode._decompress = function(e, i, t, r) {
  var n = UPNG.decode._getBPP(e), a = Math.ceil(t * n / 8), s = new Uint8Array((a + 1 + e.interlace) * r);
  return i = UPNG.decode._inflate(i, s), e.interlace == 0 ? i = UPNG.decode._filterZero(i, e, 0, t, r) : e.interlace == 1 && (i = UPNG.decode._readInterlace(i, e)), i;
};
UPNG.decode._inflate = function(e, i) {
  var t = UPNG.inflateRaw(new Uint8Array(e.buffer, 2, e.length - 6), i);
  return t;
};
UPNG.inflateRaw = function() {
  var e = {};
  return e.H = {}, e.H.N = function(i, t) {
    var r = Uint8Array, n = 0, a = 0, s = 0, o = 0, h = 0, l = 0, f = 0, b = 0, w = 0, g, E;
    if (i[0] == 3 && i[1] == 0) return t || new r(0);
    var k = e.H, A = k.b, T = k.e, C = k.R, D = k.n, $ = k.A, P = k.Z, z = k.m, B = t == null;
    for (B && (t = new r(i.length >>> 2 << 3)); n == 0; ) {
      if (n = A(i, w, 1), a = A(i, w + 1, 2), w += 3, a == 0) {
        (w & 7) != 0 && (w += 8 - (w & 7));
        var F = (w >>> 3) + 4, O = i[F - 4] | i[F - 3] << 8;
        B && (t = e.H.W(t, b + O)), t.set(new r(i.buffer, i.byteOffset + F, O), b), w = F + O << 3, b += O;
        continue;
      }
      if (B && (t = e.H.W(t, b + (1 << 17))), a == 1 && (g = z.J, E = z.h, l = 511, f = 31), a == 2) {
        s = T(i, w, 5) + 257, o = T(i, w + 5, 5) + 1, h = T(i, w + 10, 4) + 4, w += 14;
        for (var N = 1, G = 0; G < 38; G += 2)
          z.Q[G] = 0, z.Q[G + 1] = 0;
        for (var G = 0; G < h; G++) {
          var V = T(i, w + G * 3, 3);
          z.Q[(z.X[G] << 1) + 1] = V, V > N && (N = V);
        }
        w += 3 * h, D(z.Q, N), $(z.Q, N, z.u), g = z.w, E = z.d, w = C(z.u, (1 << N) - 1, s + o, i, w, z.v);
        var J = k.V(z.v, 0, s, z.C);
        l = (1 << J) - 1;
        var Q = k.V(z.v, s, o, z.D);
        f = (1 << Q) - 1, D(z.C, J), $(z.C, J, g), D(z.D, Q), $(z.D, Q, E);
      }
      for (; ; ) {
        var W = g[P(i, w) & l];
        w += W & 15;
        var ne = W >>> 4;
        if (!(ne >>> 8))
          t[b++] = ne;
        else {
          if (ne == 256)
            break;
          var pe = b + ne - 254;
          if (ne > 264) {
            var be = z.q[ne - 257];
            pe = b + (be >>> 3) + T(i, w, be & 7), w += be & 7;
          }
          var ve = E[P(i, w) & f];
          w += ve & 15;
          var Ee = ve >>> 4, Ae = z.c[Ee], _e = (Ae >>> 4) + A(i, w, Ae & 15);
          for (w += Ae & 15; b < pe; )
            t[b] = t[b++ - _e], t[b] = t[b++ - _e], t[b] = t[b++ - _e], t[b] = t[b++ - _e];
          b = pe;
        }
      }
    }
    return t.length == b ? t : t.slice(0, b);
  }, e.H.W = function(i, t) {
    var r = i.length;
    if (t <= r) return i;
    var n = new Uint8Array(r << 1);
    return n.set(i, 0), n;
  }, e.H.R = function(i, t, r, n, a, s) {
    for (var o = e.H.e, h = e.H.Z, l = 0; l < r; ) {
      var f = i[h(n, a) & t];
      a += f & 15;
      var b = f >>> 4;
      if (b <= 15)
        s[l] = b, l++;
      else {
        var w = 0, g = 0;
        b == 16 ? (g = 3 + o(n, a, 2), a += 2, w = s[l - 1]) : b == 17 ? (g = 3 + o(n, a, 3), a += 3) : b == 18 && (g = 11 + o(n, a, 7), a += 7);
        for (var E = l + g; l < E; )
          s[l] = w, l++;
      }
    }
    return a;
  }, e.H.V = function(i, t, r, n) {
    for (var a = 0, s = 0, o = n.length >>> 1; s < r; ) {
      var h = i[s + t];
      n[s << 1] = 0, n[(s << 1) + 1] = h, h > a && (a = h), s++;
    }
    for (; s < o; )
      n[s << 1] = 0, n[(s << 1) + 1] = 0, s++;
    return a;
  }, e.H.n = function(i, t) {
    for (var r = e.H.m, n = i.length, a, s, o, h, l, f = r.j, h = 0; h <= t; h++) f[h] = 0;
    for (h = 1; h < n; h += 2) f[i[h]]++;
    var b = r.K;
    for (a = 0, f[0] = 0, s = 1; s <= t; s++)
      a = a + f[s - 1] << 1, b[s] = a;
    for (o = 0; o < n; o += 2)
      l = i[o + 1], l != 0 && (i[o] = b[l], b[l]++);
  }, e.H.A = function(i, t, r) {
    for (var n = i.length, a = e.H.m, s = a.r, o = 0; o < n; o += 2) if (i[o + 1] != 0)
      for (var h = o >> 1, l = i[o + 1], f = h << 4 | l, b = t - l, w = i[o] << b, g = w + (1 << b); w != g; ) {
        var E = s[w] >>> 15 - t;
        r[E] = f, w++;
      }
  }, e.H.l = function(i, t) {
    for (var r = e.H.m.r, n = 15 - t, a = 0; a < i.length; a += 2) {
      var s = i[a] << t - i[a + 1];
      i[a] = r[s] >>> n;
    }
  }, e.H.M = function(i, t, r) {
    r = r << (t & 7);
    var n = t >>> 3;
    i[n] |= r, i[n + 1] |= r >>> 8;
  }, e.H.I = function(i, t, r) {
    r = r << (t & 7);
    var n = t >>> 3;
    i[n] |= r, i[n + 1] |= r >>> 8, i[n + 2] |= r >>> 16;
  }, e.H.e = function(i, t, r) {
    return (i[t >>> 3] | i[(t >>> 3) + 1] << 8) >>> (t & 7) & (1 << r) - 1;
  }, e.H.b = function(i, t, r) {
    return (i[t >>> 3] | i[(t >>> 3) + 1] << 8 | i[(t >>> 3) + 2] << 16) >>> (t & 7) & (1 << r) - 1;
  }, e.H.Z = function(i, t) {
    return (i[t >>> 3] | i[(t >>> 3) + 1] << 8 | i[(t >>> 3) + 2] << 16) >>> (t & 7);
  }, e.H.i = function(i, t) {
    return (i[t >>> 3] | i[(t >>> 3) + 1] << 8 | i[(t >>> 3) + 2] << 16 | i[(t >>> 3) + 3] << 24) >>> (t & 7);
  }, e.H.m = function() {
    var i = Uint16Array, t = Uint32Array;
    return { K: new i(16), j: new i(16), X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], q: new i(32), p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], c: new t(32), J: new i(512), _: [], h: new i(32), $: [], w: new i(32768), C: [], v: [], d: new i(32768), D: [], u: new i(512), Q: [], r: new i(32768), s: new t(286), Y: new t(30), a: new t(19), t: new t(15e3), k: new i(65536), g: new i(32768) };
  }(), function() {
    for (var i = e.H.m, t = 32768, r = 0; r < t; r++) {
      var n = r;
      n = (n & 2863311530) >>> 1 | (n & 1431655765) << 1, n = (n & 3435973836) >>> 2 | (n & 858993459) << 2, n = (n & 4042322160) >>> 4 | (n & 252645135) << 4, n = (n & 4278255360) >>> 8 | (n & 16711935) << 8, i.r[r] = (n >>> 16 | n << 16) >>> 17;
    }
    function a(s, o, h) {
      for (; o-- != 0; ) s.push(0, h);
    }
    for (var r = 0; r < 32; r++)
      i.q[r] = i.S[r] << 3 | i.T[r], i.c[r] = i.p[r] << 4 | i.z[r];
    a(i._, 144, 8), a(i._, 112, 9), a(i._, 24, 7), a(i._, 8, 8), e.H.n(i._, 9), e.H.A(i._, 9, i.J), e.H.l(i._, 9), a(i.$, 32, 5), e.H.n(i.$, 5), e.H.A(i.$, 5, i.h), e.H.l(i.$, 5), a(i.Q, 19, 0), a(i.C, 286, 0), a(i.D, 30, 0), a(i.v, 320, 0);
  }(), e.H.N;
}();
UPNG.decode._readInterlace = function(e, i) {
  for (var t = i.width, r = i.height, n = UPNG.decode._getBPP(i), a = n >> 3, s = Math.ceil(t * n / 8), o = new Uint8Array(r * s), h = 0, l = [0, 0, 4, 0, 2, 0, 1], f = [0, 4, 0, 2, 0, 1, 0], b = [8, 8, 8, 4, 4, 2, 2], w = [8, 8, 4, 4, 2, 2, 1], g = 0; g < 7; ) {
    for (var E = b[g], k = w[g], A = 0, T = 0, C = l[g]; C < r; )
      C += E, T++;
    for (var D = f[g]; D < t; )
      D += k, A++;
    var $ = Math.ceil(A * n / 8);
    UPNG.decode._filterZero(e, i, h, A, T);
    for (var P = 0, z = l[g]; z < r; ) {
      for (var B = f[g], F = h + P * $ << 3; B < t; ) {
        if (n == 1) {
          var O = e[F >> 3];
          O = O >> 7 - (F & 7) & 1, o[z * s + (B >> 3)] |= O << 7 - ((B & 7) << 0);
        }
        if (n == 2) {
          var O = e[F >> 3];
          O = O >> 6 - (F & 7) & 3, o[z * s + (B >> 2)] |= O << 6 - ((B & 3) << 1);
        }
        if (n == 4) {
          var O = e[F >> 3];
          O = O >> 4 - (F & 7) & 15, o[z * s + (B >> 1)] |= O << 4 - ((B & 1) << 2);
        }
        if (n >= 8)
          for (var N = z * s + B * a, G = 0; G < a; G++) o[N + G] = e[(F >> 3) + G];
        F += n, B += k;
      }
      P++, z += E;
    }
    A * T != 0 && (h += T * (1 + $)), g = g + 1;
  }
  return o;
};
UPNG.decode._getBPP = function(e) {
  var i = [1, null, 3, 1, 2, null, 4][e.ctype];
  return i * e.depth;
};
UPNG.decode._filterZero = function(e, i, t, r, n) {
  var a = UPNG.decode._getBPP(i), s = Math.ceil(r * a / 8), o = UPNG.decode._paeth;
  a = Math.ceil(a / 8);
  var h = 0, l = 1, f = e[t], b = 0;
  if (f > 1 && (e[t] = [0, 0, 1][f - 2]), f == 3) for (b = a; b < s; b++) e[b + 1] = e[b + 1] + (e[b + 1 - a] >>> 1) & 255;
  for (var w = 0; w < n; w++)
    if (h = t + w * s, l = h + w + 1, f = e[l - 1], b = 0, f == 0) for (; b < s; b++) e[h + b] = e[l + b];
    else if (f == 1) {
      for (; b < a; b++) e[h + b] = e[l + b];
      for (; b < s; b++) e[h + b] = e[l + b] + e[h + b - a];
    } else if (f == 2)
      for (; b < s; b++) e[h + b] = e[l + b] + e[h + b - s];
    else if (f == 3) {
      for (; b < a; b++) e[h + b] = e[l + b] + (e[h + b - s] >>> 1);
      for (; b < s; b++) e[h + b] = e[l + b] + (e[h + b - s] + e[h + b - a] >>> 1);
    } else {
      for (; b < a; b++) e[h + b] = e[l + b] + o(0, e[h + b - s], 0);
      for (; b < s; b++) e[h + b] = e[l + b] + o(e[h + b - a], e[h + b - s], e[h + b - a - s]);
    }
  return e;
};
UPNG.decode._paeth = function(e, i, t) {
  var r = e + i - t, n = r - e, a = r - i, s = r - t;
  return n * n <= a * a && n * n <= s * s ? e : a * a <= s * s ? i : t;
};
UPNG.decode._IHDR = function(e, i, t) {
  var r = UPNG._bin;
  t.width = r.readUint(e, i), i += 4, t.height = r.readUint(e, i), i += 4, t.depth = e[i], i++, t.ctype = e[i], i++, t.compress = e[i], i++, t.filter = e[i], i++, t.interlace = e[i], i++;
};
UPNG._bin = {
  nextZero: function(e, i) {
    for (; e[i] != 0; ) i++;
    return i;
  },
  readUshort: function(e, i) {
    return e[i] << 8 | e[i + 1];
  },
  writeUshort: function(e, i, t) {
    e[i] = t >> 8 & 255, e[i + 1] = t & 255;
  },
  readUint: function(e, i) {
    return e[i] * (256 * 256 * 256) + (e[i + 1] << 16 | e[i + 2] << 8 | e[i + 3]);
  },
  writeUint: function(e, i, t) {
    e[i] = t >> 24 & 255, e[i + 1] = t >> 16 & 255, e[i + 2] = t >> 8 & 255, e[i + 3] = t & 255;
  },
  readASCII: function(e, i, t) {
    for (var r = "", n = 0; n < t; n++) r += String.fromCharCode(e[i + n]);
    return r;
  },
  writeASCII: function(e, i, t) {
    for (var r = 0; r < t.length; r++) e[i + r] = t.charCodeAt(r);
  },
  readBytes: function(e, i, t) {
    for (var r = [], n = 0; n < t; n++) r.push(e[i + n]);
    return r;
  },
  pad: function(e) {
    return e.length < 2 ? "0" + e : e;
  },
  readUTF8: function(e, i, t) {
    for (var r = "", n, a = 0; a < t; a++) r += "%" + UPNG._bin.pad(e[i + a].toString(16));
    try {
      n = decodeURIComponent(r);
    } catch {
      return UPNG._bin.readASCII(e, i, t);
    }
    return n;
  }
};
UPNG._copyTile = function(e, i, t, r, n, a, s, o, h) {
  for (var l = Math.min(i, n), f = Math.min(t, a), b = 0, w = 0, g = 0; g < f; g++)
    for (var E = 0; E < l; E++)
      if (s >= 0 && o >= 0 ? (b = g * i + E << 2, w = (o + g) * n + s + E << 2) : (b = (-o + g) * i - s + E << 2, w = g * n + E << 2), h == 0)
        r[w] = e[b], r[w + 1] = e[b + 1], r[w + 2] = e[b + 2], r[w + 3] = e[b + 3];
      else if (h == 1) {
        var k = e[b + 3] * 0.00392156862745098, A = e[b] * k, T = e[b + 1] * k, C = e[b + 2] * k, D = r[w + 3] * (1 / 255), $ = r[w] * D, P = r[w + 1] * D, z = r[w + 2] * D, B = 1 - k, F = k + D * B, O = F == 0 ? 0 : 1 / F;
        r[w + 3] = 255 * F, r[w + 0] = (A + $ * B) * O, r[w + 1] = (T + P * B) * O, r[w + 2] = (C + z * B) * O;
      } else if (h == 2) {
        var k = e[b + 3], A = e[b], T = e[b + 1], C = e[b + 2], D = r[w + 3], $ = r[w], P = r[w + 1], z = r[w + 2];
        k == D && A == $ && T == P && C == z ? (r[w] = 0, r[w + 1] = 0, r[w + 2] = 0, r[w + 3] = 0) : (r[w] = A, r[w + 1] = T, r[w + 2] = C, r[w + 3] = k);
      } else if (h == 3) {
        var k = e[b + 3], A = e[b], T = e[b + 1], C = e[b + 2], D = r[w + 3], $ = r[w], P = r[w + 1], z = r[w + 2];
        if (k == D && A == $ && T == P && C == z) continue;
        if (k < 220 && D > 20) return !1;
      }
  return !0;
};
UPNG.encode = function(e, i, t, r, n, a, s) {
  r == null && (r = 0), s == null && (s = !1);
  var o = UPNG.encode.compress(e, i, t, r, [!1, !1, !1, 0, s]);
  return UPNG.encode.compressPNG(o, -1), UPNG.encode._main(o, i, t, n, a);
};
UPNG.encodeLL = function(e, i, t, r, n, a, s, o) {
  for (var h = { ctype: 0 + (r == 1 ? 0 : 2) + (n == 0 ? 0 : 4), depth: a, frames: [] }, l = (r + n) * a, f = l * i, b = 0; b < e.length; b++)
    h.frames.push({ rect: { x: 0, y: 0, width: i, height: t }, img: new Uint8Array(e[b]), blend: 0, dispose: 1, bpp: Math.ceil(l / 8), bpl: Math.ceil(f / 8) });
  UPNG.encode.compressPNG(h, 0, !0);
  var w = UPNG.encode._main(h, i, t, s, o);
  return w;
};
UPNG.encode._main = function(e, i, t, r, n) {
  n == null && (n = {});
  var a = UPNG.crc.crc, s = UPNG._bin.writeUint, o = UPNG._bin.writeUshort, h = UPNG._bin.writeASCII, l = 8, f = e.frames.length > 1, b = !1, w = 33 + (f ? 20 : 0);
  if (n.sRGB != null && (w += 13), n.pHYs != null && (w += 21), e.ctype == 3) {
    for (var g = e.plte.length, E = 0; E < g; E++) e.plte[E] >>> 24 != 255 && (b = !0);
    w += 8 + g * 3 + 4 + (b ? 8 + g * 1 + 4 : 0);
  }
  for (var k = 0; k < e.frames.length; k++) {
    var A = e.frames[k];
    f && (w += 38), w += A.cimg.length + 12, k != 0 && (w += 4);
  }
  w += 12;
  for (var T = new Uint8Array(w), C = [137, 80, 78, 71, 13, 10, 26, 10], E = 0; E < 8; E++) T[E] = C[E];
  if (s(T, l, 13), l += 4, h(T, l, "IHDR"), l += 4, s(T, l, i), l += 4, s(T, l, t), l += 4, T[l] = e.depth, l++, T[l] = e.ctype, l++, T[l] = 0, l++, T[l] = 0, l++, T[l] = 0, l++, s(T, l, a(T, l - 17, 17)), l += 4, n.sRGB != null && (s(T, l, 1), l += 4, h(T, l, "sRGB"), l += 4, T[l] = n.sRGB, l++, s(T, l, a(T, l - 5, 5)), l += 4), n.pHYs != null && (s(T, l, 9), l += 4, h(T, l, "pHYs"), l += 4, s(T, l, n.pHYs[0]), l += 4, s(T, l, n.pHYs[1]), l += 4, T[l] = n.pHYs[2], l++, s(T, l, a(T, l - 13, 13)), l += 4), f && (s(T, l, 8), l += 4, h(T, l, "acTL"), l += 4, s(T, l, e.frames.length), l += 4, s(T, l, n.loop != null ? n.loop : 0), l += 4, s(T, l, a(T, l - 12, 12)), l += 4), e.ctype == 3) {
    var g = e.plte.length;
    s(T, l, g * 3), l += 4, h(T, l, "PLTE"), l += 4;
    for (var E = 0; E < g; E++) {
      var D = E * 3, $ = e.plte[E], P = $ & 255, z = $ >>> 8 & 255, B = $ >>> 16 & 255;
      T[l + D + 0] = P, T[l + D + 1] = z, T[l + D + 2] = B;
    }
    if (l += g * 3, s(T, l, a(T, l - g * 3 - 4, g * 3 + 4)), l += 4, b) {
      s(T, l, g), l += 4, h(T, l, "tRNS"), l += 4;
      for (var E = 0; E < g; E++) T[l + E] = e.plte[E] >>> 24 & 255;
      l += g, s(T, l, a(T, l - g - 4, g + 4)), l += 4;
    }
  }
  for (var F = 0, k = 0; k < e.frames.length; k++) {
    var A = e.frames[k];
    f && (s(T, l, 26), l += 4, h(T, l, "fcTL"), l += 4, s(T, l, F++), l += 4, s(T, l, A.rect.width), l += 4, s(T, l, A.rect.height), l += 4, s(T, l, A.rect.x), l += 4, s(T, l, A.rect.y), l += 4, o(T, l, r[k]), l += 2, o(T, l, 1e3), l += 2, T[l] = A.dispose, l++, T[l] = A.blend, l++, s(T, l, a(T, l - 30, 30)), l += 4);
    var O = A.cimg, g = O.length;
    s(T, l, g + (k == 0 ? 0 : 4)), l += 4;
    var N = l;
    h(T, l, k == 0 ? "IDAT" : "fdAT"), l += 4, k != 0 && (s(T, l, F++), l += 4), T.set(O, l), l += g, s(T, l, a(T, N, l - N)), l += 4;
  }
  return s(T, l, 0), l += 4, h(T, l, "IEND"), l += 4, s(T, l, a(T, l - 4, 4)), l += 4, T.buffer;
};
UPNG.encode.compressPNG = function(e, i, t) {
  for (var r = 0; r < e.frames.length; r++) {
    var n = e.frames[r];
    n.rect.width;
    var a = n.rect.height, s = new Uint8Array(a * n.bpl + a);
    n.cimg = UPNG.encode._filterZero(n.img, a, n.bpp, n.bpl, s, i, t);
  }
};
UPNG.encode.compress = function(e, i, t, r, n) {
  for (var a = n[0], s = n[1], o = n[2], h = n[3], l = n[4], f = 6, b = 8, w = 255, g = 0; g < e.length; g++)
    for (var E = new Uint8Array(e[g]), k = E.length, A = 0; A < k; A += 4) w &= E[A + 3];
  var T = w != 255, C = UPNG.encode.framize(e, i, t, a, s, o), D = {}, $ = [], P = [];
  if (r != 0) {
    for (var z = [], A = 0; A < C.length; A++) z.push(C[A].img.buffer);
    for (var B = UPNG.encode.concatRGBA(z), F = UPNG.quantize(B, r), O = 0, N = new Uint8Array(F.abuf), A = 0; A < C.length; A++) {
      var G = C[A].img, V = G.length;
      P.push(new Uint8Array(F.inds.buffer, O >> 2, V >> 2));
      for (var g = 0; g < V; g += 4)
        G[g] = N[O + g], G[g + 1] = N[O + g + 1], G[g + 2] = N[O + g + 2], G[g + 3] = N[O + g + 3];
      O += V;
    }
    for (var A = 0; A < F.plte.length; A++) $.push(F.plte[A].est.rgba);
  } else
    for (var g = 0; g < C.length; g++) {
      var J = C[g], Q = new Uint32Array(J.img.buffer), W = J.rect.width, k = Q.length, ne = new Uint8Array(k);
      P.push(ne);
      for (var A = 0; A < k; A++) {
        var pe = Q[A];
        if (A != 0 && pe == Q[A - 1]) ne[A] = ne[A - 1];
        else if (A > W && pe == Q[A - W]) ne[A] = ne[A - W];
        else {
          var be = D[pe];
          if (be == null && (D[pe] = be = $.length, $.push(pe), $.length >= 300))
            break;
          ne[A] = be;
        }
      }
    }
  var ve = $.length;
  ve <= 256 && l == !1 && (ve <= 2 ? b = 1 : ve <= 4 ? b = 2 : ve <= 16 ? b = 4 : b = 8, b = Math.max(b, h));
  for (var g = 0; g < C.length; g++) {
    var J = C[g];
    J.rect.x, J.rect.y;
    var W = J.rect.width, Ee = J.rect.height, Ae = J.img;
    new Uint32Array(Ae.buffer);
    var _e = 4 * W, Be = 4;
    if (ve <= 256 && l == !1) {
      _e = Math.ceil(b * W / 8);
      for (var Me = new Uint8Array(_e * Ee), re = P[g], Te = 0; Te < Ee; Te++) {
        var A = Te * _e, Fe = Te * W;
        if (b == 8) for (var Se = 0; Se < W; Se++) Me[A + Se] = re[Fe + Se];
        else if (b == 4) for (var Se = 0; Se < W; Se++) Me[A + (Se >> 1)] |= re[Fe + Se] << 4 - (Se & 1) * 4;
        else if (b == 2) for (var Se = 0; Se < W; Se++) Me[A + (Se >> 2)] |= re[Fe + Se] << 6 - (Se & 3) * 2;
        else if (b == 1) for (var Se = 0; Se < W; Se++) Me[A + (Se >> 3)] |= re[Fe + Se] << 7 - (Se & 7) * 1;
      }
      Ae = Me, f = 3, Be = 1;
    } else if (T == !1 && C.length == 1) {
      for (var Me = new Uint8Array(W * Ee * 3), Ye = W * Ee, A = 0; A < Ye; A++) {
        var G = A * 3, Je = A * 4;
        Me[G] = Ae[Je], Me[G + 1] = Ae[Je + 1], Me[G + 2] = Ae[Je + 2];
      }
      Ae = Me, f = 2, Be = 3, _e = 3 * W;
    }
    J.img = Ae, J.bpl = _e, J.bpp = Be;
  }
  return { ctype: f, depth: b, plte: $, frames: C };
};
UPNG.encode.framize = function(e, i, t, r, n, a) {
  for (var s = [], o = 0; o < e.length; o++) {
    var h = new Uint8Array(e[o]), l = new Uint32Array(h.buffer), f, b = 0, w = 0, g = i, E = t, k = r ? 1 : 0;
    if (o != 0) {
      for (var A = a || r || o == 1 || s[o - 2].dispose != 0 ? 1 : 2, T = 0, C = 1e9, D = 0; D < A; D++) {
        for (var J = new Uint8Array(e[o - 1 - D]), $ = new Uint32Array(e[o - 1 - D]), P = i, z = t, B = -1, F = -1, O = 0; O < t; O++) for (var N = 0; N < i; N++) {
          var G = O * i + N;
          l[G] != $[G] && (N < P && (P = N), N > B && (B = N), O < z && (z = O), O > F && (F = O));
        }
        B == -1 && (P = z = B = F = 0), n && ((P & 1) == 1 && P--, (z & 1) == 1 && z--);
        var V = (B - P + 1) * (F - z + 1);
        V < C && (C = V, T = D, b = P, w = z, g = B - P + 1, E = F - z + 1);
      }
      var J = new Uint8Array(e[o - 1 - T]);
      T == 1 && (s[o - 1].dispose = 2), f = new Uint8Array(g * E * 4), UPNG._copyTile(J, i, t, f, g, E, -b, -w, 0), k = UPNG._copyTile(h, i, t, f, g, E, -b, -w, 3) ? 1 : 0, k == 1 ? UPNG.encode._prepareDiff(h, i, t, f, { x: b, y: w, width: g, height: E }) : UPNG._copyTile(h, i, t, f, g, E, -b, -w, 0);
    } else f = h.slice(0);
    s.push({ rect: { x: b, y: w, width: g, height: E }, img: f, blend: k, dispose: 0 });
  }
  if (r) for (var o = 0; o < s.length; o++) {
    var Q = s[o];
    if (Q.blend != 1) {
      var W = Q.rect, ne = s[o - 1].rect, pe = Math.min(W.x, ne.x), be = Math.min(W.y, ne.y), ve = Math.max(W.x + W.width, ne.x + ne.width), Ee = Math.max(W.y + W.height, ne.y + ne.height), Ae = { x: pe, y: be, width: ve - pe, height: Ee - be };
      s[o - 1].dispose = 1, o - 1 != 0 && UPNG.encode._updateFrame(e, i, t, s, o - 1, Ae, n), UPNG.encode._updateFrame(e, i, t, s, o, Ae, n);
    }
  }
  var _e = 0;
  if (e.length != 1) for (var G = 0; G < s.length; G++) {
    var Q = s[G];
    _e += Q.rect.width * Q.rect.height;
  }
  return s;
};
UPNG.encode._updateFrame = function(e, i, t, r, n, a, s) {
  for (var o = Uint8Array, h = Uint32Array, l = new o(e[n - 1]), f = new h(e[n - 1]), b = n + 1 < e.length ? new o(e[n + 1]) : null, w = new o(e[n]), g = new h(w.buffer), E = i, k = t, A = -1, T = -1, C = 0; C < a.height; C++) for (var D = 0; D < a.width; D++) {
    var $ = a.x + D, P = a.y + C, z = P * i + $, B = g[z];
    B == 0 || r[n - 1].dispose == 0 && f[z] == B && (b == null || b[z * 4 + 3] != 0) || ($ < E && (E = $), $ > A && (A = $), P < k && (k = P), P > T && (T = P));
  }
  A == -1 && (E = k = A = T = 0), s && ((E & 1) == 1 && E--, (k & 1) == 1 && k--), a = { x: E, y: k, width: A - E + 1, height: T - k + 1 };
  var F = r[n];
  F.rect = a, F.blend = 1, F.img = new Uint8Array(a.width * a.height * 4), r[n - 1].dispose == 0 ? (UPNG._copyTile(l, i, t, F.img, a.width, a.height, -a.x, -a.y, 0), UPNG.encode._prepareDiff(w, i, t, F.img, a)) : UPNG._copyTile(w, i, t, F.img, a.width, a.height, -a.x, -a.y, 0);
};
UPNG.encode._prepareDiff = function(e, i, t, r, n) {
  UPNG._copyTile(e, i, t, r, n.width, n.height, -n.x, -n.y, 2);
};
UPNG.encode._filterZero = function(e, i, t, r, n, a, s) {
  var o = [], h = [0, 1, 2, 3, 4];
  a != -1 ? h = [a] : (i * r > 5e5 || t == 1) && (h = [0]);
  var l;
  s && (l = { level: 0 });
  for (var f = s && UZIP != null ? UZIP : pako, b = 0; b < h.length; b++) {
    for (var w = 0; w < i; w++) UPNG.encode._filterLine(n, e, w, r, t, h[b]);
    o.push(f.deflate(n, l));
  }
  for (var g, E = 1e9, b = 0; b < o.length; b++) o[b].length < E && (g = b, E = o[b].length);
  return o[g];
};
UPNG.encode._filterLine = function(e, i, t, r, n, a) {
  var s = t * r, o = s + t, h = UPNG.decode._paeth;
  if (e[o] = a, o++, a == 0)
    if (r < 500) for (var l = 0; l < r; l++) e[o + l] = i[s + l];
    else e.set(new Uint8Array(i.buffer, s, r), o);
  else if (a == 1) {
    for (var l = 0; l < n; l++) e[o + l] = i[s + l];
    for (var l = n; l < r; l++) e[o + l] = i[s + l] - i[s + l - n] + 256 & 255;
  } else if (t == 0) {
    for (var l = 0; l < n; l++) e[o + l] = i[s + l];
    if (a == 2) for (var l = n; l < r; l++) e[o + l] = i[s + l];
    if (a == 3) for (var l = n; l < r; l++) e[o + l] = i[s + l] - (i[s + l - n] >> 1) + 256 & 255;
    if (a == 4) for (var l = n; l < r; l++) e[o + l] = i[s + l] - h(i[s + l - n], 0, 0) + 256 & 255;
  } else {
    if (a == 2)
      for (var l = 0; l < r; l++) e[o + l] = i[s + l] + 256 - i[s + l - r] & 255;
    if (a == 3) {
      for (var l = 0; l < n; l++) e[o + l] = i[s + l] + 256 - (i[s + l - r] >> 1) & 255;
      for (var l = n; l < r; l++) e[o + l] = i[s + l] + 256 - (i[s + l - r] + i[s + l - n] >> 1) & 255;
    }
    if (a == 4) {
      for (var l = 0; l < n; l++) e[o + l] = i[s + l] + 256 - h(0, i[s + l - r], 0) & 255;
      for (var l = n; l < r; l++) e[o + l] = i[s + l] + 256 - h(i[s + l - n], i[s + l - r], i[s + l - n - r]) & 255;
    }
  }
};
UPNG.crc = {
  table: function() {
    for (var e = new Uint32Array(256), i = 0; i < 256; i++) {
      for (var t = i, r = 0; r < 8; r++)
        t & 1 ? t = 3988292384 ^ t >>> 1 : t = t >>> 1;
      e[i] = t;
    }
    return e;
  }(),
  update: function(e, i, t, r) {
    for (var n = 0; n < r; n++) e = UPNG.crc.table[(e ^ i[t + n]) & 255] ^ e >>> 8;
    return e;
  },
  crc: function(e, i, t) {
    return UPNG.crc.update(4294967295, e, i, t) ^ 4294967295;
  }
};
UPNG.quantize = function(e, i) {
  var t = new Uint8Array(e), r = t.slice(0), n = new Uint32Array(r.buffer), a = UPNG.quantize.getKDtree(r, i), s = a[0], o = a[1];
  UPNG.quantize.planeDst;
  for (var h = t, l = n, f = h.length, b = new Uint8Array(t.length >> 2), w = 0; w < f; w += 4) {
    var g = h[w] * 0.00392156862745098, E = h[w + 1] * (1 / 255), k = h[w + 2] * (1 / 255), A = h[w + 3] * (1 / 255), T = UPNG.quantize.getNearest(s, g, E, k, A);
    b[w >> 2] = T.ind, l[w >> 2] = T.est.rgba;
  }
  return { abuf: r.buffer, inds: b, plte: o };
};
UPNG.quantize.getKDtree = function(e, i, t) {
  t == null && (t = 1e-4);
  var r = new Uint32Array(e.buffer), n = { i0: 0, i1: e.length, bst: null, est: null, tdst: 0, left: null, right: null };
  n.bst = UPNG.quantize.stats(e, n.i0, n.i1), n.est = UPNG.quantize.estats(n.bst);
  for (var a = [n]; a.length < i; ) {
    for (var s = 0, o = 0, h = 0; h < a.length; h++) a[h].est.L > s && (s = a[h].est.L, o = h);
    if (s < t) break;
    var l = a[o], f = UPNG.quantize.splitPixels(e, r, l.i0, l.i1, l.est.e, l.est.eMq255), b = l.i0 >= f || l.i1 <= f;
    if (b) {
      l.est.L = 0;
      continue;
    }
    var w = { i0: l.i0, i1: f, bst: null, est: null, tdst: 0, left: null, right: null };
    w.bst = UPNG.quantize.stats(e, w.i0, w.i1), w.est = UPNG.quantize.estats(w.bst);
    var g = { i0: f, i1: l.i1, bst: null, est: null, tdst: 0, left: null, right: null };
    g.bst = { R: [], m: [], N: l.bst.N - w.bst.N };
    for (var h = 0; h < 16; h++) g.bst.R[h] = l.bst.R[h] - w.bst.R[h];
    for (var h = 0; h < 4; h++) g.bst.m[h] = l.bst.m[h] - w.bst.m[h];
    g.est = UPNG.quantize.estats(g.bst), l.left = w, l.right = g, a[o] = w, a.push(g);
  }
  a.sort(function(E, k) {
    return k.bst.N - E.bst.N;
  });
  for (var h = 0; h < a.length; h++) a[h].ind = h;
  return [n, a];
};
UPNG.quantize.getNearest = function(e, i, t, r, n) {
  if (e.left == null)
    return e.tdst = UPNG.quantize.dist(e.est.q, i, t, r, n), e;
  var a = UPNG.quantize.planeDst(e.est, i, t, r, n), s = e.left, o = e.right;
  a > 0 && (s = e.right, o = e.left);
  var h = UPNG.quantize.getNearest(s, i, t, r, n);
  if (h.tdst <= a * a) return h;
  var l = UPNG.quantize.getNearest(o, i, t, r, n);
  return l.tdst < h.tdst ? l : h;
};
UPNG.quantize.planeDst = function(e, i, t, r, n) {
  var a = e.e;
  return a[0] * i + a[1] * t + a[2] * r + a[3] * n - e.eMq;
};
UPNG.quantize.dist = function(e, i, t, r, n) {
  var a = i - e[0], s = t - e[1], o = r - e[2], h = n - e[3];
  return a * a + s * s + o * o + h * h;
};
UPNG.quantize.splitPixels = function(e, i, t, r, n, a) {
  var s = UPNG.quantize.vecDot;
  for (r -= 4; t < r; ) {
    for (; s(e, t, n) <= a; ) t += 4;
    for (; s(e, r, n) > a; ) r -= 4;
    if (t >= r) break;
    var o = i[t >> 2];
    i[t >> 2] = i[r >> 2], i[r >> 2] = o, t += 4, r -= 4;
  }
  for (; s(e, t, n) > a; ) t -= 4;
  return t + 4;
};
UPNG.quantize.vecDot = function(e, i, t) {
  return e[i] * t[0] + e[i + 1] * t[1] + e[i + 2] * t[2] + e[i + 3] * t[3];
};
UPNG.quantize.stats = function(e, i, t) {
  for (var r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], n = [0, 0, 0, 0], a = t - i >> 2, s = i; s < t; s += 4) {
    var o = e[s] * 0.00392156862745098, h = e[s + 1] * (1 / 255), l = e[s + 2] * (1 / 255), f = e[s + 3] * (1 / 255);
    n[0] += o, n[1] += h, n[2] += l, n[3] += f, r[0] += o * o, r[1] += o * h, r[2] += o * l, r[3] += o * f, r[5] += h * h, r[6] += h * l, r[7] += h * f, r[10] += l * l, r[11] += l * f, r[15] += f * f;
  }
  return r[4] = r[1], r[8] = r[2], r[9] = r[6], r[12] = r[3], r[13] = r[7], r[14] = r[11], { R: r, m: n, N: a };
};
UPNG.quantize.estats = function(e) {
  var i = e.R, t = e.m, r = e.N, n = t[0], a = t[1], s = t[2], o = t[3], h = r == 0 ? 0 : 1 / r, l = [
    i[0] - n * n * h,
    i[1] - n * a * h,
    i[2] - n * s * h,
    i[3] - n * o * h,
    i[4] - a * n * h,
    i[5] - a * a * h,
    i[6] - a * s * h,
    i[7] - a * o * h,
    i[8] - s * n * h,
    i[9] - s * a * h,
    i[10] - s * s * h,
    i[11] - s * o * h,
    i[12] - o * n * h,
    i[13] - o * a * h,
    i[14] - o * s * h,
    i[15] - o * o * h
  ], f = l, b = UPNG.M4, w = [0.5, 0.5, 0.5, 0.5], g = 0, E = 0;
  if (r != 0)
    for (var k = 0; k < 10 && (w = b.multVec(f, w), E = Math.sqrt(b.dot(w, w)), w = b.sml(1 / E, w), !(Math.abs(E - g) < 1e-9)); k++)
      g = E;
  var A = [n * h, a * h, s * h, o * h], T = b.dot(b.sml(255, A), w);
  return {
    Cov: l,
    q: A,
    e: w,
    L: g,
    eMq255: T,
    eMq: b.dot(w, A),
    rgba: (Math.round(255 * A[3]) << 24 | Math.round(255 * A[2]) << 16 | Math.round(255 * A[1]) << 8 | Math.round(255 * A[0]) << 0) >>> 0
  };
};
UPNG.M4 = {
  multVec: function(e, i) {
    return [
      e[0] * i[0] + e[1] * i[1] + e[2] * i[2] + e[3] * i[3],
      e[4] * i[0] + e[5] * i[1] + e[6] * i[2] + e[7] * i[3],
      e[8] * i[0] + e[9] * i[1] + e[10] * i[2] + e[11] * i[3],
      e[12] * i[0] + e[13] * i[1] + e[14] * i[2] + e[15] * i[3]
    ];
  },
  dot: function(e, i) {
    return e[0] * i[0] + e[1] * i[1] + e[2] * i[2] + e[3] * i[3];
  },
  sml: function(e, i) {
    return [e * i[0], e * i[1], e * i[2], e * i[3]];
  }
};
UPNG.encode.concatRGBA = function(e) {
  for (var i = 0, t = 0; t < e.length; t++) i += e[t].byteLength;
  for (var r = new Uint8Array(i), n = 0, t = 0; t < e.length; t++) {
    for (var a = new Uint8Array(e[t]), s = a.length, o = 0; o < s; o += 4) {
      var h = a[o], l = a[o + 1], f = a[o + 2], b = a[o + 3];
      b == 0 && (h = l = f = 0), r[n + o] = h, r[n + o + 1] = l, r[n + o + 2] = f, r[n + o + 3] = b;
    }
    n += s;
  }
  return r.buffer;
};
class TxSprite {
  constructor(i, t, r, n, a, s = !1) {
    $e(this, "width");
    $e(this, "height");
    $e(this, "numColors");
    $e(this, "paletteData");
    $e(this, "pixelData");
    $e(this, "compress");
    this.width = i, this.height = t, this.numColors = r, this.paletteData = n, this.pixelData = a, this.compress = s, n.length / 3 !== r && r > 0 && console.warn(`TxSprite constructor: numColors (${r}) does not match paletteData length (${n.length / 3} colors).`), a.length !== i * t && i * t > 0 && console.warn(`TxSprite constructor: pixelData length (${a.length}) does not match width*height (${i * t}).`);
  }
  /**
   * Creates a TxSprite from an indexed PNG image.
   * @param imageBytes The ArrayBuffer containing the PNG image data.
   * @param compress Whether to compress the pixel data using LZ4.
   * @returns A TxSprite instance.
   */
  static async fromIndexedPngBytes(i, t = !1) {
    const r = UPNG.decode(i), { width: n, height: a, data: s, ctype: o, tabs: h } = r;
    return console.log(`PNG dimensions: ${n}x${a}, data length: ${s.byteLength}, ctype: ${o}, PLTE: ${h.PLTE}`), new TxSprite(
      n,
      a,
      h.PLTE ? h.PLTE.length / 3 : 0,
      // Number of colors in the palette
      h.PLTE ? new Uint8Array(h.PLTE) : new Uint8Array(),
      // Palette data
      new Uint8Array(s.slice(0, n * a)),
      // Pixel data (palette indices)
      t
    );
  }
  /**
   * Creates a TxSprite from an image file, resizing and quantizing it to a maximum of 16 colors.
   * @param imageBytes The ArrayBuffer containing the image data.
   * @param maxPixels The maximum number of pixels allowed in the sprite.
   * @param compress Whether to compress the pixel data using LZ4.
   * @returns A TxSprite instance.
   */
  static async fromImageBytes(i, t = 48e3, r = !1) {
    let n = await Image.load(i), a = n.width * n.height;
    if (a > t) {
      const w = Math.sqrt(t / a);
      n = n.resize({
        factor: w
        //interpolation: 'bicubic' // PIL's LANCZOS equivalent: 'bicubic' or 'bilinear'
      });
    }
    (n.width > 640 || n.height > 400) && (n = n.resize({
      width: 640,
      height: 400,
      preserveAspectRatio: !0,
      interpolation: "nearestNeighbor"
      // PIL's NEAREST
    })), console.log(`Resized image to ${n.width}x${n.height}`);
    const s = utils_exports.PointContainer.fromUint8Array(n.getRGBAData(), n.width, n.height);
    console.log(`PointContainer created with ${s.getPointArray().length} points.`);
    const o = buildPaletteSync([s], { colors: 15 });
    console.log(`Palette built: ${o.getPointContainer().getPointArray().length} colors.`), o.getPointContainer().getPointArray().unshift(utils_exports.Point.createByQuadruplet([0, 0, 0, 0]));
    const h = applyPaletteSync(s, o);
    console.log(`OutPointContainer: ${h.getPointArray().length} points.`);
    const l = new Uint8Array(h.toUint32Array());
    console.log(`Indexed pixel data size: ${l.length}.`);
    const f = o.getPointContainer().getPointArray().length, b = new Uint8Array(f * 3);
    return o.getPointContainer().getPointArray().forEach((w, g) => {
      b[g * 3 + 0] = w.r, b[g * 3 + 1] = w.g, b[g * 3 + 2] = w.b, console.log(`Color ${g}: R=${w.r}, G=${w.g}, B=${w.b}`);
    }), new TxSprite(
      n.width,
      n.height,
      f,
      b,
      l,
      r
    );
  }
  get bpp() {
    return this.numColors <= 0 ? 4 : this.numColors <= 2 ? 1 : this.numColors <= 4 ? 2 : (this.numColors <= 16 || console.warn(`numColors (${this.numColors}) is greater than 16. Defaulting BPP to 4.`), 4);
  }
  pack() {
    let i;
    const t = this.bpp;
    switch (t) {
      case 1:
        i = TxSprite._pack_1bit(this.pixelData);
        break;
      case 2:
        i = TxSprite._pack_2bit(this.pixelData);
        break;
      case 4:
        i = TxSprite._pack_4bit(this.pixelData);
        break;
      default:
        throw new Error(`Unsupported bpp: ${t}`);
    }
    const r = new Uint8Array(7), n = new DataView(r.buffer);
    n.setUint16(0, this.width, !1), n.setUint16(2, this.height, !1), n.setUint8(4, this.compress ? 1 : 0), n.setUint8(5, t), n.setUint8(6, this.numColors > 16 ? 16 : this.numColors);
    let a = i;
    if (this.compress)
      try {
        a = lz4.compress(Buffer.from(i), 9);
      } catch (o) {
        throw console.error("LZ4 compression failed:", o), o;
      }
    const s = new Uint8Array(r.length + this.paletteData.length + a.length);
    return s.set(r, 0), s.set(this.paletteData, r.length), s.set(a, r.length + this.paletteData.length), s;
  }
  static _pack_1bit(i) {
    const t = Math.ceil(i.length / 8), r = new Uint8Array(t);
    for (let n = 0; n < i.length; n++) {
      const a = Math.floor(n / 8), s = 7 - n % 8;
      i[n] & 1 && (r[a] |= 1 << s);
    }
    return r;
  }
  static _pack_2bit(i) {
    const t = Math.ceil(i.length / 4), r = new Uint8Array(t);
    for (let n = 0; n < i.length; n++) {
      const a = Math.floor(n / 4), s = (3 - n % 4) * 2;
      r[a] |= (i[n] & 3) << s;
    }
    return r;
  }
  static _pack_4bit(i) {
    const t = Math.ceil(i.length / 2), r = new Uint8Array(t);
    for (let n = 0; n < i.length; n++) {
      const a = Math.floor(n / 2), s = (1 - n % 2) * 4;
      r[a] |= (i[n] & 15) << s;
    }
    return r;
  }
}
class TxImageSpriteBlock {
  /**
   * @param image Source sprite to split
   * @param spriteLineHeight Height of each sprite strip. Default is 16.
   * @param progressiveRender Whether to render lines as they arrive. Default is true.
   * @param updatable Whether lines can be updated after initial render. Default is true.
   */
  constructor(i, t = 16, r = !0, n = !0) {
    /**
     * Source sprite to split.
     */
    $e(this, "image");
    /**
     * Height of each sprite strip. If the TxSprite is compressed, the strip has a packed size limit of 4kB and this value is ignored.
     */
    $e(this, "spriteLineHeight");
    /**
     * Whether to render lines as they arrive.
     */
    $e(this, "progressiveRender");
    /**
     * Whether lines can be updated after initial render.
     */
    $e(this, "updatable");
    /**
     * List of sprite strips.
     */
    $e(this, "spriteLines", []);
    if (this.image = i, this.progressiveRender = r, this.updatable = n, i.compress) {
      const a = i.bpp, s = a > 0 ? Math.floor((i.width + 8 / a - 1) / (8 / a)) : 0;
      this.spriteLineHeight = s > 0 ? Math.floor(4096 / s) : 0, this.spriteLineHeight === 0 && s > 0 ? this.spriteLineHeight = 1 : s === 0 && (this.spriteLineHeight = i.height);
    } else
      this.spriteLineHeight = t;
    this.image.height > 0 && this.spriteLineHeight < 1 && (this.spriteLineHeight = 1), this._splitIntoLines();
  }
  /**
   * Splits the source image into horizontal strips.
   * This method needs careful implementation based on how pixelData is structured
   * and how BPP affects its layout if it's not 1 byte per pixel index.
   * The current TxSprite.pixelData is Uint8Array of palette indices.
   */
  _splitIntoLines() {
    const i = this.image.pixelData, t = this.image.width;
    if (this.spriteLineHeight <= 0) {
      console.warn("TxImageSpriteBlock: spriteLineHeight is zero or negative, cannot split lines."), this.image.height > 0 && this.spriteLines.push(new TxSprite(
        this.image.width,
        this.image.height,
        this.image.numColors,
        this.image.paletteData,
        // Share palette data
        i,
        // Use the whole pixel data
        this.image.compress
      ));
      return;
    }
    const r = Math.floor(this.image.height / this.spriteLineHeight);
    for (let a = 0; a < r; a++) {
      const s = a * this.spriteLineHeight * t, o = s + this.spriteLineHeight * t, h = i.slice(s, o);
      this.spriteLines.push(new TxSprite(
        this.image.width,
        this.spriteLineHeight,
        this.image.numColors,
        this.image.paletteData,
        // Share palette data
        h,
        this.image.compress
      ));
    }
    const n = this.image.height % this.spriteLineHeight;
    if (n > 0) {
      const a = r * this.spriteLineHeight * t, s = i.slice(a);
      this.spriteLines.push(new TxSprite(
        this.image.width,
        n,
        this.image.numColors,
        this.image.paletteData,
        // Share palette data
        s,
        this.image.compress
      ));
    }
  }
  /**
   * Packs the image block header into a binary format.
   * @returns Uint8Array Binary representation of the header
   * @throws Error if there are no sprite lines to pack (though _splitIntoLines should always create at least one if height > 0 and spriteLineHeight > 0)
   */
  pack() {
    if (this.spriteLines.length === 0 && this.image.height > 0)
      if (console.warn("TxImageSpriteBlock pack: No sprite lines to pack, but image has height. This might indicate an issue in line splitting."), this.spriteLineHeight <= 0 && this.image.height > 0)
        console.warn("Attempting to pack header with image.height due to zero spriteLineHeight");
      else
        throw new Error("No sprite lines to pack");
    else this.spriteLines.length === 0 && this.image.height;
    const i = new Uint8Array(9), t = new DataView(i.buffer);
    let r = this.spriteLineHeight;
    return this.image.height > 0 && this.spriteLineHeight <= 0 && (this.spriteLines.length > 0 ? r = this.spriteLines[0].height : r = this.image.height), t.setUint8(0, 255), t.setUint16(1, this.image.width, !1), t.setUint16(3, this.image.height, !1), t.setUint16(5, r, !1), t.setUint8(7, this.progressiveRender ? 1 : 0), t.setUint8(8, this.updatable ? 1 : 0), i;
  }
}
class TxManualExpSettings {
  /**
   * @param manualShutter Shutter value (4-16383). Defaults to 3072.
   * @param manualAnalogGain Analog gain value (1-248). Defaults to 16.
   * @param manualRedGain Red gain value (0-1023). Defaults to 121.
   * @param manualGreenGain Green gain value (0-1023). Defaults to 64.
   * @param manualBlueGain Blue gain value (0-1023). Defaults to 140.
   */
  constructor(i = 3072, t = 16, r = 121, n = 64, a = 140) {
    /**
     * Shutter value (4-16383)
     */
    $e(this, "manualShutter");
    /**
     * Analog gain value (1-248)
     */
    $e(this, "manualAnalogGain");
    /**
     * Red gain value (0-1023)
     */
    $e(this, "manualRedGain");
    /**
     * Green gain value (0-1023)
     */
    $e(this, "manualGreenGain");
    /**
     * Blue gain value (0-1023)
     */
    $e(this, "manualBlueGain");
    this.manualShutter = i, this.manualAnalogGain = t, this.manualRedGain = r, this.manualGreenGain = n, this.manualBlueGain = a;
  }
  /**
   * Packs the settings into 9 bytes.
   * @returns Uint8Array Binary representation of the message (9 bytes)
   */
  pack() {
    const i = new ArrayBuffer(9), t = new DataView(i);
    return t.setUint16(0, this.manualShutter & 16383, !1), t.setUint8(2, this.manualAnalogGain & 255), t.setUint16(3, this.manualRedGain & 1023, !1), t.setUint16(5, this.manualGreenGain & 1023, !1), t.setUint16(7, this.manualBlueGain & 1023, !1), new Uint8Array(i);
  }
}
class TxAutoExpSettings {
  /**
   * @param meteringIndex Zero-based index into ['SPOT', 'CENTER_WEIGHTED', 'AVERAGE']. Defaults to 1.
   * @param exposure Target exposure value (0.0-1.0). Defaults to 0.1.
   * @param exposureSpeed Speed of exposure adjustments (0.0-1.0). Defaults to 0.45.
   * @param shutterLimit Maximum shutter value (4-16383). Defaults to 16383.
   * @param analogGainLimit Maximum analog gain value (1-248). Defaults to 16.
   * @param whiteBalanceSpeed Speed of white balance adjustments (0.0-1.0). Defaults to 0.5.
   * @param rgbGainLimit Maximum gain value for red, green, blue channels (0-1023). Defaults to 287.
   */
  constructor(i = 1, t = 0.1, r = 0.45, n = 16383, a = 16, s = 0.5, o = 287) {
    /**
     * Zero-based index into ['SPOT', 'CENTER_WEIGHTED', 'AVERAGE'] i.e. 0, 1 or 2.
     */
    $e(this, "meteringIndex");
    /**
     * Target exposure value (0.0-1.0)
     */
    $e(this, "exposure");
    /**
     * Speed of exposure adjustments (0.0-1.0)
     */
    $e(this, "exposureSpeed");
    /**
     * Maximum shutter value (4-16383)
     */
    $e(this, "shutterLimit");
    /**
     * Maximum analog gain value (1-248)
     */
    $e(this, "analogGainLimit");
    /**
     * Speed of white balance adjustments (0.0-1.0)
     */
    $e(this, "whiteBalanceSpeed");
    /**
     * Maximum gain value for red, green, blue channels (0-1023)
     */
    $e(this, "rgbGainLimit");
    this.meteringIndex = i, this.exposure = t, this.exposureSpeed = r, this.shutterLimit = n, this.analogGainLimit = a, this.whiteBalanceSpeed = s, this.rgbGainLimit = o;
  }
  /**
   * Packs the settings into 9 bytes.
   * @returns Uint8Array Binary representation of the message (9 bytes)
   */
  pack() {
    const i = new ArrayBuffer(9), t = new DataView(i);
    return t.setUint8(0, this.meteringIndex & 255), t.setUint8(1, Math.trunc(this.exposure * 255) & 255), t.setUint8(2, Math.trunc(this.exposureSpeed * 255) & 255), t.setUint16(3, this.shutterLimit & 16383, !1), t.setUint8(5, this.analogGainLimit & 255), t.setUint8(6, Math.trunc(this.whiteBalanceSpeed * 255) & 255), t.setUint16(7, this.rgbGainLimit & 1023, !1), new Uint8Array(i);
  }
}
class TxSpriteCoords {
  /**
   * @param code Unsigned byte identifying the sprite code.
   * @param x X-coordinate for sprite position (1..640).
   * @param y Y-coordinate for sprite position (1..400).
   * @param offset Palette offset value for the sprite (0..15). Defaults to 0.
   */
  constructor(i, t, r, n = 0) {
    /**
     * Unsigned byte identifying the sprite code
     */
    $e(this, "code");
    /**
     * X-coordinate for sprite position (1..640)
     */
    $e(this, "x");
    /**
     * Y-coordinate for sprite position (1..400)
     */
    $e(this, "y");
    /**
     * Palette offset value for the sprite (0..15)
     */
    $e(this, "offset");
    this.code = i, this.x = t, this.y = r, this.offset = n;
  }
  /**
   * Packs the message into a binary format.
   * @returns Uint8Array Binary representation of the message in the format:
   * [code, x_msb, x_lsb, y_msb, y_lsb, offset]
   * (6 bytes)
   */
  pack() {
    const i = new ArrayBuffer(6), t = new DataView(i);
    return t.setUint8(0, this.code & 255), t.setUint16(1, this.x & 65535, !1), t.setUint16(3, this.y & 65535, !1), t.setUint8(5, this.offset & 255), new Uint8Array(i);
  }
}
class TxTextSpriteBlock {
  /**
   * @param options Configuration options for the text sprite block.
   */
  constructor(i) {
    $e(this, "width");
    $e(this, "fontSize");
    $e(this, "maxDisplayRows");
    $e(this, "text");
    $e(this, "fontFamily");
    $e(this, "sprites", []);
    this.width = i.width, this.fontSize = i.fontSize, this.maxDisplayRows = i.maxDisplayRows, this.text = i.text, this.fontFamily = i.fontFamily || "sans-serif", this._createTextSprites();
  }
  /**
   * Creates sprites from the rendered text using the browser's Canvas API.
   */
  _createTextSprites() {
    const i = this.fontSize * this.maxDisplayRows;
    if (this.width <= 0 || i <= 0)
      return;
    const t = document.createElement("canvas");
    t.width = this.width, t.height = i;
    const r = t.getContext("2d", { willReadFrequently: !0 });
    if (!r) {
      console.error("TxTextSpriteBlock: Could not get 2D rendering context.");
      return;
    }
    r.fillStyle = "black", r.fillRect(0, 0, t.width, t.height), r.fillStyle = "white", r.font = `${this.fontSize}px ${this.fontFamily}`, r.textBaseline = "top";
    const n = this.text.split(`
`);
    let a = 0;
    const s = [];
    for (let o = 0; o < n.length && !(s.length >= this.maxDisplayRows); o++)
      s.push({
        text: n[o],
        drawY: a
      }), a += this.fontSize;
    for (const o of s) {
      const { text: h, drawY: l } = o;
      r.fillText(h, 0, l);
      const f = r.getImageData(0, l, this.width, this.fontSize), { data: b, width: w, height: g } = f;
      let E = w, k = g, A = -1, T = -1, C = !1;
      for (let D = 0; D < g; D++)
        for (let $ = 0; $ < w; $++)
          b[(D * w + $) * 4] > 0 && (C = !0, $ < E && (E = $), $ > A && (A = $), D < k && (k = D), D > T && (T = D));
      if (C) {
        const D = E, $ = l + k, P = A - E + 1, z = T - k + 1, B = r.getImageData(
          D,
          $,
          P,
          z
        ), { data: F, width: O, height: N } = B, G = new Uint8Array(O * N);
        for (let J = 0, Q = 0; J < F.length; J += 4, Q++)
          G[Q] = F[J] > 127 ? 1 : 0;
        const V = new TxSprite(
          O,
          N,
          2,
          new Uint8Array([0, 0, 0, 255, 255, 255]),
          G,
          !1
        );
        this.sprites.push(V);
      }
    }
  }
  /**
   * Packs the text block header and sprite offsets into a binary format.
   * @returns Uint8Array Binary representation of the text block.
   * @throws Error if there are no sprites to pack.
   */
  pack() {
    if (this.sprites.length === 0)
      throw new Error("TxTextSpriteBlock: No sprites to pack. Text might be empty or not renderable within constraints.");
    const i = 5, t = this.sprites.length * 4, r = i + t, n = new ArrayBuffer(r), a = new DataView(n);
    let s = 0;
    a.setUint8(s, 255), s += 1, a.setUint16(s, this.width, !1), s += 2, a.setUint8(s, this.maxDisplayRows & 255), s += 1, a.setUint8(s, this.sprites.length & 255), s += 1;
    let o = 0;
    for (const h of this.sprites)
      a.setUint16(s, 0, !1), s += 2, a.setUint16(s, o, !1), s += 2, o += h.height;
    return new Uint8Array(n);
  }
}
var RxAudioSampleRate = /* @__PURE__ */ ((e) => (e[e.SAMPLE_RATE_8KHZ = 8e3] = "SAMPLE_RATE_8KHZ", e[e.SAMPLE_RATE_16KHZ = 16e3] = "SAMPLE_RATE_16KHZ", e))(RxAudioSampleRate || {}), RxAudioBitDepth = /* @__PURE__ */ ((e) => (e[e.BIT_DEPTH_8 = 8] = "BIT_DEPTH_8", e[e.BIT_DEPTH_16 = 16] = "BIT_DEPTH_16", e))(RxAudioBitDepth || {});
class RxAudio {
  // Used to accumulate chunks in non-streaming mode
  constructor(i = {}) {
    $e(this, "nonFinalChunkFlag");
    $e(this, "finalChunkFlag");
    $e(this, "streaming");
    $e(this, "bitDepth");
    // 8 or 16
    $e(this, "sampleRate");
    // 8000 or 16000
    $e(this, "queue");
    $e(this, "_audioBuffer");
    this.nonFinalChunkFlag = i.nonFinalChunkFlag ?? 5, this.finalChunkFlag = i.finalChunkFlag ?? 6, this.streaming = i.streaming ?? !1, this.sampleRate = i.sampleRate ?? 8e3, this.bitDepth = i.bitDepth ?? 8, this.queue = null, this._audioBuffer = [];
  }
  concatenateAudioData() {
    let i = 0;
    for (const n of this._audioBuffer)
      i += n.length;
    const t = new Uint8Array(i);
    let r = 0;
    for (const n of this._audioBuffer)
      t.set(n, r), r += n.length;
    return t;
  }
  handleData(i) {
    if (!this.queue) {
      console.warn("RxAudio: Received data but queue not initialized - call attach() first");
      return;
    }
    const t = i[0], r = i.slice(1);
    if (this.streaming)
      r.length > 0 && this.queue.put(this.bitDepth === 8 ? Int8Array.from(r) : new Int16Array(r.buffer)), t === this.finalChunkFlag && this.queue.put(null);
    else if (this._audioBuffer.push(r), t === this.finalChunkFlag) {
      const n = this.concatenateAudioData();
      this._audioBuffer = [], this.queue.put(this.bitDepth === 8 ? Int8Array.from(n) : new Int16Array(n.buffer)), this.queue.put(null);
    }
  }
  async attach(i) {
    return this.queue = new AsyncQueue(), this._audioBuffer = [], i.registerDataResponseHandler(
      this,
      [this.nonFinalChunkFlag, this.finalChunkFlag],
      this.handleData.bind(this)
      //
    ), this.queue;
  }
  detach(i) {
    i.unregisterDataResponseHandler(this), this.queue && this.queue.clear(), this.queue = null, this._audioBuffer = [];
  }
  static writeString(i, t, r) {
    for (let n = 0; n < r.length; n++)
      i.setUint8(t + n, r.charCodeAt(n));
  }
  static toWavBytes(i, t = 8e3, r = 8, n = 1) {
    const a = t * n * (r / 8), s = i.length, o = 36 + s, h = 44, l = new ArrayBuffer(h + s), f = new DataView(l);
    let b = 0;
    if (RxAudio.writeString(f, b, "RIFF"), b += 4, f.setUint32(b, o, !0), b += 4, RxAudio.writeString(f, b, "WAVE"), b += 4, RxAudio.writeString(f, b, "fmt "), b += 4, f.setUint32(b, 16, !0), b += 4, f.setUint16(b, 1, !0), b += 2, f.setUint16(b, n, !0), b += 2, f.setUint32(b, t, !0), b += 4, f.setUint32(b, a, !0), b += 4, f.setUint16(b, n * (r / 8), !0), b += 2, f.setUint16(b, r, !0), b += 2, RxAudio.writeString(f, b, "data"), b += 4, f.setUint32(b, s, !0), b += 4, r === 8) {
      const w = new Uint8Array(l, b, s);
      for (let g = 0; g < s; g++) {
        const E = i[g] < 128 ? i[g] : i[g] - 256;
        w[g] = E + 128;
      }
    } else
      new Uint8Array(l, b).set(i);
    return new Uint8Array(l);
  }
  // --- Helper function to convert signed 8-bit PCM (provided as a raw uint8 array) to Float32Array scaled to [-1.0, 1.0] ---
  static pcm8BitToFloat32(i) {
    const t = i.length, r = new Float32Array(t), n = new Int8Array(i.buffer, i.byteOffset, t);
    for (let a = 0; a < t; a++)
      r[a] = n[a] / 64, r[a] < -1 ? r[a] = -1 : r[a] > 1 && (r[a] = 1);
    return r;
  }
  // --- Helper function to convert signed 16-bit PCM (provided as a raw uint8 array) to Float32Array scaled to [-1.0, 1.0] ---
  static pcm16BitToFloat32(i) {
    const t = i.length / 2, r = new Float32Array(t), n = new DataView(i.buffer, i.byteOffset, i.byteLength);
    for (let a = 0; a < t; a++) {
      let o = n.getInt16(a * 2) / 16384;
      o < -1 ? o = -1 : o > 1 && (o = 1), r[a] = o;
    }
    return r;
  }
}
class SensorBuffer {
  constructor(i) {
    $e(this, "maxSize");
    $e(this, "_buffer");
    this.maxSize = i, this._buffer = [];
  }
  add(i) {
    this._buffer.push(i), this._buffer.length > this.maxSize && this._buffer.shift();
  }
  get average() {
    if (!this._buffer.length)
      return [0, 0, 0];
    let i = 0, t = 0, r = 0;
    for (const [a, s, o] of this._buffer)
      i += a, t += s, r += o;
    const n = this._buffer.length;
    return [
      Math.trunc(i / n),
      Math.trunc(t / n),
      Math.trunc(r / n)
    ];
  }
}
class IMUData {
  constructor(i, t, r) {
    $e(this, "compass");
    $e(this, "accel");
    $e(this, "raw");
    this.compass = i, this.accel = t, this.raw = r;
  }
  get pitch() {
    return Math.atan2(this.accel[1], this.accel[2]) * 180 / Math.PI;
  }
  get roll() {
    return Math.atan2(this.accel[0], this.accel[2]) * 180 / Math.PI;
  }
}
class RxIMU {
  constructor(i = {}) {
    $e(this, "imuFlag");
    $e(this, "smoothingSamples");
    $e(this, "queue");
    $e(this, "compassBuffer");
    $e(this, "accelBuffer");
    this.imuFlag = i.imuFlag ?? 10, this.smoothingSamples = i.smoothingSamples ?? 1, this.queue = null, this.compassBuffer = new SensorBuffer(this.smoothingSamples), this.accelBuffer = new SensorBuffer(this.smoothingSamples);
  }
  /**
   * Process incoming IMU data packets.
   * @param data Uint8Array containing IMU data with flag byte prefix.
   */
  handleData(i) {
    if (!this.queue) {
      console.warn("RxIMU: Received data but queue not initialized - call attach() first");
      return;
    }
    if (i.length < 14) {
      console.warn("RxIMU: Data packet too short for IMU data.");
      return;
    }
    const t = new DataView(i.buffer, i.byteOffset), r = [];
    for (let o = 0; o < 6; o++)
      r.push(t.getInt16(2 + o * 2, !0));
    const n = [r[0], r[1], r[2]], a = [r[3], r[4], r[5]];
    this.compassBuffer.add(n), this.accelBuffer.add(a);
    const s = new IMUData(
      this.compassBuffer.average,
      //
      this.accelBuffer.average,
      //
      {
        compass: n,
        accel: a
      }
    );
    this.queue.put(s);
  }
  /**
   * Attach the IMU handler to the Frame data response.
   * @param frame The FrameMsg instance.
   * @returns A promise that resolves to an AsyncQueue that will receive IMUData objects.
   */
  async attach(i) {
    return this.queue = new AsyncQueue(), i.registerDataResponseHandler(
      this,
      [this.imuFlag],
      this.handleData.bind(this)
    ), this.queue;
  }
  /**
   * Detach the IMU handler from the Frame data response and clean up resources.
   * @param frame The FrameMsg instance.
   */
  detach(i) {
    i.unregisterDataResponseHandler(this), this.queue && this.queue.clear(), this.queue = null;
  }
}
class RxMeteringData {
  constructor(i = {}) {
    $e(this, "msgCode");
    $e(this, "queue");
    this.msgCode = i.msgCode ?? 18, this.queue = null;
  }
  /**
   * Process incoming metering data packets.
   * @param data Uint8Array containing metering data with a flag byte prefix,
   * followed by 6 unsigned bytes (spot r,g,b, matrix r,g,b).
   */
  handleData(i) {
    if (!this.queue) {
      console.warn("RxMeteringData: Received data but queue not initialized - call attach() first");
      return;
    }
    if (i.length < 7) {
      console.warn("RxMeteringData: Data packet too short for metering data.");
      return;
    }
    const t = {
      spot_r: i[1],
      // unpacked[0]
      spot_g: i[2],
      // unpacked[1]
      spot_b: i[3],
      // unpacked[2]
      matrix_r: i[4],
      // unpacked[3]
      matrix_g: i[5],
      // unpacked[4]
      matrix_b: i[6]
      // unpacked[5]
    };
    this.queue.put(t);
  }
  /**
   * Attach the receive handler to the Frame data response.
   * @param frame The FrameMsg instance.
   * @returns A promise that resolves to an AsyncQueue that will receive MeteringData objects.
   */
  async attach(i) {
    return this.queue = new AsyncQueue(), i.registerDataResponseHandler(
      this,
      [this.msgCode],
      this.handleData.bind(this)
    ), this.queue;
  }
  /**
   * Detach the receive handler from the Frame data response and clean up resources.
   * @param frame The FrameMsg instance.
   */
  detach(i) {
    i.unregisterDataResponseHandler(this), this.queue && this.queue.clear(), this.queue = null;
  }
}
class RxAutoExpResult {
  /**
   * Initialize receive handler for processing auto exposure result data.
   * @param options Configuration options for the handler.
   * Includes `msgCode` (default: 0x11)
   */
  constructor(i = {}) {
    $e(this, "msgCode");
    $e(this, "queue");
    this.msgCode = i.msgCode ?? 17, this.queue = null;
  }
  /**
   * Process incoming auto exposure result data packets.
   * @param data Uint8Array containing auto exposure result data with a flag byte prefix,
   * followed by 16 little-endian floats (64 bytes).
   */
  handleData(i) {
    if (!this.queue) {
      console.warn("RxAutoExpResult: Received data but queue not initialized - call attach() first");
      return;
    }
    if (i.length < 65) {
      console.warn(`RxAutoExpResult: Data packet too short for auto exposure result data. Expected 65 bytes, got ${i.length}.`);
      return;
    }
    const t = new DataView(i.buffer, i.byteOffset, i.byteLength), r = !0;
    let n = 1;
    const a = [];
    for (let o = 0; o < 16; o++)
      a.push(t.getFloat32(n, r)), n += 4;
    const s = {
      error: a[0],
      //
      shutter: a[1],
      //
      analog_gain: a[2],
      //
      red_gain: a[3],
      //
      green_gain: a[4],
      //
      blue_gain: a[5],
      //
      brightness: {
        center_weighted_average: a[6],
        //
        scene: a[7],
        //
        matrix: {
          r: a[8],
          //
          g: a[9],
          //
          b: a[10],
          //
          average: a[11]
          //
        },
        spot: {
          r: a[12],
          //
          g: a[13],
          //
          b: a[14],
          //
          average: a[15]
          //
        }
      }
    };
    this.queue.put(s);
  }
  /**
   * Attach the receive handler to the Frame data response.
   * @param frame The FrameMsg instance.
   * @returns A promise that resolves to an AsyncQueue that will receive AutoExpResultData objects.
   */
  async attach(i) {
    return this.queue = new AsyncQueue(), i.registerDataResponseHandler(
      this,
      [this.msgCode],
      this.handleData.bind(this)
      //
    ), this.queue;
  }
  /**
   * Detach the receive handler from the Frame data response and clean up resources.
   * @param frame The FrameMsg instance.
   */
  detach(i) {
    i.unregisterDataResponseHandler(this), this.queue && this.queue.clear(), this.queue = null;
  }
}
const Rt = class Rt {
  constructor(i = {}) {
    $e(this, "nonFinalChunkFlag");
    $e(this, "finalChunkFlag");
    $e(this, "upright");
    $e(this, "isRaw");
    $e(this, "quality");
    $e(this, "resolution");
    $e(this, "queue");
    $e(this, "_imageDataChunks");
    this.nonFinalChunkFlag = i.nonFinalChunkFlag ?? 7, this.finalChunkFlag = i.finalChunkFlag ?? 8, this.upright = i.upright ?? !0, this.isRaw = i.isRaw ?? !1, this.quality = i.quality ?? null, this.resolution = i.resolution ?? null, this.queue = null, this._imageDataChunks = [];
  }
  static hasJpegHeader(i, t) {
    return `${i}_${t}` in Rt._jpegHeaderMap;
  }
  concatenateImageData() {
    let i = 0;
    for (const n of this._imageDataChunks)
      i += n.length;
    const t = new Uint8Array(i);
    let r = 0;
    for (const n of this._imageDataChunks)
      t.set(n, r), r += n.length;
    return t;
  }
  handleData(i) {
    if (!this.queue) {
      console.warn("RxPhoto: Received data but queue not initialized - call attach() first");
      return;
    }
    const t = i[0], r = i.slice(1);
    this._imageDataChunks.push(r), t === this.finalChunkFlag && this._processCompleteImage().catch((n) => {
      console.error("RxPhoto: Error processing complete image:", n), this._imageDataChunks = [];
    });
  }
  async _processCompleteImage() {
    if (!this.queue) return;
    let i;
    const t = this.concatenateImageData();
    if (this._imageDataChunks = [], this.isRaw) {
      if (!this.quality || !this.resolution)
        throw new Error("RxPhoto: Quality and resolution must be set for raw images if no header is cached.");
      const r = `${this.quality}_${this.resolution}`, n = Rt._jpegHeaderMap[r];
      if (!n)
        throw new Error(
          `RxPhoto: No JPEG header found for quality ${this.quality} and resolution ${this.resolution} - request full JPEG first to cache header.`
        );
      const a = new Uint8Array(n.length + t.length);
      a.set(n, 0), a.set(t, n.length), i = a;
    } else if (i = t, this.quality && this.resolution) {
      const r = `${this.quality}_${this.resolution}`;
      if (!Rt._jpegHeaderMap[r]) {
        const n = i.slice(0, 623);
        Rt._jpegHeaderMap[r] = n;
      }
    }
    this.upright ? (console.log("Rotating image 90 degrees counter-clockwise"), this.queue.put(await this.rotateJpeg90CounterClockwise(i))) : this.queue.put(i);
  }
  async attach(i) {
    return this.isRaw && (!this.quality || !this.resolution) && console.warn("RxPhoto: Handling raw images without quality/resolution specified. Header must be pre-cached or will fail."), this.queue = new AsyncQueue(), this._imageDataChunks = [], i.registerDataResponseHandler(
      this,
      [this.nonFinalChunkFlag, this.finalChunkFlag],
      this.handleData.bind(this)
    ), this.queue;
  }
  detach(i) {
    i.unregisterDataResponseHandler(this), this.queue && this.queue.clear(), this.queue = null, this._imageDataChunks = [];
  }
  /**
   * Rotates a JPEG image 90 degrees counter-clockwise using an offscreen canvas.
   * @param inputBytes The input JPEG image as a Uint8Array.
   * @returns the rotated JPEG image as a Uint8Array.
   */
  async rotateJpeg90CounterClockwise(i) {
    const t = jpeg.decode(i, { useTArray: !0 });
    if (!t || !t.data || !t.width || !t.height)
      throw new Error("Failed to decode JPEG image.");
    const r = document.createElement("canvas");
    r.width = t.height, r.height = t.width;
    const n = r.getContext("2d");
    if (!n)
      throw new Error("Failed to get canvas 2D context.");
    const a = document.createElement("canvas");
    a.width = t.width, a.height = t.height;
    const s = a.getContext("2d");
    if (!s)
      throw new Error("Failed to get temporary canvas 2D context.");
    s.putImageData(new ImageData(
      new Uint8ClampedArray(t.data.buffer),
      t.width,
      t.height
    ), 0, 0), n.clearRect(0, 0, r.width, r.height), n.translate(0, r.height), n.rotate(-90 * Math.PI / 180), n.drawImage(a, 0, 0);
    const h = await (await new Promise((l, f) => {
      r.toBlob((b) => {
        b ? l(b) : f(new Error("Failed to convert canvas to JPEG blob."));
      }, "image/jpeg");
    })).arrayBuffer();
    return new Uint8Array(h);
  }
};
$e(Rt, "_jpegHeaderMap", {});
let RxPhoto = Rt;
class RxTap {
  constructor(i = 9, t = 0.3) {
    $e(this, "tapFlag");
    $e(this, "threshold");
    // in milliseconds
    $e(this, "queue");
    $e(this, "lastTapTime");
    $e(this, "tapCount");
    $e(this, "thresholdTimeoutId");
    this.tapFlag = i, this.threshold = t * 1e3, this.queue = null, this.lastTapTime = 0, this.tapCount = 0, this.thresholdTimeoutId = null;
  }
  async resetThresholdTimer() {
    this.thresholdTimeoutId && (clearTimeout(this.thresholdTimeoutId), this.thresholdTimeoutId = null), this.thresholdTimeoutId = setTimeout(() => {
      this.thresholdTimeout();
    }, this.threshold);
  }
  thresholdTimeout() {
    this.queue && this.tapCount > 0 && (this.queue.put(this.tapCount), this.tapCount = 0), this.thresholdTimeoutId = null;
  }
  // The data handler now expects a Uint8Array as per FrameMsg.ts
  handleData(i) {
    if (!this.queue) {
      console.warn("RxTap: Received data but queue not initialized - call attach() first");
      return;
    }
    const t = Date.now();
    if (t - this.lastTapTime < 40) {
      this.lastTapTime = t;
      return;
    }
    this.lastTapTime = t, this.tapCount += 1, this.resetThresholdTimer();
  }
  async attach(i) {
    return this.queue = new AsyncQueue(), this.lastTapTime = 0, this.tapCount = 0, i.registerDataResponseHandler(this, [this.tapFlag], this.handleData.bind(this)), this.queue;
  }
  detach(i) {
    i.unregisterDataResponseHandler(this), this.thresholdTimeoutId && (clearTimeout(this.thresholdTimeoutId), this.thresholdTimeoutId = null), this.queue && this.queue.clear(), this.queue = null, this.tapCount = 0;
  }
}
export {
  AsyncQueue,
  FrameMsg,
  IMUData,
  RxAudio,
  RxAudioBitDepth,
  RxAudioSampleRate,
  RxAutoExpResult,
  RxIMU,
  RxMeteringData,
  RxPhoto,
  RxTap,
  StdLua,
  TxAutoExpSettings,
  TxCaptureSettings,
  TxCode,
  TxImageSpriteBlock,
  TxManualExpSettings,
  TxPlainText,
  TxSprite,
  TxSpriteCoords,
  TxTextSpriteBlock
};
